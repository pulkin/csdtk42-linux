<bigarchive>

<archive relative="****phantomglobalvars****">
    <var global="yes" name="SPC_IF_VER" value="3"/>
    <var global="yes" name="CHIP_ASIC_ID" value="6"/>
    <var global="yes" name="CHIP_EDGE_SUPPORTED" value="0"/>
    <var global="yes" name="CHIP_HAS_AP" value="0"/>
    <var global="yes" name="CHIP_HAS_WCPU" value="0"/>
    <var global="yes" name="CHIP_HAS_USB" value="1"/>
    <var global="yes" name="CHIP_WITH_VOC" value="1"/>
    <var global="yes" name="CHIP_WITH_VOC_ROM" value="0"/>
    <var global="yes" name="ROM_VERSION_ADDRESS" value="0x81e13ff8"/>
    <var global="yes" name="BOOT_SECTOR_CODE_ADDRESS" value="0x82000010"/>
    <var global="yes" name="XCPU_ERROR_INFO_ADDRESS" value="0x81c000b8"/>
    <var global="yes" name="BCPU_ERROR_INFO_ADDRESS" value="0x81983270"/>
    <var global="yes" name="MAP_TABLE_PTR_ADDRESS" value="0x81c0027c"/>
    <var global="yes" name="HOST_MONITOR_CONTROL_ADDRESS" value="0x81c000a0"/>
    <var global="yes" name="BOOT_HOST_USB_MONITOR_VAR_PTR_ADDRESS" value="0x81e00ffc"/>
    <var global="yes" name="BOOT_SECTOR_STRUCT_PTR_ADDRESS" value="0x81c00278"/>
    <var global="yes" name="USE_VOC_XMD" value="0"/>

</archive>

<archive relative='../../../platform/chip/hal/include/hal_map_engine.xmd'  asm="no">

    <comment>
        @defgroup map HAL Map Driver
        <br/>
        This file contains the functions controlling the MAP engine of HAL.
        This engine allows any module to describe its memory map in XMD
        format so that CoolWatcher (or any CoolXml tool) can access it.
        <br/>
        @{
    </comment>

    <include load="no" file="hal_error.h"/>

    
    <typedef name="HAL_MAP_VERSION_T">
        <comment>
            Type used to define the version of a software module.
        </comment>
        <uint32          name="revision"/>
        <uint32          name="number"/>
        <uint32          name="date"/>
        <ptr type="int8" name="string"/>
    </typedef>

    
    <typedef name="HAL_MAP_MODULE_T">
        <comment>
            Type used to access the version and the memory map of a soft module.
        </comment>
        <ptr type="HAL_MAP_VERSION_T" name="version"/>
        <ptr type="void"              name="access"/>
    </typedef>

    
    <enum name="HAL_MAP_ID_T">
        <comment>
            Software modules identifiers.
            Caution, these values are also used in the file "csw_ver.h".
            Must be compatible with the type MAP_TABLE_T of "chipstd_soft_root.xmd".
        </comment>
        <entry name="HAL_MAP_ID_HAL"/>
        <entry name="HAL_MAP_ID_PAL"/>
        <entry name="HAL_MAP_ID_SPAL"/>
        <entry name="HAL_MAP_ID_SPP"/>
        <entry name="HAL_MAP_ID_SPC"/>
        <entry name="HAL_MAP_ID_RFD"/>
        <entry name="HAL_MAP_ID_FREE1"/>
        <entry name="HAL_MAP_ID_AT"/>
        <entry name="HAL_MAP_ID_MEMD"/>
        <entry name="HAL_MAP_ID_PMD"/>
        <entry name="HAL_MAP_ID_STACK"/>
        <entry name="HAL_MAP_ID_VPP"/>
        <entry name="HAL_MAP_ID_SX"/>
        <entry name="HAL_MAP_ID_STD"/>
        <entry name="HAL_MAP_ID_LCDD"/>
        <entry name="HAL_MAP_ID_ARS"/>
        <entry name="HAL_MAP_ID_APS"/>
        <entry name="HAL_MAP_ID_VOIS"/>
        <entry name="HAL_MAP_ID_CALIB"/>
        <entry name="HAL_MAP_ID_GTES"/>
        <entry name="HAL_MAP_ID_FLASH_PROG"/>
        <entry name="HAL_MAP_ID_CSW"/>
        <entry name="HAL_MAP_ID_MMI"/>
        <entry name="HAL_MAP_ID_AUD"/>
        <entry name="HAL_MAP_ID_MDI"/>
        <entry name="HAL_MAP_ID_BTD"/>
        
        <entry name="HAL_MAP_ID_COUNT"/>
    </enum>

    
    <typedef name="HAL_MAP_TABLE_T">
        <comment>
            Type used to access the version and the memory map of a soft module.
        </comment>
        <instance name="modules" type="HAL_MAP_MODULE_T" count="HAL_MAP_ID_COUNT"/>
    </typedef>

<cjoker>
// =============================================================================
//  FUNCTIONS
// =============================================================================



// =============================================================================
// hal_MapEngineOpen
// -----------------------------------------------------------------------------
/// Initialize the map engine so that the remote tools can access the map
/// structures of the software modules.
// =============================================================================
PUBLIC VOID hal_MapEngineOpen(VOID);



// =============================================================================
// hal_MapEngineRegisterModule
// -----------------------------------------------------------------------------
/// Configure the map access field for the specified module in the table
/// located at the address pointer by the fixed pointer.
/// @param id Id of the module for which the version and the access
/// pointer will be specified.
/// @param version Pointer to a structure giving the version information for
/// the module 'id'. This structure must be instantiated by the module 'id'.
/// @param access Pointer to a structure containing the informations that will
/// be accessible from the remote PC (e.g. through CoolWatcher). This strucutre
/// must be instantiated by the module 'id'.
/// @return HAL_ERR_NO if no error or HAL_ERR_BAD_PARAMETER if the module 'id'
/// cannot be found.
// =============================================================================
PUBLIC HAL_ERR_T hal_MapEngineRegisterModule(HAL_MAP_ID_T id, HAL_MAP_VERSION_T *version, VOID* access);


// =============================================================================
// hal_MapEnginePrintModuleVersion
// -----------------------------------------------------------------------------
/// Print a module version's string on the Trace, if the module has been
/// registered.
/// @param id Number of the Module whose version is to be put
/// on the Trace.
// =============================================================================
PUBLIC VOID hal_MapEnginePrintModuleVersion(HAL_MAP_ID_T id);


// =============================================================================
// hal_MapEnginePrintAllModulesVersion
// -----------------------------------------------------------------------------
/// Print all module version's string on the Trace.
// =============================================================================
PUBLIC VOID hal_MapEnginePrintAllModulesVersion(VOID);


// =============================================================================
// hal_MapEngineGetVersion
// -----------------------------------------------------------------------------
/// Get the pointer to the version structure of a given module.
///
/// @param id Number of the Module whose version is to be got.
/// @return Pointer to the version structure of said module.
// =============================================================================
PUBLIC CONST HAL_MAP_VERSION_T* hal_MapEngineGetVersion(HAL_MAP_ID_T id);


/// @} // --> End of the group.
</cjoker>

</archive>

<archive relative='../ChipStd/cpu_error.xmd'  h="no" asm="no">

    
    <typedef name="ERROR_CTX_T" >
        <reg name="zero" protect="r"/>
        <reg name="at" protect="r"/>
        <reg name="v0" protect="r"/>
        <reg name="v1" protect="r"/>
        <reg name="a0" protect="r"/>
        <reg name="a1" protect="r"/>
        <reg name="a2" protect="r"/>
        <reg name="a3" protect="r"/>
        <reg name="t0" protect="r"/>
        <reg name="t1" protect="r"/>
        <reg name="t2" protect="r"/>
        <reg name="t3" protect="r"/>
        <reg name="t4" protect="r"/>
        <reg name="t5" protect="r"/>
        <reg name="t6" protect="r"/>
        <reg name="t7" protect="r"/>
        <reg name="s0" protect="r"/>
        <reg name="s1" protect="r"/>
        <reg name="s2" protect="r"/>
        <reg name="s3" protect="r"/>
        <reg name="s4" protect="r"/>
        <reg name="s5" protect="r"/>
        <reg name="s6" protect="r"/>
        <reg name="s7" protect="r"/>
        <reg name="t8" protect="r"/>
        <reg name="t9" protect="r"/>
        <reg name="k0" protect="r"/>
        <reg name="k1" protect="r"/>
        <reg name="gp" protect="r"/>
        <reg name="sp" protect="r"/>
        <reg name="fp" protect="r"/>
        <reg name="ra" protect="r"/>
        <reg name="sr" protect="r"/>
        <reg name="lo" protect="r"/>
        <reg name="hi" protect="r"/>
        <reg name="bad" protect="r"/>
        <reg name="cause" protect="r">
            <bits name="cp0_Cause_ExcCode" pos="5:2" access="r" rst="0">
                <options>
                    <option value="0" name="Int"><comment>Interrupt</comment></option>
                    <option value="1" name="Mod"><comment>TLB modification exception</comment></option>
                    <option value="2" name="TLBL"><comment>TLB exception (load or instruction fetch)</comment></option>
                    <option value="3" name="TLBS"><comment>TLB exception (store)</comment></option>
                    <option value="4" name="AdEL"><comment>Address error exception (load or instruction fetch)</comment></option>
                    <option value="5" name="AdES"><comment>Address error exception (store)</comment></option>
                    <option value="6" name="IBE"><comment>Bus error exception (instruction fetch)</comment></option>
                    <option value="7" name="DBE"><comment>Bus error exception (data reference: load or store)</comment></option>
                    <option value="8" name="Sys"><comment>Syscall exception</comment></option>
                    <option value="9" name="Pb"><comment>Breakpoint exception</comment></option>
                    <option value="10" name="Ri"><comment>Reserved instruction exception</comment></option>
                    <option value="11" name="CpU"><comment>Coprocessor Unusable exception</comment></option>
                    <option value="12" name="Ov"><comment>Arithmetic Overflow exception</comment></option>
                    <default/>
                    <mask/>
                    <shift/>
                </options>
            </bits>
            <bits name="cp0_Cause_IP_soft" pos="9:8" access="r" rst="0">
                <comment>Theses interrupt lines are software interrupts (the cpu can write in the CP0 bits to trigger and clear them).
                </comment>
                <options>
                    <default/>
                    <mask/>
                    <shift/>
                </options>
            </bits>
            <bits name="cp0_Cause_IP_ext" pos="15:10" access="r" rst="0">
                <comment>Theses interrupt lines maps to the hardware interrupt lines from the corresponding irq module.
                </comment>
                <options>
                    <default/>
                    <mask/>
                    <shift/>
                </options>
            </bits>
            <bitgroup name="cp0_Cause_IP">
                <entry ref="cp0_Cause_IP_soft"/>
                <entry ref="cp0_Cause_IP_ext"/>
            </bitgroup>
            <bits name="cp0_Cause_CE" pos="29:28" access="r" rst="0">
                <comment>The Coprocessor Error (CE) field indicate the coprocessor unit number referenced when a Coprocessor Unusable exception is taken.
                </comment>
                <options>
                    <default/>
                    <mask/>
                    <shift/>
                </options>
            </bits>
            <bits name="cp0_Cause_BD" pos="31" access="r" rst="0">
                <comment>The Branch Delay (BD) bit indicate whether the last exception was taken while executing in a branch delay slot.
                </comment>
                <options>
                    <option value="0" name="Normal"/>
                    <option value="1" name="Delay_slot"/>
                    <mask/>
                    <shift/>
                </options>
            </bits>
        </reg>
        <reg name="pc" protect="r"/>
    </typedef>

    <typedef name="CPU_ERROR_INFO_T">
        <reg name="cpu_error_code" protect="r"/>
        <reg name="cpu_error_status" protect="r"/>
        <ptr name="cpu_sp_context" type="ERROR_CTX_T" />
        <reg name="cpu_stack_base" protect="r"/>
        <reg name="cpu_dbg_start" protect="r"/>
        <reg name="cpu_dbg_end" protect="r"/>
    </typedef>

</archive>

<archive relative='../ChipStd/host_monitor.xmd'  h="no" asm="no">


    <typedef name="HOST_MONITOR_EXECUTION_CONTEXT_T">
        <reg name="cmd_type" protect="rw"/>
        <reg name="pc" protect="rw"/>
        <reg name="sp" protect="rw" />
        <reg name="param" protect="rw"/>
        <reg name="returned_value" protect="rw"/>
    </typedef>

    <typedef name="HOST_EXTENDED_HANDLER_T">
        <reg name= "extended_command_handler" protect="rw"/>
    </typedef>

    <typedef name="HOST_MONITOR_CONTROL_T">
        <instance name="execution_context" type="HOST_MONITOR_EXECUTION_CONTEXT_T"/>
        <instance name="extended_handler"  type="HOST_EXTENDED_HANDLER_T"/>
    </typedef>

</archive>
<archive relative='../../../platform/chip/hal/include/hal_speech.xmd'  asm='no'>

    <comment>
        That file contains speech buffer structures and related functions.
        <br/>
        <br/>
        @defgroup speech HAL Speech FIFO
        <br/>
        @par Operation
        A speech FIFO is used to convey audio data from the Baseband side to
        acoustic world. PAL accesses this FIFO through #hal_SpeechPushRxPopTx,
        which puts received audio data in the Fifo and takes out audio data
        to send.
        <br/>
        @par
        On the other side, #hal_SpeechPopRxPushTx is aimed to be used by the
        VOIS service. It takes received data from the Fifo (to decode them and
        play them) and puts in it audio data to send (recorded from a mic and
        encoded),
        <br/>
        @par
        Thus, we see that the speech FIFO and its related mechanisms only manipulate
        encoded data.
        <br/>
        @{
    </comment>

<include load="no" file="cs_types.h"/>

<var name='HAL_SPEECH_FIFO_DEPTH' value='4'>
    <comment>FIFO depth.  </comment>
</var>

<enum name='HAL_SPEECH_MODE'>
    <comment>HAL Speech modes</comment>

    <entry name='HAL_AMR475_DEC' value='0x00f0'></entry>
    <entry name='HAL_AMR475_ENC' value='0x000f'></entry>
    <entry name='HAL_AMR515_DEC' value='0x00f1'></entry>
    <entry name='HAL_AMR515_ENC' value='0x001f'></entry>
    <entry name='HAL_AMR59_DEC' value='0x00f2'></entry>
    <entry name='HAL_AMR59_ENC' value='0x002f'></entry>
    <entry name='HAL_AMR67_DEC' value='0x00f3'></entry>
    <entry name='HAL_AMR67_ENC' value='0x003f'></entry>
    <entry name='HAL_AMR74_DEC' value='0x00f4'></entry>
    <entry name='HAL_AMR74_ENC' value='0x004f'></entry>
    <entry name='HAL_AMR795_DEC' value='0x00f5'></entry>
    <entry name='HAL_AMR795_ENC' value='0x005f'></entry>
    <entry name='HAL_AMR102_DEC' value='0x00f6'></entry>
    <entry name='HAL_AMR102_ENC' value='0x006f'></entry>
    <entry name='HAL_AMR122_DEC' value='0x00f7'></entry>
    <entry name='HAL_AMR122_ENC' value='0x007f'></entry>
    <entry name='HAL_EFR' value='0x0177'></entry>
    <entry name='HAL_FR' value='0x1fff'></entry>
    <entry name='HAL_HR' value='0x2fff'></entry>
    <entry name='HAL_INVALID' value='0xffff'></entry>
</enum>

<enum name='HAL_SPEECH_FRAME_SIZE'>
    <comment>Size of the frame in bytes, for the various supported codecs.  </comment>

    <entry name='HAL_SPEECH_FRAME_SIZE_AMR475' value='12'></entry>
    <entry name='HAL_SPEECH_FRAME_SIZE_AMR515' value='16'></entry>
    <entry name='HAL_SPEECH_FRAME_SIZE_AMR59' value='16'></entry>
    <entry name='HAL_SPEECH_FRAME_SIZE_AMR67' value='20'></entry>
    <entry name='HAL_SPEECH_FRAME_SIZE_AMR74' value='20'></entry>
    <entry name='HAL_SPEECH_FRAME_SIZE_AMR795' value='20'></entry>
    <entry name='HAL_SPEECH_FRAME_SIZE_AMR102' value='28'></entry>
    <entry name='HAL_SPEECH_FRAME_SIZE_AMR122' value='32'></entry>
    <entry name='HAL_SPEECH_FRAME_SIZE_AMR_RING' value='32'></entry>
    <entry name='HAL_SPEECH_FRAME_SIZE_EFR' value='32'></entry>
    <entry name='HAL_SPEECH_FRAME_SIZE_FR' value='36'></entry>
    <entry name='HAL_SPEECH_FRAME_SIZE_HR' value='16'></entry>
    <entry name='HAL_SPEECH_FRAME_SIZE_COD_BUF' value='36'></entry>
    <entry name='HAL_SPEECH_FRAME_SIZE_PCM_BUF' value='320'></entry>
</enum>

<typedef name='HAL_SPEECH_ENC_OUT'>
    <comment>Structure used to configure VOC frame encode</comment>

    <uint16 name='encMode'>
        <comment>Mode of the voice coded output frame</comment>
    </uint16>
    <uint16 name='encFrameType'>
        <comment>Type of the coded output frame (AMR only)</comment>
    </uint16>
    <uint16 name='echoSkipEncFrame'>
        <comment>Flag for skipping the encoded frame, only valid when the ES is activated (replaces the unused VAD flag)</comment>
    </uint16>
    <uint16 name='sp'>
        <comment>Speech flag (all except AMR)</comment>
    </uint16>
    <uint16 name='encOutBuf' count='HAL_SPEECH_FRAME_SIZE_COD_BUF/2'>
        <comment>Encoder output buffer (coded frame in enc_mode)</comment>
    </uint16>
</typedef>

<typedef name='HAL_SPEECH_DEC_IN'>
    <comment>Structure used to configure VOC frame decode</comment>

    <uint16 name='dtxOn'>
        <comment>DTX allowed by the network, active->G1</comment>
    </uint16>
    <uint16 name='codecMode'>
        <comment>mode of the voice coded input frame and of the next encoder speech frame output</comment>
    </uint16>
    <uint16 name='decFrameType'>
        <comment>Type of the coded input frame (AMR only)</comment>
    </uint16>
    <uint16 name='bfi'>
        <comment>BFI flag (all vocoders except AMR)</comment>
    </uint16>
    <uint16 name='sid'>
        <comment>SID flag (all vocoders except AMR)</comment>
    </uint16>
    <uint16 name='taf'>
        <comment>TAF flag (all vocoders except AMR)</comment>
    </uint16>
    <uint16 name='ufi'>
        <comment>UFI flag (HR only)</comment>
    </uint16>
    <uint16 name='reserved'>
        <comment>Reserved</comment>
    </uint16>
    <uint16 name='decInBuf' count='HAL_SPEECH_FRAME_SIZE_COD_BUF/2'>
        <comment>Decoder input buffer (coded frame in dec_mode)</comment>
    </uint16>
</typedef>


<enum name='HAL_RX_FRAME_TYPE'>
    <comment>AMR enum</comment>

    <entry name='HAL_RX_SPEECH_GOOD'></entry>
    <entry name='HAL_RX_SPEECH_DEGRADED'></entry>
    <entry name='HAL_RX_ONSET'></entry>
    <entry name='HAL_RX_SPEECH_BAD'></entry>
    <entry name='HAL_RX_SID_FIRST'></entry>
    <entry name='HAL_RX_SID_UPDATE'></entry>
    <entry name='HAL_RX_SID_BAD'></entry>
    <entry name='HAL_RX_NO_DATA'></entry>
</enum>

<enum name='HAL_TX_FRAME_TYPE'>
    <entry name='HAL_TX_SPEECH'></entry>
    <entry name='HAL_TX_SID_FIRST'></entry>
    <entry name='HAL_TX_SID_UPDATE'></entry>
    <entry name='HAL_TX_NO_DATA'></entry>
</enum>





<alias name='HAL_SPEECH_PCM_HALF_BUF'>
    <uint16 name='unused' count='HAL_SPEECH_FRAME_SIZE_PCM_BUF/2'>
        <comment>PCM Half buffer type. Two of them are packed to become a ping-pong buffer.</comment>
    </uint16>
</alias>

<typedef name='HAL_SPEECH_PCM_BUF'>
    <comment>Structure defining the Speech PCM swap buffers used in Speech encoding and decoding</comment>

    <instance name='pcmBuf' type='HAL_SPEECH_PCM_HALF_BUF' count='2'>
        <comment>A couple of Speech PCM swap buffers</comment>
    </instance>
</typedef>

<typedef name='HAL_SPEECH_FIFO_ELM_T'>
    <comment>
        This types describes a Fifo section. Rx and Tx are joined together because
        the we always read and write one Rx and a Tx (or inversly) at the same time.
    </comment>
    <instance name="rx" type="HAL_SPEECH_DEC_IN">
        <comment>
            Received encoded frame
        </comment>
    </instance>
    <instance name="tx" type="HAL_SPEECH_ENC_OUT">
        <comment>
            Encoded Frame to transmit
        </comment>
    </instance>
</typedef>

<typedef name="HAL_SPEECH_FIFO_T">
    <instance   name='fifo' type='HAL_SPEECH_FIFO_ELM_T' count='HAL_SPEECH_FIFO_DEPTH'/>
    <bool       name='rxOverflowTxUnderflow'>
        <comment>
            That boolean is set to TRUE when the Speech Fifo Rx has overflowed,
            which also corresponds to a Tx underflow.
            The reset is manual through coolwatcher.
        </comment>
    </bool>
    <bool       name='txOverflowRxUnderflow' >
        <comment>
            That boolean is set to TRUE when the Speech Fifo Tx has overflowed,
            which also corresponds to a Rx underflow.
            This is normally expected in case of handover, for example.
            The reset is manual through coolwatcher.
        </comment>
    </bool>
</typedef>

<cjoker>
// =============================================================================
// FUNCTIONS
// =============================================================================

// =============================================================================
// hal_SpeechFifoReset
// -----------------------------------------------------------------------------
/// Initializes the speech related mechanisms in HAL (Speech Fifo, ...)
// =============================================================================
PUBLIC VOID hal_SpeechFifoReset(VOID);

// =============================================================================
// hal_SpeechPushRxPopTx
// -----------------------------------------------------------------------------
/// PAL side of the FIFO accessor.
///
/// @param pushedRx Pointer to the received trame to push in the FIFO
/// @param popedTx Pointer to the buffer where the trame to send will
/// be copied.
// =============================================================================
PUBLIC VOID hal_SpeechPushRxPopTx(CONST HAL_SPEECH_DEC_IN_T* pushedRx,
HAL_SPEECH_ENC_OUT_T* popedTx);

// =============================================================================
// hal_SpeechPopRxPushTx
// -----------------------------------------------------------------------------
/// Vois side of the FIFO accessor.
///
/// @param popedRx Pointer where to copy the received trame.
/// @param pushedTx Pointer to the trame to send to push in the FIFO.
// =============================================================================
PUBLIC VOID hal_SpeechPopRxPushTx(HAL_SPEECH_DEC_IN_T* popedRx,
CONST HAL_SPEECH_ENC_OUT_T* pushedTx);

/// @} // --> End of the Speech group.

</cjoker>
</archive>

<archive relative='../../../platform/chip/hal/include/hal_map.xmd'  asm="no">


    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    
    <include file="hal_speech.xmd"/>

    <typedef name="hal_map_globals" rubyconstants="yes"></typedef>

    
    <var name="HAL_VERSION_NUMBER" value="13">
    </var>

    <var name="HAL_SYS_RESOURCE_NUMBER" value="64">
    </var>

    <var name="HAL_TRACE_SWITCH_PORT_CMD_FLAG" value="0x80000000">
    </var>

    <alias name="HAL_SYS_FREQ_REGISTRY_T">
        <uint8 name="unused" count="HAL_SYS_RESOURCE_NUMBER"/>
    </alias>

    
    <typedef name="HAL_SYS_ACCESS_T">
        <comment>
        </comment>
        <ptr    name="halSysSystemFreq"       type="uint32"/>
        <ptr    name="halSysLpsLock"          type="bool"/>
        <ptr    name="halSysFreqScalRegistry" type="HAL_SYS_FREQ_REGISTRY"/>
    </typedef>

    
    <enum name="HAL_LPS_STATE_2_T">
        <comment>
            Record of LPS State
        </comment>
        <entry name="HAL_LPS_IDLE_2"          />
        <entry name="HAL_LPS_CALIBRATED_2"    />
        <entry name="HAL_LPS_CALIB_RUNNING_2" />
    </enum>

    <typedef  name="HAL_LPS_CONTEXT_2_T">
        <comment>
            Record of LPS content
        </comment>

        <instance   name="lpsState" type="HAL_LPS_STATE_2_T">
            <comment>
                LPS State
            </comment>
        </instance>

        <bool       name="lpsInvalidateCalib">
            <comment>
                Calibration invalidation request
            </comment>
        </bool>

        <uint8      name="lpsAccuracy">
            <comment>
                Accuracy
            </comment>
        </uint8>

        <uint32     name="lpsRate">
            <comment>
                Low Power Synchronizer Rate value
            </comment>
        </uint32>

        <uint32     name="calibFreq">
            <comment>
                Low Power Calibration frequency
            </comment>
        </uint32>

        <uint32     name="lpsRateLast">
            <comment>
                Low Power Synchronizer previous Rate value
            </comment>
        </uint32>

        <uint32     name="calibFreqLast">
            <comment>
                Low Power Calibration frequency
            </comment>
        </uint32>

        <bool       name="lpsSkipFrameAllowed">
            <comment>
                Allow Frames to be skipped
            </comment>
        </bool>

        <uint16     name="lpsFrameLastEvt">
            <comment>
                Last event programmed in active frame
            </comment>
        </uint16>

        <uint16     name="lpsSkipFrameNumber">
            <comment>
                Number of Frame skipped
            </comment>
        </uint16>

        <uint32     name="lpsPuCtrl">
            <comment>
                Pu State machine configuration
            </comment>
        </uint32>

        <uint8      name="lpsWakeUpFrameNbr">
            <comment>
                Number of frames neccessary to wake up
            </comment>
        </uint8>
    </typedef>

    
    <enum name="PXTSLEVELS_T">
        <entry name="Enable_Pxts_Tag_Reserved_0"/>
        <entry name="Enable_Pxts_Tag_Boot"/>
        <entry name="Enable_Pxts_Tag_Hal"/>
        <entry name="Enable_Pxts_Tag_Sx"/>
        <entry name="Enable_Pxts_Tag_Pal"/>
        <entry name="Enable_Pxts_Tag_Edrv"/>
        <entry name="Enable_Pxts_Tag_Svc"/>
        <entry name="Enable_Pxts_Tag_Stack"/>
        <entry name="Enable_Pxts_Tag_Csw"/>
        <entry name="Enable_Pxts_Tag_Reserved_9"/>
        <entry name="Enable_Pxts_Tag_Reserved_10"/>
        <entry name="Enable_Pxts_Tag_Reserved_11"/>
        <entry name="Enable_Pxts_Tag_Bb_Irq"/>
        <entry name="Enable_Pxts_Tag_Spal"/>
        <entry name="Enable_Pxts_Tag_Spp"/>
        <entry name="Enable_Pxts_Tag_Spc"/>
    </enum>
    <typedef  name="HAL_PROFILE_CONTROL_T">
        <comment>This is used only when the code is compiled with HAL_PROFILE_ON_MULTI in cool_profile release.
        </comment>
        <uint32     name="config" display="hex">
            <bits name='Global_Enable_Ram' pos='0' access='rw' rst='0'>
                <comment>Global Enable.
                </comment>
            </bits>
            <bits name='Global_Enable_Trace' pos='1' access='rw' rst='0'>
                <comment>Global Enable.
                </comment>
            </bits>
            <bits name='Enable_Pxts_Tag' cut='1' cutenum='PXTSLEVELS_T' access='rw' rst='0' pos='31:16'>
                <comment>Enable the corresponding PXTS TAG when the bit is set. </comment>
            </bits>
        </uint32>

        <uint32     name="startAddr" display="hex">
            <comment>
                Start Address of the Ram Buffer used to record PXTS tags.
                It is allocted by CoolWatcher through a remote execution
                of malloc. The size is defined by the size field of this
                structure.
            </comment>
        </uint32>

        <uint32     name="size" display="hex">
            <comment>
                It must be of a sized multiple of 64 bits.
            </comment>
        </uint32>

        <uint32     name="writePointer" display="hex">
            <comment>
                The next PXTS tag/time stamp will be written at this address
            </comment>
        </uint32>

        <uint32     name="readPointer" display="hex">
            <comment>
                The next PXTS tag/time stamp will be read at this address
                by CoolWatcher. (Unused)
            </comment>
        </uint32>

        <int32     name="remainingSize" display="dec">
            <comment>
                Remaining size in the buffer, in byte.
            </comment>
        </int32>

        <uint32     name="status" display="hex">
            <comment>
                Status of the profiling recording
            </comment>
            <bits   name="wrapped" pos="0" access="rw" rst="0">
                <comment>
                    Write wrapped while recording PXTS tags in the buffer.
                </comment>
            </bits>
            <bits   name="overflowed" pos="1" access="rw" rst="0">
                <comment>
                    Overflow happened while recording PXTS tags in the buffer.(Unused)
                </comment>
            </bits>
        </uint32>

        <ptr type="void" name="mallocRamBuffer">
            <comment>
                Function to execute remotely to allocate the buffer used by the
                profile in RAM mechanism.
            </comment>
        </ptr>

        <ptr type="void" name="freeRamBuffer">
            <comment>
                Function to execute remotely to free the buffer used by the
                profile in RAM mechanism.
            </comment>
        </ptr>

    </typedef>

    <var name="HAL_GDB_SWITCH_CTX_CMD_START" value="0xF0">
    </var>
    <var name="HAL_GDB_SWITCH_CTX_CMD_OK" value="0xE0">
    </var>
    <var name="HAL_GDB_SWITCH_CTX_CMD_ERR" value="0xE1">
    </var>
    <var name="HAL_GDB_SWITCH_CTX_CMD_RESTORED" value="0xE2">
    </var>

    <enum name="HAL_GDB_SWITCH_CTX_FLAG">
        <entry name="HAL_GDB_SWITCH_CTX_FLAG_TASK_ID"/>
        <entry name="HAL_GDB_SWITCH_CTX_FLAG_JOB_ID"/>
        <entry name="HAL_GDB_SWITCH_CTX_FLAG_CTX_BEFORE_CUR_IRQ"/>
        <entry name="HAL_GDB_SWITCH_CTX_FLAG_TASK_IRQ_SP"/>
        <entry name="HAL_GDB_SWITCH_CTX_FLAG_JOB_SP"/>
    </enum>

    <typedef name="HAL_GDB_SWITCH_CTX_T">
        <comment>
            To set the parameters and the result of the context switching.
        </comment>
        <uint8 name='cmd'>
            <comment> Whether to start switching, or the result after switching.
            </comment>
        </uint8>
        <uint8 name='flag'>
            <comment> How to interpret the parameters, seeing HAL_GDB_SWITCH_CTX_FLAG
            </comment>
        </uint8>
        <uint16 name='id'>
            <comment> The task or job ID.
            </comment>
        </uint16>
        <uint32 name="stackPointer">
            <comment> The stack pointer to show backtrace
            </comment>
        </uint32>
    </typedef>

    
    <typedef name="HAL_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        <instance type="HAL_SYS_ACCESS_T"      name="sys"/>
        <ptr type="HAL_LPS_CONTEXT_2_T"        name="lpsCtx"/>
        <ptr type="uint32"                     name="lpsForceNoSleepPtr"/>
        <ptr type="HAL_SPEECH_FIFO_T"          name="halSpeechFifo"/>
        <instance type="HAL_PROFILE_CONTROL_T" name="profileControl"/>
        <ptr type="void"                       name="keypadPulseHandler"/>
        <ptr type="HAL_GDB_SWITCH_CTX_T"       name="gdbSwitchCtxPtr"/>
        <ptr type="uint32"                     name="gdbEnabledPtr"/>
        <ptr type="uint32"                     name="traceSwitchPtr"/>
    </typedef>

<cjoker>


// =============================================================================
// g_halMapAccess
// -----------------------------------------------------------------------------
/// This global variable is the shared structure of HAL.
// =============================================================================
EXPORT PROTECTED HAL_MAP_ACCESS_T g_halMapAccess;


// =============================================================================
// hal_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID hal_RegisterYourself(VOID);

</cjoker>

</archive>



<archive relative='../../../platform/calib/include/calib_m.xmd'  asm="no">


<comment>

@defgroup calib Calibration Driver<br/>
@{<br/>
</comment>

<include load="no" file="cs_types.h"/>


<typedef name="calib_globals" rubyconstants="yes"></typedef>

<var name='CALIB_MAJ_VERSION' value='2'>
    <comment>Version of the calibration stub and code (on 8 bits).</comment>
</var>

<var name='CALIB_MIN_VERSION' value='6'></var>

<var name='CALIB_MARK_VERSION' value='0xCA1B0000'></var>

<var name='CALIB_VERSION_NUMBER' value='( CALIB_MARK_VERSION | CALIB_MAJ_VERSION &lt;&lt; 8 | CALIB_MIN_VERSION )'></var>

<var name='CALIB_STUB_VERSION' value='0xCA5B0001'></var>

<var name='CALIB_XCV_TIME_QTY' value='20'>
    <comment>Number of calib timings for the transceiver.</comment>
</var>

<var name='CALIB_PA_TIME_QTY' value='15'>
    <comment>Number of calib timings for the PA.</comment>
</var>

<var name='CALIB_SW_TIME_QTY' value='15'>
    <comment>Number of calib timings for the switch.</comment>
</var>

<var name='CALIB_PAL_TIME_QTY' value='20'>
    <comment>Number of calib timings for PAL.</comment>
</var>

<var name='CALIB_XCV_PARAM_QTY' value='20'>
    <comment>Number of generic parameters for the transceiver.</comment>
</var>

<var name='CALIB_PA_PARAM_QTY' value='15'>
    <comment>Number of generic parameters for the PA.</comment>
</var>

<var name='CALIB_SW_PARAM_QTY' value='15'>
    <comment>Number of generic parameters for the switch.</comment>
</var>

<var name='CALIB_XCV_MASK' value='(1 &lt;&lt; 24)'>
    <comment>Mask for transceiver RF name.</comment>
</var>

<var name='CALIB_PA_MASK' value='(1 &lt;&lt; 25)'>
    <comment>Mask for PA RF name.</comment>
</var>

<var name='CALIB_SW_MASK' value='(1 &lt;&lt; 26)'>
    <comment>Mask for switch RF name.</comment>
</var>

<var name='CALIB_GSM_PCL_QTY' value='15'></var>

<var name='CALIB_DCS_PCL_QTY' value='17'></var>

<var name='CALIB_PCS_PCL_QTY' value='18'></var>

<var name='CALIB_PADAC_PROF_INTERP_QTY' value='16'></var>

<var name='CALIB_PADAC_PROF_QTY' value='1024'></var>

<var name='CALIB_PADAC_RAMP_QTY' value='32'></var>

<var name='CALIB_LOW_VOLT_QTY' value='6'></var>

<var name='CALIB_VOC_MDF_QTY' value='64'>
    <comment>Number of coefficiens in the MDF FIR filter.</comment>
</var>

<var name='CALIB_VOC_SDF_QTY' value='64'>
    <comment>Number of coefficiens in the SDF FIR filter.</comment>
</var>

<var name='CALIB_EC_ON' value='(1 &lt;&lt; 0)'>
    <comment>Mask for echo cancelation enable (to be used with audio VoC enable).</comment>
</var>

<var name='CALIB_MDF_ON' value='(1 &lt;&lt; 1)'>
    <comment>Mask for MDF FIR filter enable (to be used with audio VoC enable).</comment>
</var>

<var name='CALIB_SDF_ON' value='(1 &lt;&lt; 2)'>
    <comment>Mask for SDF FIR filter enable (to be used with audio VoC enable).</comment>
</var>

<var name='CALIB_AUDIO_GAIN_QTY' value='8'>
    <comment>Number of audio gain steps.</comment>
</var>

<var name='CALIB_AUDIO_GAIN_VALUE_MUTE' value='-128'>
    <comment>The audio gain value standing for mute.</comment>
</var>

<var name='CALIB_AUDIO_PARAM_QTY' value='8'>
    <comment>Number of misc audio parameters.</comment>
</var>

<var name='CALIB_STUB_SEARCH_POWER' value='0x0'>
    <comment>Unrealistic values meaning that the power measure is not complete yet.</comment>
</var>

<var name='CALIB_STUB_SEARCH_FOF' value='-2000000'>
    <comment>Unrealistic values meaning that the FOf measure is not complete yet.</comment>
</var>

<var name='CALIB_STUB_XTAL_IDLE' value='-2000001'>
    <comment>For communication between Calib Stub and calibration tools.</comment>
</var>

<var name='CALIB_STUB_PA_PROF_IDLE' value='-2000002'>
    <comment>For communication between Calib Stub and calibration tools.</comment>
</var>

<var name='CALIB_STUB_ILOSS_IDLE' value='-128'>
    <comment>For communication between Calib Stub and calibration tools.
    </comment>
</var>

<var name='CALIB_STUB_DCO_IDLE' value='-32768'>
    <comment>For communication between Calib Stub and calibration tools.
    </comment>
</var>

<var name='CALIB_STUB_DCO_ERROR' value='-32767'>
    <comment>For communication between Calib Stub and calibration tools.
    </comment>
</var>

<var name='CALIB_STUB_GPADC_ERROR' value='0xFFFF'>
    <comment>For communication between Calib Stub and calibration tools.
    </comment>
</var>

<var name='CALIB_STUB_GPADC_IDLE' value='0xFFFE'>
    <comment>For communication between Calib Stub and calibration tools.
    </comment>
</var>

<var name='CALIB_NB_CELLS' value='5'>
    <comment>Number of cells used for measurement averages
    </comment>
</var>


<var name='CALIB_AUDIO_ITF_QTY' value='6'>
    <comment>
        Maximum number of different Audio Interfaces supported
        by this calibration structure.
        The value of CALIB_AUDIO_ITF_QTY must be the same as AUD_ITF_QTY!
    </comment>
</var>

<var name='CALIB_GPADC_CH_QTY' value='4'>
    <comment>The number of GP ADC channels.
    </comment>
</var>

<alias name='CALIB_GPADC_ALL_CH'>
    <uint16 name='unused' count='CALIB_GPADC_CH_QTY'>
        <comment>Type used to avoid the need for a matrix.
        It represents an array of one measurement per
        GPADC Channel.
        </comment>
    </uint16>
</alias>


<var name='CALIB_GPADC_ACC_COUNT' value='8'>
    <comment>
    </comment>
</var>


<var name='CALIB_GPADC_ACC_COUNT_MAX' value='128'>
    <comment>
    </comment>
</var>


<var name='CALIB_AUDIO_DICTA_REC' value='1'>
    <comment>
    </comment>
</var>


<var name='CALIB_AUDIO_DICTA_PLAY' value='2'>
    <comment>
    </comment>
</var>


<alias name='CALIB_VERSION_TAG'>
    <uint32 name='unused'>
        <comment>
            Calib version type. Use #CALIB_VERSION to build
            a version number to check against a calib sector version number.
            The calibration version number of the code
            is defined by CALIB_VERSION_NUMBER.
        </comment>
    </uint32>
</alias>

<enum name='CALIB_METHOD'>
    <comment>Calib process method type.</comment>

    <entry name='CALIB_METH_DEFAULT' value='0xCA11E700'></entry>
    <entry name='CALIB_METH_COMPILATION'></entry>
    <entry name='CALIB_METH_MANUAL'></entry>
    <entry name='CALIB_METH_AUTOMATIC'></entry>
    <entry name='CALIB_METH_SIMULATION'></entry>
</enum>

<typedef name='CALIB_OP_INFO'>
    <comment>Calib process method and date type.</comment>

    <uint32 name='date'></uint32>
    <instance name='method' type='CALIB_METHOD'></instance>
</typedef>

<alias name='CALIB_XCV_TIMES'>
    <int16 name='unused' count='CALIB_XCV_TIME_QTY'>
        <comment>Transceiver timing type.</comment>
    </int16>
</alias>

<alias name='CALIB_PA_TIMES'>
    <int16 name='unused' count='CALIB_PA_TIME_QTY'>
        <comment>PA timing type.</comment>
    </int16>
</alias>

<alias name='CALIB_SW_TIMES'>
    <int16 name='unused' count='CALIB_SW_TIME_QTY'>
        <comment>Switch timing type.</comment>
    </int16>
</alias>

<alias name='CALIB_PAL_TIMES'>
    <int16 name='unused' count='CALIB_PAL_TIME_QTY'>
        <comment>PAL timing type.</comment>
    </int16>
</alias>

<alias name='CALIB_XCV_PARAM'>
    <int32 name='unused' count='CALIB_XCV_PARAM_QTY'>
        <comment>Transceiver generic parameter type.</comment>
    </int32>
</alias>

<alias name='CALIB_PA_PARAM'>
    <int32 name='unused' count='CALIB_PA_PARAM_QTY'>
        <comment>PA generic parameter type.</comment>
    </int32>
</alias>

<alias name='CALIB_SW_PARAM'>
    <int32 name='unused' count='CALIB_SW_PARAM_QTY'>
        <comment>Switch generic parameter type.</comment>
    </int32>
</alias>

<enum name='CALIB_H_ENUM_0'>
    <comment>Used for autonomous calib processes, results from Calib Stub to remote.</comment>

    <entry name='CALIB_PROCESS_STOP' value='0x0'></entry>
    <entry name='CALIB_PROCESS_CONTINUE' value='0x1'></entry>
    <entry name='CALIB_PROCESS_PENDING' value='0x2'></entry>
    <entry name='CALIB_PROCESS_NEED_CALM' value='0x3'></entry>
    <entry name='CALIB_PROCESS_ERR_BAD_POW' value='0xf0'></entry>
    <entry name='CALIB_PROCESS_ERR_NO_MONO_POW' value='0xf1'></entry>
    <entry name='CALIB_PROCESS_ERR_ZERO_DAC' value='0xf2'></entry>
    <entry name='CALIB_PROCESS_ERROR' value='0xff'></entry>
</enum>

<enum name='CALIB_STUB_BAND'>
    <entry name='CALIB_STUB_BAND_GSM850' value='0'></entry>
    <entry name='CALIB_STUB_BAND_GSM900' value='1'></entry>
    <entry name='CALIB_STUB_BAND_DCS1800' value='2'></entry>
    <entry name='CALIB_STUB_BAND_PCS1900' value='3'></entry>
    <entry name='CALIB_STUB_BAND_QTY'></entry>
</enum>

<alias name='CALIB_RF_CHIP_NAME'>
    <uint32 name='unused'>
        <comment>RF chip identification name.</comment>
    </uint32>
</alias>

<alias name='CALIB_RXTX_FREQ_OFFSET'>
    <int16 name='unused' count='CALIB_STUB_BAND_QTY'></int16>
</alias>

<alias name='CALIB_RXTX_TIME_OFFSET'>
    <int16 name='unused'></int16>
</alias>

<alias name='CALIB_RXTX_IQ_TIME_OFFSET'>
    <int16 name='unused'></int16>
</alias>

<alias name='CALIB_DCO_CAL_TIME'>
    <int16 name='unused'></int16>
</alias>

<typedef name='CALIB_XCV_PALCUST'>
    <comment>XCV PAL custom types.</comment>

    <instance name='name' type='CALIB_RF_CHIP_NAME'></instance>
    <instance name='rxTxFreqOffset' type='CALIB_RXTX_FREQ_OFFSET'></instance>
    <instance name='rxTxTimeOffset' type='CALIB_RXTX_TIME_OFFSET'></instance>
    <instance name='rxIqTimeOffset' type='CALIB_RXTX_IQ_TIME_OFFSET'></instance>
    <instance name='txIqTimeOffset' type='CALIB_RXTX_IQ_TIME_OFFSET'></instance>
    <instance name='dcoCalTime' type='CALIB_DCO_CAL_TIME'></instance>
    <int32 name='spare' count='7'></int32>
</typedef>

<alias name='CALIB_ARFCN'>
    <int16 name='unused' count='2'></int16>
</alias>

<alias name='CALIB_PCL2DBM_ARFCN_G'>
    <instance name='unused' type='CALIB_ARFCN' count='CALIB_GSM_PCL_QTY'></instance>
</alias>

<alias name='CALIB_PCL2DBM_ARFCN_D'>
    <instance name='unused' type='CALIB_ARFCN' count='CALIB_DCS_PCL_QTY'></instance>
</alias>

<alias name='CALIB_PCL2DBM_ARFCN_P'>
    <instance name='unused' type='CALIB_ARFCN' count='CALIB_PCS_PCL_QTY'></instance>
</alias>

<alias name='CALIB_PADAC_PROFILE_INTERP'>
    <uint16 name='unused' count='CALIB_PADAC_PROF_INTERP_QTY'></uint16>
</alias>

<alias name='CALIB_PADAC_PROFILE'>
    <uint16 name='unused' count='CALIB_PADAC_PROF_QTY'></uint16>
</alias>

<alias name='CALIB_PADAC_PROFILE_EXTREM'>
    <int16 name='unused'></int16>
</alias>

<alias name='CALIB_PADAC_RAMP'>
    <uint16 name='unused' count='CALIB_PADAC_RAMP_QTY'></uint16>
</alias>

<alias name='CALIB_PADAC_RAMP_SWAP'>
    <uint16 name='unused'></uint16>
</alias>

<alias name='CALIB_PADAC_LOW_VOLT'>
    <uint16 name='unused' count='CALIB_LOW_VOLT_QTY'></uint16>
</alias>

<alias name='CALIB_PADAC_LOW_DAC'>
    <uint16 name='unused' count='CALIB_LOW_VOLT_QTY'></uint16>
</alias>

<typedef name='CALIB_PA_PALCUST'>
    <comment>PA PAL custom types.</comment>

    <instance name='name' type='CALIB_RF_CHIP_NAME'></instance>
    <instance name='pcl2dbmArfcnG' type='CALIB_PCL2DBM_ARFCN_G'></instance>
    <instance name='pcl2dbmArfcnD' type='CALIB_PCL2DBM_ARFCN_D'></instance>
    <instance name='pcl2dbmArfcnP' type='CALIB_PCL2DBM_ARFCN_P'></instance>
    <instance name='profileInterpG' type='CALIB_PADAC_PROFILE_INTERP'></instance>
    <instance name='profileInterpDp' type='CALIB_PADAC_PROFILE_INTERP'></instance>
    <instance name='profileG' type='CALIB_PADAC_PROFILE'></instance>
    <instance name='profileDp' type='CALIB_PADAC_PROFILE'></instance>
    <instance name='profileDbmMinG' type='CALIB_PADAC_PROFILE_EXTREM'></instance>
    <instance name='profileDbmMinDp' type='CALIB_PADAC_PROFILE_EXTREM'></instance>
    <instance name='profileDbmMaxG' type='CALIB_PADAC_PROFILE_EXTREM'></instance>
    <instance name='profileDbmMaxDp' type='CALIB_PADAC_PROFILE_EXTREM'></instance>
    <instance name='rampLow' type='CALIB_PADAC_RAMP'></instance>
    <instance name='rampHigh' type='CALIB_PADAC_RAMP'></instance>
    <instance name='rampSwapG' type='CALIB_PADAC_RAMP_SWAP'></instance>
    <instance name='rampSwapDp' type='CALIB_PADAC_RAMP_SWAP'></instance>
    <instance name='lowVoltLimit' type='CALIB_PADAC_LOW_VOLT'></instance>
    <instance name='lowDacLimit' type='CALIB_PADAC_LOW_DAC'></instance>
    <int32 name='spare' count='8'></int32>
</typedef>

<typedef name='CALIB_SW_PALCUST'>
    <instance name='name' type='CALIB_RF_CHIP_NAME'></instance>
    <int32 name='spare' count='8'></int32>
</typedef>



<typedef name='CALIB_AUDIO_VOC_EC'>
    <comment>Echo Cancelling for VoC.</comment>
    <uint8 name='ecMu'>
        <comment> Enables Echo Canceller algorithm when >0.
        </comment>
    </uint8>
    <uint8 name='ecRel'>
        <comment> Echo Canceller REL parameter (0,+16).
        </comment>
    </uint8>
    <uint8 name='ecMin'>
        <comment> Echo Canceller MIN parameter (0, 32).
        </comment>
    </uint8>
    <uint8 name='esOn'>
        <comment> Enable Echo Suppressor algorithm (0,1).
        </comment>
    </uint8>
    <uint8 name='esDtd'>
        <comment> Double talk threshold for Echo Suppressor algo  (0,32).
        </comment>
    </uint8>
    <uint8 name='esVad'>
        <comment> Donwlink vad threshold for Echo Suppressor algo (0,32).
        </comment>
    </uint8>
    <uint32 name='enableField'>
        <comment>Enable for echo cancelling.</comment>
    </uint32>
</typedef>

<typedef name='CALIB_AUDIO_VOC_FILTERS'>
    <comment>VoC anti-distortion filters.</comment>
    <uint16 name='mdfFilter' count='CALIB_VOC_MDF_QTY'>
        <comment>VoC needs the MDF coeffs to be 32-bit aligned.</comment>
    </uint16>
    <uint16 name='sdfFilter' count='CALIB_VOC_SDF_QTY'>
        <comment>SDF coeffs must stay right after MDF.</comment>
    </uint16>
</typedef>

<typedef name='CALIB_AUDIO_IN_GAINS'>
    <comment>Input (MIC) gains.</comment>
    <int8 name='ana'>
        <comment>Input analog gain.</comment>
    </int8>
    <int8 name='adc'>
        <comment>Input ADC gain.</comment>
    </int8>
    <int8 name='alg'>
        <comment>Input algorithm gain.</comment>
    </int8>
    <int8 name='reserv'>
        <comment>Reserved.</comment>
    </int8>
</typedef>

<typedef name='CALIB_AUDIO_OUT_GAINS'>
    <comment>Output gains.</comment>
    <int8 name='voiceOrEpAna'>
        <comment>
            Output voice gains for physical interfaces, or
            earpiece gains for application interfaces.
            Output analog gain.
        </comment>
    </int8>
    <int8 name='voiceOrEpDac'>
        <comment>Output DAC gain.</comment>
    </int8>
    <int8 name='voiceOrEpAlg'>
        <comment>Output algorithm gain.</comment>
    </int8>
    <int8 name='reserv1'>
        <comment>Reserved.</comment>
    </int8>
    <int8 name='musicOrLsAna'>
        <comment>
            Output music gains for physical interfaces, or
            loudspeaker gains for application interfaces.
            Output analog gain.
        </comment>
    </int8>
    <int8 name='musicOrLsDac'>
        <comment>Output DAC gain.</comment>
    </int8>
    <int8 name='musicOrLsAlg'>
        <comment>Output algorithm gain.</comment>
    </int8>
    <int8 name='reserv2'>
        <comment>Reserved.</comment>
    </int8>
</typedef>

<typedef name='CALIB_AUDIO_GAINS'>
    <comment>Calib audio gain types.</comment>

    <instance name='inGainsCall' type='CALIB_AUDIO_IN_GAINS'>
        <comment>MIC gains during a voice call.</comment>
    </instance>
    <instance name='outGains' type='CALIB_AUDIO_OUT_GAINS' count='CALIB_AUDIO_GAIN_QTY'>
    </instance>
    <int8 name='sideTone' count='CALIB_AUDIO_GAIN_QTY'></int8>
    <instance name='inGainsRecord' type='CALIB_AUDIO_IN_GAINS'>
        <comment>MIC gains during a sound recording.</comment>
    </instance>
    <int8 name='reserv' count='20'></int8>
</typedef>

<typedef name='CALIB_AUDIO_PARAMS'>
    <comment>Audio calibration parameters.</comment>
    <uint32 name='reserv1'></uint32>
    <int8 name='AecEnbleFlag'></int8>
    <int8 name='AgcEnbleFlag'></int8>
    <int8 name='StrongEchoFlag'></int8>
    <int8 name='reserv2'></int8>
    <int8 name='NoiseGainLimit'></int8>
    <int8 name='NoiseMin'></int8>
    <int8 name='NoiseGainLimitStep'></int8>
    <int8 name='AmpThr'></int8>
    <int8 name='HighPassFilterFlag'></int8>
    <int8 name='NotchFilterFlag'></int8>
    <int8 name='NoiseSuppresserFlag'></int8>
    <int8 name='NoiseSuppresserWithoutSpeechFlag'></int8>
    <uint32 name='AudioParams' count='CALIB_AUDIO_PARAM_QTY-4'></uint32>
</typedef>

<typedef name='CALIB_AUDIO_ITF'>
    <comment>
        Calibration of an audio interface. It gathers the
        audio gains and VoC calibrations data
    </comment>
    <instance name='vocEc'          type='CALIB_AUDIO_VOC_EC'>
    </instance>
    <instance name='vocFilters'     type='CALIB_AUDIO_VOC_FILTERS'>
    </instance>
    <instance name='audioGains'     type='CALIB_AUDIO_GAINS'>
    </instance>
    <instance name='audioParams'    type='CALIB_AUDIO_PARAMS'>
    </instance>
</typedef>

<typedef name='CALIB_GPADC'>
    <comment>Calib GPADC analog type.</comment>

    <uint16 name='sensorGainA'></uint16>
    <uint16 name='sensorGainB'></uint16>
</typedef>

<alias name='CALIB_RF_CRC'>
    <uint32 name='unused'>
    </uint32>
</alias>

<typedef name='CALIB_XCV'>
    <comment>Transceiver calibration.</comment>

    <instance name='times' type='CALIB_XCV_TIMES'></instance>
    <instance name='param' type='CALIB_XCV_PARAM'></instance>
    <instance name='palcust' type='CALIB_XCV_PALCUST'></instance>
</typedef>

<typedef name='CALIB_PA'>
    <comment>Power Amplifier RF calibration.</comment>

    <instance name='times' type='CALIB_PA_TIMES'></instance>
    <instance name='param' type='CALIB_PA_PARAM'></instance>
    <instance name='palcust' type='CALIB_PA_PALCUST'></instance>
</typedef>

<typedef name='CALIB_SW'>
    <comment>Switch calibration.</comment>

    <instance name='times' type='CALIB_SW_TIMES'></instance>
    <instance name='param' type='CALIB_SW_PARAM'></instance>
    <instance name='palcust' type='CALIB_SW_PALCUST'></instance>
</typedef>

<typedef name='CALIB_BB'>
    <comment>Baseband calibration.</comment>

    <instance name='times' type='CALIB_PAL_TIMES'>
        <comment>PAL calibration.</comment>
    </instance>
    <instance name='audio' type='CALIB_AUDIO_ITF' count='CALIB_AUDIO_ITF_QTY'>
        <comment>Audio calibration, for each interface</comment>
    </instance>
    <instance name='gpadc' type='CALIB_GPADC'>
        <comment>Analog macros calibration: GPADC.</comment>
    </instance>
</typedef>

<typedef name='CALIB_BUFFER'>
    <instance name='versionTag' type='CALIB_VERSION_TAG'>
        <comment>Information about this calib buffer.</comment>
    </instance>
    <instance name='opInfo' type='CALIB_OP_INFO'></instance>
    <instance name='xcv' type='CALIB_XCV'>
        <comment>Transceiver calibration.</comment>
    </instance>
    <instance name='pa' type='CALIB_PA'>
        <comment>Power Amplifier RF calibration.</comment>
    </instance>
    <instance name='sw' type='CALIB_SW'>
        <comment>Switch calibration.</comment>
    </instance>
    <instance name='bb' type='CALIB_BB'>
        <comment>Baseband calibration.</comment>
    </instance>
    <uint32 name='reserved' count='2'>
        <comment>Reserved for future use.</comment>
    </uint32>
    <instance name='audioVersionTag' type='CALIB_VERSION_TAG'>
        <comment>Information for audio calibration data.</comment>
    </instance>
    <instance name='rfCrc' type='CALIB_RF_CRC'>
        <comment>CRC value for RF calibration data.</comment>
    </instance>
</typedef>

<enum name='CALIB_STUB_CMDS'>
    <comment>Values used to define the contexts of the Calib Stub.</comment>

    <entry name='CALIB_STUB_NO_STATE'></entry>
    <entry name='CALIB_STUB_MONIT_STATE'></entry>
    <entry name='CALIB_STUB_FOF_STATE'></entry>
    <entry name='CALIB_STUB_TX_STATE'></entry>
    <entry name='CALIB_STUB_PA_STATE'></entry>
    <entry name='CALIB_STUB_AUDIO_OUT'></entry>
    <entry name='CALIB_STUB_AUDIO_IN'></entry>
    <entry name='CALIB_STUB_AUDIO_SIDE'></entry>
    <entry name='CALIB_STUB_SYNCH_STATE'></entry>
    <entry name='CALIB_STUB_IDLE_STATE'></entry>
</enum>

<enum name='CALIB_STUB_AFC_BOUND_T'>
    <entry name='CALIB_STUB_AFC_BOUND_CENTER' value='0'></entry>
    <entry name='CALIB_STUB_AFC_BOUND_NEG_FREQ'></entry>
    <entry name='CALIB_STUB_AFC_BOUND_POS_FREQ'></entry>
    <entry name='CALIB_STUB_AFC_BOUND_NO'></entry>
</enum>


<var name='CALIB_DCO_ACC_COUNT' value='32'>
    <comment>Value that defines the number of measure to do before the DC offset
    average is considered valid.
    </comment>
</var>

<var name='CALIB_MAGIC_TAG' value='0xCA1BCA1B'>
    <comment>
        This magiv tag is used as a parameter to the
        boot loader to force is to run the calibration
        stub
    </comment>
</var>

<typedef name='CALIB_STUB_CTX'>
    <comment>Used to send calibration context change requests from the remote  calibration tools to the Calib Stub.</comment>

    <instance name='state' type='CALIB_STUB_CMDS' ckeywords='VOLATILE'>
        <comment>Commands from the remote calibration tools.</comment>
    </instance>
    <bool name='firstFint' ckeywords='VOLATILE'></bool>
    <int32 name='setXtalFreqOffset' ckeywords='VOLATILE'>
        <comment>Subcommands from the remote calibration tools.</comment>
    </int32>
    <uint8 name='setAfcBound' ckeywords='VOLATILE'></uint8>
    <uint8 name='setChangeDACAfcBound' ckeywords='VOLATILE'></uint8>
    <int32 name='setChangeDACAfcFreqOffset' ckeywords='VOLATILE'></int32>
    <int32 name='setChangeDACAfcFreq' ckeywords='VOLATILE'></int32>
    <int32 name='setAfcFreqOffset' ckeywords='VOLATILE'></int32>
    <int8 name='setILossOffset' ckeywords='VOLATILE'></int8>
    <int32 name='setPAProfMeas' ckeywords='VOLATILE'></int32>
    <int8 name='setCalibUpdate' ckeywords='VOLATILE'></int8>
    <uint8 name='setRestartGpadcMeasure' ckeywords='VOLATILE'></uint8>

    
    <uint16 name='arfcn' ckeywords='VOLATILE' count='CALIB_NB_CELLS'>
        <comment>Cells information</comment>
    </uint16>
    <uint8  name='power' ckeywords='VOLATILE'  count='CALIB_NB_CELLS'></uint8>
    <bool   name='isPcs' ckeywords='VOLATILE'  count='CALIB_NB_CELLS'></bool>
    <uint8  name='bsic'  ckeywords='VOLATILE'  ></uint8>
    <uint32 name='fn'    ckeywords='VOLATILE'  ></uint32>
    <uint8  name='t2'    ckeywords='VOLATILE'  ></uint8>
    <uint8  name='t3'    ckeywords='VOLATILE'  ></uint8>
    <uint16 name='qbOf'  ckeywords='VOLATILE'  ></uint16>

    
    <uint16 name='pFactor' ckeywords='VOLATILE'></uint16>
    <int32 name='tOf' ckeywords='VOLATILE'></int32>
    <int32 name='fOf' ckeywords='VOLATILE'></int32>
    <uint16 name='snR' ckeywords='VOLATILE'></uint16>
    <uint8 name='bitError' ckeywords='VOLATILE'></uint8>
    <uint8 name='monPower' ckeywords='VOLATILE'></uint8>
    <uint8 name='nbPower' ckeywords='VOLATILE'></uint8>
    <uint8 name='monBitmap' ckeywords='VOLATILE'></uint8>
    <int32 name='meanFOf' ckeywords='VOLATILE'></int32>
    <uint8 name='xtalCalibDone' ckeywords='VOLATILE'>
        <comment> This is initialized by HST </comment>
        </uint8>
    <uint16 name='paProfNextDacVal' ckeywords='VOLATILE'>>
        <comment> This is initialized by HST </comment>
        </uint16>
    <uint8 name='paProfCalibDone' ckeywords='VOLATILE'></uint8>
    <int16 name='dcoAverI' ckeywords='VOLATILE'></int16>
    <int16 name='dcoAverQ' ckeywords='VOLATILE'></int16>
    <uint8 name='dcoAccCount' ckeywords='VOLATILE'>
        <comment>Can go up to 2 * CT_CALIB_DCO_ACC_COUNT - 1.</comment>
    </uint8>
    <int16 name='dcoI' ckeywords='VOLATILE' count='CALIB_DCO_ACC_COUNT'></int16>
    <int16 name='dcoQ' ckeywords='VOLATILE' count='CALIB_DCO_ACC_COUNT'></int16>
    <uint8  name='iLossCalibDone'>>
        <comment>Status of the iloss calibration porcess.
                 This is initialized by HST.
        </comment>
     </uint8>
    <uint16 name='iLossNextArfcn'>
        <comment>ARFCN for which to measure the insertion loss. This is not initialized.
        </comment>
    </uint16>
    <uint16 name='gpadcAver' count='CALIB_GPADC_CH_QTY'> </uint16>
    <uint8  name='gpadcAccCount'>
        <comment>Can go up to 2*CALIB_GPADC_ACC_COUNT-1.
        </comment>
    </uint8>
    <instance name='gpadcAcc' type='CALIB_GPADC_ALL_CH' count='CALIB_GPADC_ACC_COUNT_MAX'> </instance>

    
    <uint16 name='txArfcn' ckeywords='VOLATILE'>
        <comment>Parameters for Tx commands from the remote calibration tools.</comment>
    </uint16>
    <uint8 name='txPcl' ckeywords='VOLATILE'></uint8>
    <uint16 name='txDac' ckeywords='VOLATILE'></uint16>
    <uint8 name='txBand' ckeywords='VOLATILE'></uint8>
    <uint8 name='txTsc' ckeywords='VOLATILE'></uint8>

    
    <uint16 name='monArfcn' ckeywords='VOLATILE'>
        <comment>Parameters for monitoring commands from the remote calibration tools.</comment>
    </uint16>
    <uint8 name='monBand' ckeywords='VOLATILE'></uint8>
    <uint8 name='monExpPow' ckeywords='VOLATILE'></uint8>

    
    <uint8 name='itfSel' ckeywords='VOLATILE'>
        <comment>
            Parameters for audio commands from the remote calibration tools.
            This parameter is used to select the Audio Interface to calibrate
        </comment>
    </uint8>
    <uint8 name='inSel' ckeywords='VOLATILE'>
        <comment>
            This field selects which input (microphone) is used on the
            Audio Interface defined by the itfSel field.
        </comment>
    </uint8>
    <uint8 name='inGain' ckeywords='VOLATILE'></uint8>
    <uint8 name='inUart' ckeywords='VOLATILE'></uint8>
    <uint8 name='outSel' ckeywords='VOLATILE'>
        <comment>
            This field selects which input (speaker) is used on the
            Audio Interface defined by the itfSel field.
        </comment>
    </uint8>
    <uint8 name='outGain' ckeywords='VOLATILE'></uint8>
    <uint8 name='polyGain' ckeywords='VOLATILE'></uint8>
    <uint8 name='sideGain' ckeywords='VOLATILE'></uint8>
    <uint16 name='outFreq' ckeywords='VOLATILE'></uint16>
    <uint8 name='outAmpl' ckeywords='VOLATILE'></uint8>

    
    <uint8 name='startAudioDictaphone' ckeywords='VOLATILE'></uint8>
    <uint8 name='audioDictaphoneStatus' ckeywords='VOLATILE'></uint8>

    <uint8 name='pmdCustomCalibStart' ckeywords='VOLATILE'>
        <comment>Command to start the custom calibration of the PMD.
            This value is given to the pmd_CustomCalibration() function.
            This is initialized by the stub and written by the HST.
        </comment>
    </uint8>
    <uint32 name='pmdCustomCalibStatus' ckeywords='VOLATILE'>
        <comment>Status of the custom calibration of the PMD.
            This is initialized by the HST and returned by the stub.
        </comment>
    </uint32>

</typedef>

<enum name='CALIB_COMMAND'>
    <entry name='CALIB_CMD_DONE' value='0xCA11B042'>
        <comment>Command used by the Calibration Embedded Stub to inform HST that the command is done.</comment>
    </entry>
    <entry name='CALIB_CMD_NOT_ACCESSIBLE'></entry>
    <entry name='CALIB_CMD_UPDATE'></entry>
    <entry name='CALIB_CMD_UPDATE_ERROR'></entry>
    <entry name='CALIB_CMD_PA_PROFILE_GSM'></entry>
    <entry name='CALIB_CMD_PA_PROFILE_DCSPCS'></entry>
    <entry name='CALIB_CMD_RF_FLASH_BURN'></entry>
    <entry name='CALIB_CMD_FLASH_ERASE'></entry>
    <entry name='CALIB_CMD_FLASH_ERROR'></entry>
    <entry name='CALIB_CMD_RF_RESET'></entry>
    <entry name='CALIB_CMD_AUDIO_RESET'></entry>
    <entry name='CALIB_CMD_RESET'></entry>
    <entry name='CALIB_CMD_AUDIO_FLASH_BURN'></entry>
    <entry name='CALIB_CMD_FLASH_BURN'></entry>
    <entry name='CALIB_CMD_CFP_BURN'></entry>
</enum>

<enum name='CALIB_PARAM_STATUS'>
    <comment>Calibration parameter type identifier.</comment>

    <entry name='CALIB_PARAM_DEFAULT' value='0xca11b042'></entry>
    <entry name='CALIB_PARAM_DEFAULT_RF_MIS' value='0xca11b043'></entry>
    <entry name='CALIB_PARAM_INIT_ERROR' value='0xca10dead'></entry>
    <entry name='CALIB_PARAM_RF_CALIBRATED' value='0x007f0011'></entry>
    <entry name='CALIB_PARAM_AUDIO_CALIBRATED' value='0x00a0d011'></entry>
    <entry name='CALIB_PARAM_AUDIO_CALIBRATED_RF_MIS' value='0x00a0d043'></entry>
    <entry name='CALIB_PARAM_CALIBRATED' value='0x00def011'></entry>
</enum>

<typedef name='CALIB_CALIBRATION_T'>
    <comment>This struct will contain pointers to the calibration info and to  the struct where to put the calibration context requests. It also  contains the address of the calibration sector in flash.</comment>

    <instance name='codeVersion' type='CALIB_VERSION_TAG'></instance>
    <instance name='paramStatus' type='CALIB_PARAM_STATUS'></instance>
    <instance name='command' type='CALIB_COMMAND'></instance>
    <ptr name='opInfo' type='CALIB_OP_INFO'></ptr>
    <ptr name='xcv' type='CALIB_XCV'></ptr>
    <ptr name='pa' type='CALIB_PA'></ptr>
    <ptr name='sw' type='CALIB_SW'></ptr>
    <ptr name='bb' type='CALIB_BB'></ptr>
    <ptr name='hstOpInfo' type='CALIB_OP_INFO' ckeywords='VOLATILE'></ptr>
    <ptr name='hstXcv' type='CALIB_XCV' ckeywords='VOLATILE'></ptr>
    <ptr name='hstPa' type='CALIB_PA' ckeywords='VOLATILE'></ptr>
    <ptr name='hstSw' type='CALIB_SW' ckeywords='VOLATILE'></ptr>
    <ptr name='hstBb' type='CALIB_BB' ckeywords='VOLATILE'></ptr>
    <ptr name='stubCtx' type='CALIB_STUB_CTX' ckeywords='VOLATILE'></ptr>
    <ptr name='flash' type='CALIB_BUFFER' ckeywords='CONST'></ptr>
</typedef>

<cjoker>
//------------------------------------------------------------------------------
// Defines
//------------------------------------------------------------------------------

#define CALIB_MAJ_MASK(x) ((x &gt;&gt; 8) &amp; 0xFF)
#define CALIB_MIN_MASK(x) (x &amp; 0xFF)
#define CALIB_MARK_MASK(x) (x &amp; 0xFFFF0000)
#define CALIB_VERSION(maj, min) (CALIB_MARK_VERSION | maj &lt;&lt; 8 | min &lt;&lt; 0)


//------------------------------------------------------------------------------
// Functions
//------------------------------------------------------------------------------

//=============================================================================
// calib_DaemonInit
//-----------------------------------------------------------------------------
/// At boot time, if the CALIB_TAG_CALIBRATED is in the validTag field of
/// the calibration flash sector, Calib uses the calibrated parameters
/// (i.e. the parameters present in the calib flash sector), else Calib
/// uses the default parameters.
/// @par
/// If the code has been compiled with the calibration mode flag set, at boot
/// time, this function also uses the remote parameters RAM buffer and copy 
/// the default parameters in it.
/// @par
/// This must be called in the PAL initialization, after the initialization
/// of the RF drivers.
//=============================================================================
PUBLIC VOID calib_DaemonInit(VOID);

//=============================================================================
// calib_DaemonProcess
//-----------------------------------------------------------------------------
/// Execute the calibration commands received by the remote calib tools. This
/// will, usually, update the calibration buffers with new values provided by
/// the user controlling the calib tools.
/// @par
/// This must be called in the PAL start frame.
//=============================================================================
PUBLIC VOID calib_DaemonProcess(VOID);

//=============================================================================
// calib_GetPointers
//-----------------------------------------------------------------------------
/// Access to the calibration parameters.
///
/// @return The global pointers used by the code to access the calibrated
/// parameters. When the target's flash does not contain a flash sector,
/// the calib parameters are initialized with default parameters during
/// the calibration init. Also returns the pointers used by the remote
/// calibration tools to get the version number of the calibration and to 
/// find the calibration buffers.
//=============================================================================
PUBLIC CALIB_CALIBRATION_T* calib_GetPointers(VOID);



//=============================================================================
// calib_SetStubContext
//-----------------------------------------------------------------------------
/// Used by the Calib Stub to define the calibration context structure that
/// the remote calibration tools must use to communicate with the Calib Stub.
///
/// @param ctx Pointer to the context where the remote calib tools must put
/// its calibration command to be executed by the Calib Stub.
//=============================================================================
PUBLIC VOID calib_SetStubContext(CONST CALIB_STUB_CTX_T *ctx);



//=============================================================================
// calib_SetXcvDefaults
//-----------------------------------------------------------------------------
/// Used by the transceiver RF driver to set its default calibration parameters
/// (see #calib_DaemonInit to know when they can be used). It must be called 
/// during the RF transceiver driver initialization.
///
/// @param param Pointer to a structure containing the default values to be
/// used by this transceiver model.
//=============================================================================
PUBLIC VOID calib_SetXcvDefaults(CONST CALIB_XCV_T* param);



//=============================================================================
// calib_SetPaDefaults
//-----------------------------------------------------------------------------
/// Used by the PA RF driver to set its default calibration parameters
/// (see #calib_DaemonInit to know when they can be used). It must be called 
/// during the RF PA driver initialization.
///
/// @param param Pointer to a structure containing the default values to be
/// used for this PA model.
//=============================================================================
PUBLIC VOID calib_SetPaDefaults(CONST CALIB_PA_T* param);



//=============================================================================
// calib_SetSwDefaults
//-----------------------------------------------------------------------------
/// Used by the switch RF driver to set the default calibration parameters
/// (see #calib_DaemonInit to know when they can be used). It must be called 
/// during the RF switch driver initialization.
///
/// @param param Pointer to a structure containing the default values to be
/// used for this switch model.
//=============================================================================
PUBLIC VOID calib_SetSwDefaults(CONST CALIB_SW_T* param);



//=============================================================================
// calib_DaemonTracePrint
//-----------------------------------------------------------------------------
/// Display in the trace the current calibration status, used for debug.
//=============================================================================
PUBLIC VOID calib_DaemonTracePrint(VOID);



// =============================================================================
// calib_DaemonSetContext
// -----------------------------------------------------------------------------
/// Defines the context structure that HST and CES must use.
/// @param ctx Pointer to the context to use.
// =============================================================================
PUBLIC VOID calib_DaemonSetContext(VOID* ctx);



// =============================================================================
// calib_DaemonUsrDataProcess
// -----------------------------------------------------------------------------
/// Apply and burn HST calibration buffer.
/// @return TRUE if success, and FALSE otherwise.
// =============================================================================
PUBLIC BOOL calib_DaemonUsrDataProcess(VOID);



// =============================================================================
// calib_GetRfCalibStatus
// -----------------------------------------------------------------------------
/// Get the status of RF calibration data.
/// @return 0 if calibrated with good CRC, 1 if calibrated with bad CRC,
///         2 if not calibrated.
// =============================================================================
PUBLIC UINT8 calib_GetRfCalibStatus(VOID);



// =============================================================================
// calib_GetAudioCalibStatus
// -----------------------------------------------------------------------------
/// Get the status of audio calibration data.
/// @return 0 if calibrated, 2 if not calibrated.
// =============================================================================
PUBLIC UINT8 calib_GetAudioCalibStatus(VOID);



/// @} // end of calib group

</cjoker>
</archive>

<archive relative='../../../platform/calib/include/calib_map.xmd'  asm="no">


    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    
    <include file="calib_m.xmd"/>


    


    
    <alias name="CALIB_MAP_ACCESS_T">
        <comment>
            This struct will contain pointers to the calibration info and to the struct where
            to put the calibration context requests. It also contains the address of the
            calibration sector in flash.
        </comment>
        <instance name='unused' type='CALIB_CALIBRATION_T'></instance>
    </alias>

<cjoker>

// =============================================================================
// calib_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID calib_RegisterYourself(VOID);

</cjoker>

</archive>


<archive relative='../../../platform_test/hal/gtes/include/gtes_config.xmd'  asm="no">


    <include load="no" file="cs_types.h"/>

    

    
    <enum name="GTES_TEST_ID">
    
        <entry name="GTES_TEST_ID_NONE" >
          <comment>
            DO NOT MODIFIED this entry.
            This is not a test IDentifier but the default value.
          </comment>
        </entry>
            
        <entry name="GTES_TEST_ID_BOARD_MANUAL_HELLOWORLD" /> 
        <entry name="GTES_TEST_ID_PROTO_AUTO_CALL"       />
        <entry name="GTES_TEST_ID_PROTO_AUTO_ATTACH"       />
        <entry name="GTES_TEST_ID_HAL_AUTO_UART"       />
        <entry name="GTES_TEST_ID_BOARD_AUTO_SIM"        />
        <entry name="GTES_TEST_ID_BOARD_AUTO_MEM"        />
        <entry name="GTES_TEST_ID_BOARD_AUTO_PLL"/>
        <entry name="GTES_TEST_ID_BOARD_AUTO_I2C_MAXIM"/>
        <entry name="GTES_TEST_ID_BOARD_MANUAL_AUDIO"/>
        <entry name="GTES_TEST_ID_BOARD_MANUAL_KEY"/>
        <entry name="GTES_TEST_ID_BOARD_MANUAL_RF"/>
        <entry name="GTES_TEST_ID_BOARD_MANUAL_GPO_CLK"/>
        <entry name="GTES_TEST_ID_BOARD_AUTO_UART"/>
        <entry name="GTES_TEST_ID_QTY"         >
    
        
    
          <comment>
            DO NOT MODIFIED this entry.
            This is not a test IDentifier but a value indicating the QuanTitY of known tests.
          </comment>
        </entry>
       
    </enum>

    <enum name="GTES_TEST_ERR">
        
        <entry name="GTES_TEST_ERR_NONE" value="0x0000">
            <comment>
            The test has been processed without any error.
            </comment>
        </entry>
        
        <entry name="GTES_TEST_ERR_PARAMETERS_MISSING">
          <comment>
            Parameters are missing.
          </comment>
        </entry>
        
        <entry name="GTES_TEST_ERR_BAD_PARAMETERS">
          <comment>
            Parameters are not convenient with this test.
          </comment>
        </entry>
        
        <entry name="GTES_TEST_ERR_CALL_UNKNOWN_STATUS">
          <comment>
            The chip does not know the call status before to start the call test.
          </comment>
        </entry>
        
        <entry name="GTES_TEST_ERR_CALL_ALREADY_CONNECTED">
          <comment>
            A call has already been established : Can not establish a new one.
          </comment>
        </entry>
        
        <entry name="GTES_TEST_ERR_CALL_ALREADY_DISCONNECTED">
          <comment>
            There is no call to stop : call status is disconnected.
          </comment>
        </entry>

        <entry name="GTES_TEST_ERR_NO_CS_SERVICE">
          <comment>
            the mobile has no CS service
          </comment>
        </entry>
       
        
        
    </enum>
    
    
    <enum name="GTES_LOAD_TESTS_STATUS">
	
	<entry name="GTES_LOAD_TESTS_STATUS_FAIL">
		<comment>
		The gtes initialization failed.
		</comment>
	</entry>

	<entry name="GTES_LOAD_TESTS_STATUS_SUCCESS">
		<comment>
		The gtes initialization succeeded.
		</comment>
	</entry>

    </enum>
     
    
    <typedef name="gtes_tests_globals" rubyconstants="yes">
    </typedef>

    <cjoker>
    
////////////////////////////////////////////////////////////////////////////////
// gtes_LoadHalTests
////////////////////////////////////////////////////////////////////////////////
/// This function registers all HAL unit tests in the global array gtesTestsList 
/// defined in gtes.c.
////////////////////////////////////////////////////////////////////////////////
PUBLIC GTES_LOAD_TESTS_STATUS_T gtes_LoadHalTests(VOID);

////////////////////////////////////////////////////////////////////////////////
// gtes_LoadBoardTests
////////////////////////////////////////////////////////////////////////////////
/// This function registers all Board Check unit tests in the global array 
/// gtesTestsList defined in gtes.c.
////////////////////////////////////////////////////////////////////////////////
PUBLIC GTES_LOAD_TESTS_STATUS_T gtes_LoadBoardTests(VOID);

////////////////////////////////////////////////////////////////////////////////
// gtes_LoadProtoTests
////////////////////////////////////////////////////////////////////////////////
/// This function registers all unit tests which need the proto in the global 
/// array  gtesTestsList defined in gtes.c.
////////////////////////////////////////////////////////////////////////////////
PUBLIC GTES_LOAD_TESTS_STATUS_T gtes_LoadProtoTests(VOID);

////////////////////////////////////////////////////////////////////////////////
// gtes_LoadAllTests
////////////////////////////////////////////////////////////////////////////////
/// This function registers all unit tests in the global array gtesTestsList 
/// defined in gtes.c.
////////////////////////////////////////////////////////////////////////////////
PUBLIC GTES_LOAD_TESTS_STATUS_T gtes_LoadAllTests(VOID);  
    
    </cjoker>


</archive>
<archive relative='../../../platform_test/hal/gtes/include/gtes_stack_msg.xmd'  asm='no'>

<var name='GTES_HVY_API' value='( 10 &lt;&lt; 16 )'></var>

<var name='GTES_HVY_API_GENERAL_IN' value='( GTES_HVY_API + 0 )'></var>

<var name='GTES_HVY_API_GENERAL_OUT' value='( GTES_HVY_API + 0x80 )'></var>

<var name='GTES_HVY_API_NW_IN' value='( GTES_HVY_API + 0x100 )'></var>

<var name='GTES_HVY_API_NW_OUT' value='( GTES_HVY_API + 0x180 )'></var>

<var name='GTES_HVY_API_CC_IN' value='( GTES_HVY_API + 0x200 )'></var>

<var name='GTES_HVY_API_CC_OUT' value='( GTES_HVY_API + 0x280 )'></var>

<var name='GTES_HVY_API_SS_IN' value='( GTES_HVY_API + 0x300 )'></var>

<var name='GTES_HVY_API_SS_OUT' value='( GTES_HVY_API + 0x380 )'></var>

<var name='GTES_HVY_API_PDP_IN' value='( GTES_HVY_API + 0x400 )'></var>

<var name='GTES_HVY_API_PDP_OUT' value='( GTES_HVY_API + 0x480 )'></var>

<var name='GTES_HVY_API_PSD_IN' value='( GTES_HVY_API + 0x500 )'></var>

<var name='GTES_HVY_API_PSD_OUT' value='( GTES_HVY_API + 0x580 )'></var>

<var name='GTES_HVY_API_SIM_IN' value='( GTES_HVY_API + 0x600 )'></var>

<var name='GTES_HVY_API_SIM_OUT' value='( GTES_HVY_API + 0x680 )'></var>

<var name='GTES_HVY_API_SMSPP_IN' value='( GTES_HVY_API + 0x700 )'></var>

<var name='GTES_HVY_API_SMSPP_OUT' value='( GTES_HVY_API + 0x780 )'></var>

<var name='GTES_HVY_API_SMSCB_IN' value='( GTES_HVY_API + 0x800 )'></var>

<var name='GTES_HVY_API_SMSCB_OUT' value='( GTES_HVY_API + 0x880 )'></var>

<var name='GTES_HVY_API_CSD_IN' value='( GTES_HVY_API + 0x900 )'></var>

<var name='GTES_HVY_API_CSD_OUT' value='( GTES_HVY_API + 0x980 )'></var>

<var name='GTES_HVY_API_CTR_IN' value='( GTES_HVY_API + 0xa00 )'></var>

<var name='GTES_HVY_API_CTR_OUT' value='( GTES_HVY_API + 0xa80 )'></var>

<var name='GTES_HVY_API_RESERVED' value='( GTES_HVY_API + 0xFF00 )'>
	<comment>values (GTES_HVY_API+0xFF00) and above are RESERVED</comment>
</var>


<enum name="GTES_API_MSG">

<entry name='GTES_STACK_NOT_USED' value='0'></entry>

<entry name='GTES_API_START_REQ' value='( GTES_HVY_API_GENERAL_IN + 0 )'>
	<comment>General: MMI -&amp;gt; GTES_API</comment>
</entry>

<entry name='GTES_API_STOP_REQ' value='( GTES_HVY_API_GENERAL_IN + 1 )'></entry>

<entry name='GTES_API_IMEI_REQ' value='( GTES_HVY_API_GENERAL_IN + 2 )'></entry>

<entry name='GTES_API_QUAL_REPORT_REQ' value='( GTES_HVY_API_GENERAL_IN + 3 )'></entry>

<entry name='GTES_API_NWKINFO_IND' value='( GTES_HVY_API_GENERAL_IN + 4 )'></entry>

<entry name='GTES_API_DBGINFO_CMD' value='( GTES_HVY_API_GENERAL_IN + 5 )'></entry>

<entry name='GTES_API_CURCELL_INFO_REQ' value='( GTES_HVY_API_GENERAL_IN + 6 )'></entry>

<entry name='GTES_API_ADJCELL_INFO_REQ' value='( GTES_HVY_API_GENERAL_IN + 7 )'></entry>

<entry name='GTES_API_IMEI_IND' value='( GTES_HVY_API_GENERAL_OUT + 0 )'>
	<comment>General: GTES_API -&amp;gt; MMI</comment>
</entry>

<entry name='GTES_API_QUAL_REPORT_CNF' value='( GTES_HVY_API_GENERAL_OUT + 1 )'></entry>

<entry name='GTES_API_STOP_CNF' value='( GTES_HVY_API_GENERAL_OUT + 2 )'></entry>

<entry name='GTES_API_DBGINFO_IND' value='( GTES_HVY_API_GENERAL_OUT + 3 )'></entry>

<entry name='GTES_API_CURCELL_INFO_IND' value='( GTES_HVY_API_GENERAL_OUT + 4 )'></entry>

<entry name='GTES_API_ADJCELL_INFO_IND' value='( GTES_HVY_API_GENERAL_OUT + 5 )'></entry>

<entry name='GTES_API_NW_SELMODE_REQ' value='( GTES_HVY_API_NW_IN + 0 )'>
	<comment>Network services: MMI -&amp;gt; GTES_API</comment>
</entry>

<entry name='GTES_API_NW_LIST_REQ' value='( GTES_HVY_API_NW_IN + 1 )'></entry>

<entry name='GTES_API_NW_LISTABORT_REQ' value='( GTES_HVY_API_NW_IN + 2 )'></entry>

<entry name='GTES_API_NW_LISTABORT_IND' value='( GTES_HVY_API_NW_IN + 3 )'></entry>

<entry name='GTES_API_NW_SEL_REQ' value='( GTES_HVY_API_NW_IN + 4 )'></entry>

<entry name='GTES_API_NW_RESEL_REQ' value='( GTES_HVY_API_NW_IN + 5 )'></entry>

<entry name='GTES_API_NW_PSATTACH_REQ' value='( GTES_HVY_API_NW_IN + 6 )'></entry>

<entry name='GTES_API_NW_PSDETACH_REQ' value='( GTES_HVY_API_NW_IN + 7 )'></entry>

<entry name='GTES_API_NW_CSREGSTATUS_IND' value='( GTES_HVY_API_NW_OUT + 0 )'>
	<comment>Network services: GTES_API -&amp;gt; MMI</comment>
</entry>

<entry name='GTES_API_NW_PSREGSTATUS_IND' value='( GTES_HVY_API_NW_OUT + 1 )'></entry>

<entry name='GTES_API_NW_LIST_IND' value='( GTES_HVY_API_NW_OUT + 2 )'></entry>

<entry name='GTES_API_CC_SETUP_REQ' value='( GTES_HVY_API_CC_IN + 0 )'>
	<comment>CC: MMI -&amp;gt; GTES_API</comment>
</entry>

<entry name='GTES_API_CC_CALLCONF_REQ' value='( GTES_HVY_API_CC_IN + 1 )'></entry>

<entry name='GTES_API_CC_ALERT_REQ' value='( GTES_HVY_API_CC_IN + 2 )'></entry>

<entry name='GTES_API_CC_CONNECT_REQ' value='( GTES_HVY_API_CC_IN + 3 )'></entry>

<entry name='GTES_API_CC_DISC_REQ' value='( GTES_HVY_API_CC_IN + 4 )'></entry>

<entry name='GTES_API_CC_RELEASE_REQ' value='( GTES_HVY_API_CC_IN + 5 )'></entry>

<entry name='GTES_API_CC_RELEASECMPLT_REQ' value='( GTES_HVY_API_CC_IN + 6 )'></entry>

<entry name='GTES_API_CC_STARTDTMF_REQ' value='( GTES_HVY_API_CC_IN + 7 )'></entry>

<entry name='GTES_API_CC_STOPDTMF_REQ' value='( GTES_HVY_API_CC_IN + 8 )'></entry>

<entry name='GTES_API_CC_CALLHOLD_REQ' value='( GTES_HVY_API_CC_IN + 9 )'></entry>

<entry name='GTES_API_CC_CALLRETRIEVE_REQ' value='( GTES_HVY_API_CC_IN + 0xA )'></entry>

<entry name='GTES_API_CC_MODIFY_REQ' value='( GTES_HVY_API_CC_IN + 0xB )'></entry>

<entry name='GTES_API_CC_MODIFYCMPLT_REQ' value='( GTES_HVY_API_CC_IN + 0xC )'></entry>

<entry name='GTES_API_CC_MODIFYREJ_REQ' value='( GTES_HVY_API_CC_IN + 0xD )'></entry>

<entry name='GTES_API_CC_NOTIFY_REQ' value='( GTES_HVY_API_CC_IN + 0xE )'></entry>

<entry name='GTES_API_CC_FACILITY_REQ' value='( GTES_HVY_API_CC_IN + 0xF )'></entry>

<entry name='GTES_API_CC_USER_INFO_REQ' value='( GTES_HVY_API_CC_IN + 0x10 )'></entry>

<entry name='GTES_API_CC_TI_IND' value='( GTES_HVY_API_CC_OUT + 0 )'>
	<comment>CC: GTES_API -&amp;gt; MMI</comment>
</entry>

<entry name='GTES_API_CC_SETUP_IND' value='( GTES_HVY_API_CC_OUT + 1 )'></entry>

<entry name='GTES_API_CC_CALLPROC_IND' value='( GTES_HVY_API_CC_OUT + 2 )'></entry>

<entry name='GTES_API_CC_PROGRESS_IND' value='( GTES_HVY_API_CC_OUT + 3 )'></entry>

<entry name='GTES_API_CC_ALERT_IND' value='( GTES_HVY_API_CC_OUT + 4 )'></entry>

<entry name='GTES_API_CC_CONNECT_IND' value='( GTES_HVY_API_CC_OUT + 5 )'></entry>

<entry name='GTES_API_CC_CONNECTACK_IND' value='( GTES_HVY_API_CC_OUT + 6 )'></entry>

<entry name='GTES_API_CC_DISC_IND' value='( GTES_HVY_API_CC_OUT + 7 )'></entry>

<entry name='GTES_API_CC_RELEASE_IND' value='( GTES_HVY_API_CC_OUT + 8 )'></entry>

<entry name='GTES_API_CC_RELEASECMPLT_IND' value='( GTES_HVY_API_CC_OUT + 9 )'></entry>

<entry name='GTES_API_CC_ERROR_IND' value='( GTES_HVY_API_CC_OUT + 0xA )'></entry>

<entry name='GTES_API_CC_CALLHOLD_CNF' value='( GTES_HVY_API_CC_OUT + 0xB )'></entry>

<entry name='GTES_API_CC_CALLRETRIEVE_CNF' value='( GTES_HVY_API_CC_OUT + 0xC )'></entry>

<entry name='GTES_API_CC_MODIFY_IND' value='( GTES_HVY_API_CC_OUT + 0xD )'></entry>

<entry name='GTES_API_CC_MODIFYCMPLT_IND' value='( GTES_HVY_API_CC_OUT + 0xE )'></entry>

<entry name='GTES_API_CC_MODIFYREJ_IND' value='( GTES_HVY_API_CC_OUT + 0xF )'></entry>

<entry name='GTES_API_CC_NOTIFY_IND' value='( GTES_HVY_API_CC_OUT + 0x10 )'></entry>

<entry name='GTES_API_CC_AUDIOON_IND' value='( GTES_HVY_API_CC_OUT + 0x11 )'></entry>

<entry name='GTES_API_CC_FACILITY_IND' value='( GTES_HVY_API_CC_OUT + 0x12 )'></entry>

<entry name='GTES_API_CC_USER_INFO_IND' value='( GTES_HVY_API_CC_OUT + 0x13 )'></entry>

<entry name='GTES_API_CC_CONG_CTRL_IND' value='( GTES_HVY_API_CC_OUT + 0x14 )'></entry>

<entry name='GTES_API_CC_AOC_CCM_IND' value='( GTES_HVY_API_CC_OUT + 0x15 )'></entry>

<entry name='GTES_API_CC_CHANMODE_IND' value='( GTES_HVY_API_CC_OUT + 0x16 )'></entry>

<entry name='GTES_API_SS_ACTION_REQ' value='( GTES_HVY_API_SS_IN + 0 )'>
	<comment>SS: MMI -&amp;gt; GTES_API</comment>
</entry>

<entry name='GTES_API_SS_ACTION_CNF' value='( GTES_HVY_API_SS_OUT + 0 )'>
	<comment>SS: GTES_API -&amp;gt; MMI</comment>
</entry>

<entry name='GTES_API_SS_TI_IND' value='( GTES_HVY_API_SS_OUT + 1 )'></entry>

<entry name='GTES_API_SS_ERROR_IND' value='( GTES_HVY_API_SS_OUT + 2 )'></entry>

<entry name='GTES_API_PDP_CTXACTIVATE_REQ' value='( GTES_HVY_API_PDP_IN + 0 )'>
	<comment>PDP: MMI -&amp;gt; GTES_API</comment>
</entry>

<entry name='GTES_API_PDP_CTXMODIFY_REQ' value='( GTES_HVY_API_PDP_IN + 1 )'></entry>

<entry name='GTES_API_PDP_CTXMODIFY_ACC' value='( GTES_HVY_API_PDP_IN + 2 )'></entry>

<entry name='GTES_API_PDP_CTXDEACTIVATE_REQ' value='( GTES_HVY_API_PDP_IN + 3 )'></entry>

<entry name='GTES_API_PDP_SETMINQOS_REQ' value='( GTES_HVY_API_PDP_IN + 4 )'></entry>

<entry name='GTES_API_PDP_CTXACTIVATE_CNF' value='( GTES_HVY_API_PDP_OUT + 0 )'>
	<comment>PDP: GTES_API -&amp;gt; MMI</comment>
</entry>

<entry name='GTES_API_PDP_CTXSMINDEX_IND' value='( GTES_HVY_API_PDP_OUT + 1 )'></entry>

<entry name='GTES_API_PDP_CTXACTIVATE_REJ' value='( GTES_HVY_API_PDP_OUT + 2 )'></entry>

<entry name='GTES_API_PDP_CTXACTIVATE_IND' value='( GTES_HVY_API_PDP_OUT + 3 )'></entry>

<entry name='GTES_API_PDP_CTXMODIFY_CNF' value='( GTES_HVY_API_PDP_OUT + 4 )'></entry>

<entry name='GTES_API_PDP_CTXMODIFY_REJ' value='( GTES_HVY_API_PDP_OUT + 5 )'></entry>

<entry name='GTES_API_PDP_CTXMODIFY_IND' value='( GTES_HVY_API_PDP_OUT + 6 )'></entry>

<entry name='GTES_API_PDP_CTXDEACTIVATE_IND' value='( GTES_HVY_API_PDP_OUT + 7 )'></entry>

<entry name='GTES_API_PDP_CTXDEACTIVATE_CNF' value='( GTES_HVY_API_PDP_OUT + 8 )'></entry>

<entry name='GTES_API_PSDATA_REQ' value='( GTES_HVY_API_PSD_IN + 0 )'>
	<comment>Packet Switched Data: MMI -&amp;gt; GTES_API</comment>
</entry>

<entry name='GTES_API_PSDATA_IND' value='( GTES_HVY_API_PSD_OUT + 0 )'>
	<comment>Packet Switched Data: GTES_API -&amp;gt; MMI</comment>
</entry>

<entry name='GTES_API_PS_QUEUECREATE_IND' value='( GTES_HVY_API_PSD_OUT + 1 )'></entry>

<entry name='GTES_API_SIM_RESET_REQ' value='( GTES_HVY_API_SIM_IN + 0 )'>
	<comment>SIM: MMI -&amp;gt; GTES_API</comment>
</entry>

<entry name='GTES_API_SIM_READBINARY_REQ' value='( GTES_HVY_API_SIM_IN + 1 )'></entry>

<entry name='GTES_API_SIM_UPDATEBINARY_REQ' value='( GTES_HVY_API_SIM_IN + 2 )'></entry>

<entry name='GTES_API_SIM_READRECORD_REQ' value='( GTES_HVY_API_SIM_IN + 3 )'></entry>

<entry name='GTES_API_SIM_UPDATERECORD_REQ' value='( GTES_HVY_API_SIM_IN + 4 )'></entry>

<entry name='GTES_API_SIM_INVALIDATE_REQ' value='( GTES_HVY_API_SIM_IN + 5 )'></entry>

<entry name='GTES_API_SIM_REHABILITATE_REQ' value='( GTES_HVY_API_SIM_IN + 6 )'></entry>

<entry name='GTES_API_SIM_SEEK_REQ' value='( GTES_HVY_API_SIM_IN + 7 )'></entry>

<entry name='GTES_API_SIM_INCREASE_REQ' value='( GTES_HVY_API_SIM_IN + 8 )'></entry>

<entry name='GTES_API_SIM_VERIFYCHV_REQ' value='( GTES_HVY_API_SIM_IN + 9 )'></entry>

<entry name='GTES_API_SIM_CHANGECHV_REQ' value='( GTES_HVY_API_SIM_IN + 10 )'></entry>

<entry name='GTES_API_SIM_DISABLECHV_REQ' value='( GTES_HVY_API_SIM_IN + 11 )'></entry>

<entry name='GTES_API_SIM_ENABLECHV_REQ' value='( GTES_HVY_API_SIM_IN + 12 )'></entry>

<entry name='GTES_API_SIM_UNBLOCKCHV_REQ' value='( GTES_HVY_API_SIM_IN + 13 )'></entry>

<entry name='GTES_API_SIM_ELEMFILESTATUS_REQ' value='( GTES_HVY_API_SIM_IN + 14 )'></entry>

<entry name='GTES_API_SIM_DEDICFILESTATUS_REQ' value='( GTES_HVY_API_SIM_IN + 15 )'></entry>

<entry name='GTES_API_SIM_TERMINALPROFILE_REQ' value='( GTES_HVY_API_SIM_IN + 16 )'></entry>

<entry name='GTES_API_SIM_TERMINALENVELOPE_REQ' value='( GTES_HVY_API_SIM_IN + 17 )'></entry>

<entry name='GTES_API_SIM_TERMINALRESPONSE_REQ' value='( GTES_HVY_API_SIM_IN + 18 )'></entry>

<entry name='GTES_API_SIM_STKACTIVATE_REQ' value='( GTES_HVY_API_SIM_IN + 19 )'></entry>

<entry name='GTES_API_SIM_OPEN_IND' value='( GTES_HVY_API_SIM_IN + 20 )'></entry>

<entry name='GTES_API_SIM_CLOSE_IND' value='( GTES_HVY_API_SIM_IN + 21 )'></entry>

<entry name='GTES_API_SIM_POLL_REQ' value='( GTES_HVY_API_SIM_IN + 22 )'></entry>

<entry name='GTES_API_SIM_POLLOFF_REQ' value='( GTES_HVY_API_SIM_IN + 23 )'></entry>

<entry name='GTES_API_SIM_RESET_CNF' value='( GTES_HVY_API_SIM_OUT + 0 )'>
	<comment>SIM: GTES_API -&amp;gt; MMI</comment>
</entry>

<entry name='GTES_API_SIM_STATUSERROR_IND' value='( GTES_HVY_API_SIM_OUT + 1 )'></entry>

<entry name='GTES_API_SIM_READBINARY_CNF' value='( GTES_HVY_API_SIM_OUT + 2 )'></entry>

<entry name='GTES_API_SIM_UPDATEBINARY_CNF' value='( GTES_HVY_API_SIM_OUT + 3 )'></entry>

<entry name='GTES_API_SIM_READRECORD_CNF' value='( GTES_HVY_API_SIM_OUT + 4 )'></entry>

<entry name='GTES_API_SIM_UPDATERECORD_CNF' value='( GTES_HVY_API_SIM_OUT + 5 )'></entry>

<entry name='GTES_API_SIM_INVALIDATE_CNF' value='( GTES_HVY_API_SIM_OUT + 6 )'></entry>

<entry name='GTES_API_SIM_REHABILITATE_CNF' value='( GTES_HVY_API_SIM_OUT + 7 )'></entry>

<entry name='GTES_API_SIM_SEEK_CNF' value='( GTES_HVY_API_SIM_OUT + 8 )'></entry>

<entry name='GTES_API_SIM_INCREASE_CNF' value='( GTES_HVY_API_SIM_OUT + 9 )'></entry>

<entry name='GTES_API_SIM_VERIFYCHV_CNF' value='( GTES_HVY_API_SIM_OUT + 10 )'></entry>

<entry name='GTES_API_SIM_CHANGECHV_CNF' value='( GTES_HVY_API_SIM_OUT + 11 )'></entry>

<entry name='GTES_API_SIM_DISABLECHV_CNF' value='( GTES_HVY_API_SIM_OUT + 12 )'></entry>

<entry name='GTES_API_SIM_ENABLECHV_CNF' value='( GTES_HVY_API_SIM_OUT + 13 )'></entry>

<entry name='GTES_API_SIM_UNBLOCKCHV_CNF' value='( GTES_HVY_API_SIM_OUT + 14 )'></entry>

<entry name='GTES_API_SIM_ELEMFILESTATUS_CNF' value='( GTES_HVY_API_SIM_OUT + 15 )'></entry>

<entry name='GTES_API_SIM_DEDICFILESTATUS_CNF' value='( GTES_HVY_API_SIM_OUT + 16 )'></entry>

<entry name='GTES_API_SIM_TERMINALPROFILE_CNF' value='( GTES_HVY_API_SIM_OUT + 17 )'></entry>

<entry name='GTES_API_SIM_TERMINALENVELOPE_CNF' value='( GTES_HVY_API_SIM_OUT + 18 )'></entry>

<entry name='GTES_API_SIM_TERMINALRESPONSE_CNF' value='( GTES_HVY_API_SIM_OUT + 19 )'></entry>

<entry name='GTES_API_SIM_FETCH_IND' value='( GTES_HVY_API_SIM_OUT + 20 )'></entry>

<entry name='GTES_API_SMSPP_SEND_REQ' value='( GTES_HVY_API_SMSPP_IN + 0 )'>
	<comment>SMS-PP: MMI -&amp;gt; GTES_API</comment>
</entry>

<entry name='GTES_API_SMSPP_SENDMMA_REQ' value='( GTES_HVY_API_SMSPP_IN + 1 )'></entry>

<entry name='GTES_API_SMSPP_ACK_REQ' value='( GTES_HVY_API_SMSPP_IN + 2 )'></entry>

<entry name='GTES_API_SMSPP_ERROR_REQ' value='( GTES_HVY_API_SMSPP_IN + 3 )'></entry>

<entry name='GTES_API_SMSPP_ABORTMMA_REQ' value='( GTES_HVY_API_SMSPP_IN + 4 )'></entry>

<entry name='GTES_API_SMSPP_ABORT_REQ' value='( GTES_HVY_API_SMSPP_IN + 5 )'></entry>

<entry name='GTES_API_SMSPP_ACK_IND' value='( GTES_HVY_API_SMSPP_OUT + 0 )'>
	<comment>SMS-PP: GTES_API -&amp;gt; MMI</comment>
</entry>

<entry name='GTES_API_SMSPP_ERROR_IND' value='( GTES_HVY_API_SMSPP_OUT + 1 )'></entry>

<entry name='GTES_API_SMSPP_RECEIVE_IND' value='( GTES_HVY_API_SMSPP_OUT + 2 )'></entry>

<entry name='GTES_API_SMSCB_ACTIVATE_REQ' value='( GTES_HVY_API_SMSCB_IN + 0 )'>
	<comment>SMS-CB: MMI -&amp;gt; GTES_API</comment>
</entry>

<entry name='GTES_API_SMSCB_DEACTIVATE_REQ' value='( GTES_HVY_API_SMSCB_IN + 1 )'></entry>

<entry name='GTES_API_SMSCB_RECEIVE_IND' value='( GTES_HVY_API_SMSCB_OUT + 0 )'>
	<comment>SMS-CB: GTES_API -&amp;gt; MMI</comment>
</entry>

<entry name='GTES_API_SMSCB_PAGE_IND' value='( GTES_HVY_API_SMSCB_OUT + 1 )'></entry>

<entry name='GTES_API_CSD_DATA_REQ' value='( GTES_HVY_API_CSD_IN + 0 )'>
	<comment>Fax, Data : MMI -&amp;gt; GTES_API</comment>
</entry>

<entry name='GTES_API_CSD_CRLPSET_REQ' value='( GTES_HVY_API_CSD_IN + 1 )'></entry>

<entry name='GTES_API_CSD_CRLPRD_REQ' value='( GTES_HVY_API_CSD_IN + 2 )'></entry>

<entry name='GTES_API_CSD_DATA_IND' value='( GTES_HVY_API_CSD_OUT + 0 )'>
	<comment>Fax, Data : GTES_API -&amp;gt; MMI</comment>
</entry>

<entry name='GTES_API_CSD_CRLPRD_IND' value='( GTES_HVY_API_CSD_OUT + 1 )'></entry>

<entry name='GTES_API_SYS_CTR_IND' value='( GTES_HVY_API_CTR_OUT + 0 )'></entry>

<entry name='GTES_API_START_GTES_STACK_ERR' value='(GTES_HVY_API_GENERAL_OUT + 10)'></entry>

</enum>

<typedef name="gtes_stack_globals" rubyconstants="yes">
	</typedef>


</archive>


<archive relative='../../../platform_test/hal/gtes/include/gtes_m.xmd'  asm="no">



<include file="gtes_config.xmd" />
<include file="gtes_stack_msg.xmd"/>

<comment> 
BE CAUTIOUS !!!
This header MUST NOT BE MODIFIED when adding a new test unless you exactly know what you do.
When adding a new test, unically gtes_config.h header and gtes_config.c shall be modified.

@file gtes_m<br/>
<br/>
@mainpage General Description<br/>
<br/>
@todo Documentation under construction...<br/>
<br/>
This document describes the characteristics of the @b Granite based phone @b Tester @b Embedded @b Stub ( GTES ) and how to use it via its API.<br/>
<br/>
GTES core, through its API, allows you to :<br/>
- Init the embedded tester to execute tests from CoolTester<br/>
- Register new tests<br/>
- Poll/execute commands from CoolTester <br/>
- Store stack messages <br/>
.<br/>

Go to the @b GTES @b API : @ref API <br/>

<br/>

@par Files organisation :<br/>
<br/>
All gtes header files are generated with coolxml in order to made all structures useabled via CoolRuby : <br />
<br/>
- @ref gtes_m.h/ @ref gtes.c is the core of GTES. GTES API functions are defined here. <br/>
These files MUST NOT BE MODIFIED when adding a new test unless you exactly know what you do.<br/>
<br/>
- @ref gtes_config.h/ @ref gtes_config.c are configurations files which must be modified when adding an new test.<br/>
 These files are the interface between GTES core and all the different unit tests ever created. <br/>
<br/>
- gtes_test_myTest1.c/gtes_test_myTest1.h etc... are user unit tests, integrated to the GTES core.<br/>

@image html gtes_files.png<br/>
<br/>

@par CoolTester remote communication : <br/>
<br/>
GTES could be use as a -stand alone- via CoolWatcher but it has been designed to work with the remote CoolTester tool.<br/>
Thus, one of the most important structure is the global remote communication one called #g_gtesRemoteStructure of type #GTES_REMOTE_STRUCTURE_T. This structure is linked to the Granite map through gtes_map.xmd file and, as a result reachable from CoolTester.<br/>
Thanks to this structure, CoolTester can check GTES main status ( avalaible, busy etc..),last executed test status, potential test executions errors. Furthermore, CoolTester can execute command with parameters like starting a test with a specified ID.<br/>

@par User tests management : <br/>
<br/>
From GTES point of view, each test is described by five elements : <br/>
- An unique IDentifier, defined in @ref gtes_config.h <br/>
- A set of @b execution errors, defined in @ref gtes_config.h <br/>
- A main test function which is the test entry point, defined in gtes_test_@e myTestName.c<br/>
- A parameters structure instanciated in gtes_test_@e myTestName.c where all test parameters, if any, are gathered <br/>
- A results structure instanciated in gtes_test_@e myTestName.c, where all test results ( sub test results etc..) are gathered <br/>
<br/>
To be executed from CoolTester a test must be registered in a global tests array call #g_gtesTestsList instanciated
in @ref gtes.c.<br/>
This array can be seen as a tests -database-, and a link between tests loaded on the chip and GTES core. <br/>
Each line of this array matches a unique test and is composed with : <br/>
- The test ID <br/>
- A pointer to the test parameters structure <br/>
- A pointer to the test results structure <br/>
- A pointer to the test main function <br/>
<br/>
This operation can be done thanks to the GTES function #gtes_RegisterNewTest. <br/>
Since #g_gtesTestsList is reachable from CoolTester ( at a known address via gtes_map), the following operations could be done from remote control : <br/>
1) Write test parameters directly in its parameters structure <br/>
2) Start the test through its main function <br/>
3) Read tests results directly in its results structure <br/>

@image html gtes_structures.png

<br/>
<br/>

<br/>
<br/>

@defgroup API GTES <br/>
@{<br/>
</comment>

<include load="no" file="cs_types.h"/>


<var name="GTES_MAJOR_VERSION" value="0x01">
	<comment> Major version of Granite Tester Embedded Stub. </comment>
</var>

<var name="GTES_MINOR_VERSION" value="0x00">
	<comment> Minor version of Granite Tester Embedded Stub. </comment>
</var>

<var name="GTES_MAGIC_NUMBER" value="0x1e51">
	<comment> Magic number which indicates the presence of Granite Tester Embedded Stub in the chip. </comment>
</var>

<var name="GTES_VERSION" value="(GTES_MAGIC_NUMBER &lt;&lt; 16) | ( GTES_MAJOR_VERSION &lt;&lt; 8) | GTES_MINOR_VERSION" >
	<comment> Stores both the magic number and the version ( Major.Minor ) in 32 bits. </comment>
</var>

<var name="GTES_TASK_PRIORITY" value="200">
	<comment> Priority of the GTES task. </comment>
</var>

<var name="GTES_TASK_SIZE" value="4*128">
	<comment> GTES task size. </comment>
</var>

<var name="GTES_TASK_POLLING_PERIOD" value="327">
	<comment> Polling period is 20ms. </comment>
</var>

<var name="GTES_MAX_TESTS" value="0xF">
	<comment> Maximum of 127 tests in the test table. </comment>
</var>

<typedef name="gtes_globals" rubyconstants="yes">
	</typedef>


<typedef name="GTES_TEST">
	
	<comment>
	This structure defines a generic test with an unique id, pointers to its test_function, its parameters ( eventually ) and its results.
	</comment>

	<instance name="testId" type="GTES_TEST_ID" />
	
	<ptr type="VOID" name="testFunction">
		<comment>
		Generic pointer to the test function : Shall be cast by typedef GTES_TEST_ERR_T (*)(VOID*,VOID*).
		</comment>	
	</ptr>
	
	<ptr type="VOID" name="testParams">
		<comment>
		Generic pointer to the test parameters : NULL if the test does not need any parameters.
		</comment>	
	</ptr>
	
	<ptr type="VOID" name="testResults">
		<comment>
		Generic pointer to the test results.
		</comment>	
	</ptr>
	
</typedef>


<alias name="GTES_TESTS_LIST" > 
	<comment> Array listing all tests with pointers to its function, parameters and results. Its size is specify in gtes_config.xmd </comment>
	<instance type="GTES_TEST" name="unused" count="GTES_MAX_TESTS"/>
</alias>


<enum name="GTES_REMOTE_CMD">
	
	<entry name="GTES_CMD_NO" value="0x0000">
		<comment>
		By default.
		</comment>
	</entry>
	
	<entry name="GTES_CMD_IS_ALIVE">
		<comment>
		This cmd is used by CoolTester to check if GTES is still alive that is to say if GTES still poll
		CoolTester cmds.
		</comment>
	</entry>
		
	<entry name="GTES_CMD_START_TEST">
		<comment>
		CoolTester asks remotely to start a test which id is specify in coolTesterParam field of the communication structure of type GTES_REMOTE_STRUCTURE_T.
		</comment>
	</entry>
	
	

</enum>


<enum name="GTES_MAIN_STATUS">
	
	<entry name="GTES_MAIN_STATUS_NOT_INIT" >
		<comment>
		GTES has not yet been initialized : No tests are registered.
		</comment>
	</entry>

	<entry name="GTES_MAIN_STATUS_REGISTER_ERR" >
		<comment>
		An error has occured when registering a test.
		</comment>
	</entry>
	
	<entry name="GTES_MAIN_STATUS_BUSY">
		<comment>
		A test is under process in GTES : can not execute a cmd for the moment.
		</comment>
	</entry>
	
	<entry name="GTES_MAIN_STATUS_READY">
		<comment>
		No test are processing in GTES : GTES is ready to process a remote command.
		</comment>
	</entry>
	
	
</enum>


<enum name="GTES_REGISTER_ERR">
	
	<entry name="GTES_REGISTER_ERR_NONE" >
		<comment>
		None error occured during the test registration process.
		</comment>
	</entry>

    <entry name="GTES_REGISTER_ERR_TOO_MANY_TESTS">
		<comment>
		The test list g_gtesTestsList can't accept a new test.
		</comment>
	</entry>
    
    <entry name="GTES_REGISTER_ERR_TEST_FUNCTION_NOT_PRECISED" >
		<comment>
		An entry test function has not been precised during the test registration process.
		Check if pointer to #gtes_TestFunctionMyTestName has been given as a parameter to
		#gtes_RegisterNewTest function.
		</comment>
	</entry>
	
	<entry name="GTES_REGISTER_ERR_TEST_UNKNOWN_ID" >
		<comment>
		A test IDentifier precised during the test registration process is unknown !
		It means that one of the test IDentifiers registered is not well described in gtes_config.xmd.
		</comment>
	</entry>
			
	
</enum>


<enum name="GTES_TEST_STATUS">
    
    <entry name="GTES_TEST_STATUS_PROCESSING">
        <comment>
		The test is in process and it will keep this value if it entered in an infinite loop.
		</comment>
	</entry>
    
	<entry name="GTES_TEST_STATUS_RESULTS_AVAILABLE">
		<comment>
		Last test results are available.
		</comment>
	</entry>

	<entry name="GTES_TEST_STATUS_ID_NOT_PRECISED">
		<comment>
		The test id has not been precised before the remote cmd GTES_CMD_START_TEST.
		</comment>
	</entry>

	<entry name="GTES_TEST_STATUS_UNKNOWN_ID">
		<comment>
		The remote required test has not been found in the chip.
		</comment>
	</entry>

	<entry name="GTES_TEST_STATUS_ERR">
		<comment>
		An error has occured during the last test execution.
		</comment>
	</entry>
	
	

</enum>


<enum name="GTES_ADD_NEW_TEST_STATUS">
	
	<entry name="GTES_ADD_NEW_TEST_FAIL">
		<comment>
		The new test has not well been registered.
		</comment>
	</entry>

	<entry name="GTES_ADD_NEW_TEST_SUCCESSFUL">
		<comment>
		The new test has well been registered.
		</comment>
	</entry>

</enum>



<enum name="GTES_EVENT">
	
	<entry name="GTES_EVENT_TEST_STARTED" value="(GTES_MAGIC_NUMBER &lt;&lt; 16)">
		<comment>
		This event is sent just before to call #gtes_function_mytestname.
		</comment>
	</entry>

	<entry name="GTES_EVENT_TEST_FINISHED" value="(GTES_MAGIC_NUMBER &lt;&lt; 16)+1">
		<comment>
		This event is sent when we are out of #gtes_function_mytestname.
		</comment>
	</entry>
    
    <entry name="GTES_EVENT_ALIVE" value="(GTES_MAGIC_NUMBER &lt;&lt; 16)+2">
		<comment>
		This event is sent as an automatic response when GTES_CMD_IS_ALIVE is received.
		</comment>
	</entry>
    
</enum>

<enum name="GTES_CALL_STATUS">
	
	<entry name="GTES_CALL_STATUS_NO_CS_SERVICE" value="0x0000">
		<comment>
		MS is not camped
		</comment>
	</entry>
	
	<entry name="GTES_CALL_STATUS_IDLE">
		<comment>
		MS in Idle mode
		</comment>
    </entry>
    
	<entry name="GTES_CALL_STATUS_CONNECTED">
		<comment>
		MS established a TCH
		</comment>
	</entry>
	
</enum>

<enum name="GTES_SMS_STATUS">
	
	<entry name="GTES_SMS_STATUS_NONE" value="0x0000">
		<comment>
		None SMS received.
		</comment>
	</entry>
	
	<entry name="GTES_SMS_STATUS_RECEIVED">
		<comment>
		SMS received.
		</comment>
	</entry>
	
</enum>

<enum name="GTES_API_CC_ERROR">
	
	<entry name="GTES_API_CC_ERROR_NONE" value="0x0000"/>
	<entry name="GTES_API_CC_ERROR_NORMAL_RELEASE" />
	<entry name="GTES_API_CC_ERROR_LOWER_LAYER_FAILURE"/>
	<entry name="GTES_API_CC_ERROR_REQUEST_IMPOSSIBLE"/>
	<entry name="GTES_API_CC_ERROR_INCOMING_CALL_BARRED"/>
	<entry name="GTES_API_CC_ERROR_OUTGOING_CALL_BARRED"/>
	<entry name="GTES_API_CC_ERROR_CALL_HOLD_REJECTED"/>
	<entry name="GTES_API_CC_ERROR_CALL_RETRIEVE_REJECTED"/>
	<entry name="GTES_API_CC_ERROR_CC_TIMER_EXPIRY">
	    <comment>
		Used for the MultiParty.
		</comment>
    </entry>
    <entry name="GTES_API_CC_ERROR_PROTOCOL_ERROR">
	    <comment>
		An error happen on a protocol message.
		</comment>
    </entry>

</enum>

<typedef name="GTES_STACK_STATUS">
	
	<comment>
	This structure contains the main elements describing the stack status.
	</comment>
    
    
	<instance name="lastApiToMmiMsg" type="GTES_API_MSG" />
	
	<instance name="lastCcError" type="GTES_API_CC_ERROR" />
	
	<UINT8 name="lastTi" >
		<comment>
		This attribute is the last transaction indicator set by the network.
		</comment>
	</UINT8>
    
    <instance name="callStatus" type="GTES_CALL_STATUS" />
    
    <instance name="smsStatus" type="GTES_SMS_STATUS" />
    
    
</typedef>



<typedef name="GTES_REMOTE_STRUCTURE">
	
	<comment>
	This is the main structure of communication between GTES and CoolTester remote tool.
	Variables which could be written by CoolTester remote tool : coolTesterCmd, coolTesterParam, *(gtesTestsList[x].test_params).
    Variables which shall be read by CoolTester remote tool : gtesVersion, gtesMainStatus, gtesTestStatus, gtesCountAvailableTests, *(gtesTestsList	 [x].test_results).
	</comment>
	
	

	<UINT32 name="gtesVersion" >
		<comment>
		This attribute must store GTES_VERSION : the magic number of Granite Tester Embedded Stuff and its embedded version.
		</comment>
	</UINT32>
	
		
	<instance type="GTES_MAIN_STATUS" name="gtesMainStatus"/>
	
	<instance type="GTES_REGISTER_ERR" name="gtesRegisterErr"/>
		
		
	<instance type="GTES_TEST_STATUS" name="gtesTestStatus"/>

		
	<instance type="GTES_TEST_ERR" name="gtesTestErr"/>
	
		
	<instance type="GTES_REMOTE_CMD" name="coolTesterCmd"/>
	
	<UINT32 name="coolTesterParam" >
		<comment>
		This attribute is written by CoolTester tool : parameter related to a specific GTES_REMOTE_CMD_T.
		</comment>
	</UINT32>
	
		
	<ptr type="GTES_STACK_STATUS" name="gtesStackStatus">
		<comment>
		Pointer to the stack status structure.
		</comment>	
	</ptr>	
					
	
	<ptr type="GTES_TESTS_LIST" name="gtesTestsList">
		<comment>
		Pointer to the test table.
		</comment>	
	</ptr>	
	

</typedef>

<cjoker>


EXPORT PROTECTED UINT8 g_gtesMbx;

/// Generic type use to define a gtes test function.
typedef GTES_TEST_ERR_T (*GTES_TEST_FUNCTION_PTR_T)(VOID);

////////////////////////////////////////////////////////////////////////////////
// gtes_Init
////////////////////////////////////////////////////////////////////////////////
/// This function must be called before using GTES.
/// It registers gtes test module in hal map engine, reset the tests array 
/// #g_gtesTestslist, create gtes mailBox and gtesTask.
/// Set the gtesMainStatus of the remote structure as #GTES_MAIN_STATUS_READY.
///
/// @return GTES mailBox identifier.
////////////////////////////////////////////////////////////////////////////////
UINT8 gtes_Init(VOID);

////////////////////////////////////////////////////////////////////////////////
// gtes_ResetTestsTab
////////////////////////////////////////////////////////////////////////////////
/// This function reset all unit tests in the global array gtesTestsList 
/// defined in gtes.c. It must be called first before registering any tests.
/// This function is called in the #gtes_Init one.
/// This function could be helpful when you want to destroy the previous
/// test registration you did. ( To register new tests for instance...)
////////////////////////////////////////////////////////////////////////////////
PUBLIC VOID gtes_ResetTestsTab(VOID);

	
////////////////////////////////////////////////////////////////////////////////
// gtes_RegisterNewTest
////////////////////////////////////////////////////////////////////////////////
/// This function allows to register a new test in gtesTestsList array. Thus, 
/// the test could be detected/executed by CoolTester.
/// If an error occured during the registration process,
/// a GTES_MAIN_STATUS_REGISTER_ERR flag will be raised in gtesMainStatus field
/// of the remote structure.
/// Moreover, the error will be specified in the gtesRegisterErr field of 
/// the remote Structure.
///
///
/// @param myTestId Unique test IDentifier, defined in #gtes_config.h.
///        If not, will raise a #GTES_REGISTER_ERR_TEST_UNKNOWN_ID.
/// @param myTestFunction Pointer to the main test function of the registered 
///        test. This is this function which will be executed when CoolTester 
///        ask to start a test which identifier is myTestId.
///        If NULL, will raise a #GTES_REGISTER_ERR_TEST_FUNCTION_NOT_PRECISED. 
/// @param myTestParams Pointer to the registered test parameters structure.
/// @param myTestResults Pointer to the registered test results structure.
///
/// @return #GTES_ADD_NEW_TEST_STATUS_T
////////////////////////////////////////////////////////////////////////////////
PUBLIC GTES_ADD_NEW_TEST_STATUS_T gtes_RegisterNewTest(
					GTES_TEST_ID_T myTestId,					
					VOID* myTestFunction,
					VOID* myTestParams, 
					VOID* myTestResults);

////////////////////////////////////////////////////////////////////////////////
// gtes_PollProcess
////////////////////////////////////////////////////////////////////////////////
/// This function read coolTesterCmd field of #g_gtesRemoteStructure and execute
/// the Cmd if any. This function shall be called periodically as a function
/// timer one. This method is called by gtes task.
////////////////////////////////////////////////////////////////////////////////
PUBLIC VOID gtes_PollProcess(VOID);

////////////////////////////////////////////////////////////////////////////////
// gtes_RegisterMsgFromAPI
////////////////////////////////////////////////////////////////////////////////
/// This function register last API msg received in #g_gtesRemoteStructure.
////////////////////////////////////////////////////////////////////////////////
PUBLIC VOID gtes_RegisterMsgFromAPI(VOID* msg);

////////////////////////////////////////////////////////////////////////////////
// gtes_RegisterTI
////////////////////////////////////////////////////////////////////////////////
/// This function register last Transaction IDentifier.
////////////////////////////////////////////////////////////////////////////////
PUBLIC VOID gtes_RegisterTI(UINT8 ti);

////////////////////////////////////////////////////////////////////////////////
// gtes_GetTI
////////////////////////////////////////////////////////////////////////////////
/// Return the current Transaction IDentifier.
////////////////////////////////////////////////////////////////////////////////
PUBLIC UINT8 gtes_GetTI(VOID);

////////////////////////////////////////////////////////////////////////////////
// gtes_RegisterCCerror
////////////////////////////////////////////////////////////////////////////////
/// This function register last CC error.
////////////////////////////////////////////////////////////////////////////////
PUBLIC VOID gtes_RegisterCCerror(UINT8 error);

////////////////////////////////////////////////////////////////////////////////
// gtes_GetCallStatus
////////////////////////////////////////////////////////////////////////////////
/// Return the call status.
////////////////////////////////////////////////////////////////////////////////
PUBLIC GTES_CALL_STATUS_T gtes_GetCallStatus(VOID);





</cjoker>



</archive>








<archive relative='../../../platform_test/hal/gtes/include/gtes_test_board_auto_uart.xmd'  asm="no">


  <comment>
    Description of your test.
  </comment>

  <include load="no" file="cs_types.h"/>
  <include load="no" file="gtes_config.h"/>
  <include load="no" file="gtes_m.h"/>

  <typedef name="GTES_TEST_PARAMS_BOARD_AUTO_UART" >
    <BOOL name="start">
      If start is true the test start
      If start is false the test stop
    </BOOL>
  </typedef>

  <typedef name="GTES_TEST_RESULTS_BOARD_AUTO_UART" >
  </typedef>

  <typedef name="gtes_test_board_auto_uart_globals" rubyconstants="yes">
  </typedef>

  <cjoker>
    ////////////////////////////////////////////////////////////////////////////////
    // gtes_TestFunctionBoard_auto_uart
    ////////////////////////////////////////////////////////////////////////////////
    /// Describe your test here.
    ////////////////////////////////////////////////////////////////////////////////
    
    PUBLIC GTES_TEST_ERR_T gtes_TestFunctionBoard_auto_uart(VOID);   

    ////////////////////////////////////////////////////////////////////////////////
    // gtes_RegisterBoard_auto_uart
    ////////////////////////////////////////////////////////////////////////////////
    /// This function register the test in the global array gtesTestsList defined
    /// in gtes.c
    ////////////////////////////////////////////////////////////////////////////////
    
    PUBLIC GTES_ADD_NEW_TEST_STATUS_T gtes_RegisterBoard_auto_uart(VOID);    
  </cjoker>


</archive>


<archive relative='../../../platform_test/hal/gtes/include/gtes_test_board_manual_gpo_clk.xmd'  asm="no">


  <comment>
    GP01, GPO2, DBGCLK test
  </comment>

  <include load="no" file="cs_types.h"/>
  <include load="no" file="gtes_config.h"/>
  <include load="no" file="gtes_m.h"/>

  <typedef name="GTES_TEST_PARAMS_BOARD_MANUAL_GPO_CLK" >
  </typedef>

  <typedef name="GTES_TEST_RESULTS_BOARD_MANUAL_GPO_CLK" >
  </typedef>

  <typedef name="gtes_test_board_manual_gpo_clk_globals" rubyconstants="yes">
  </typedef>

  <cjoker>
    ////////////////////////////////////////////////////////////////////////////////
    // gtes_TestFunctionBoard_Manual_Gpo_clk
    ////////////////////////////////////////////////////////////////////////////////
    /// Describe your test here.
    ////////////////////////////////////////////////////////////////////////////////
    
    PUBLIC GTES_TEST_ERR_T gtes_TestFunctionBoard_Manual_Gpo_clk(VOID);   

    ////////////////////////////////////////////////////////////////////////////////
    // gtes_RegisterBoard_Manual_Gpo_clk
    ////////////////////////////////////////////////////////////////////////////////
    /// This function register the test in the global array gtesTestsList defined
    /// in gtes.c
    ////////////////////////////////////////////////////////////////////////////////
    
    PUBLIC GTES_ADD_NEW_TEST_STATUS_T gtes_RegisterBoard_Manual_Gpo_clk(VOID);    
  </cjoker>


</archive>


<archive relative='../../../platform_test/hal/gtes/include/gtes_test_board_manual_rf.xmd'  asm="no">


  <comment>
    Description of your test.
  </comment>

  <include load="no" file="cs_types.h"/>
  <include load="no" file="gtes_config.h"/>
  <include load="no" file="gtes_m.h"/>

  <typedef name="GTES_TEST_PARAMS_BOARD_MANUAL_RF" >
  </typedef>

  <typedef name="GTES_TEST_RESULTS_BOARD_MANUAL_RF" >
    <INT32 name="mean_IA" />
    <INT32 name="mean_IB" />
    <INT32 name="mean_IC" />
    <INT32 name="mean_ID" />
    <INT32 name="mean_QA" />
    <INT32 name="mean_QB" />
    <INT32 name="mean_QC" />
    <INT32 name="mean_QD" />
    <INT32 name="var_IA" />
    <INT32 name="var_IB" />
    <INT32 name="var_IC" />
    <INT32 name="var_ID" />
    <INT32 name="var_QA" />
    <INT32 name="var_QB" />
    <INT32 name="var_QC" />
    <INT32 name="var_QD" />
  </typedef>

  <typedef name="gtes_test_board_manual_rf_globals" rubyconstants="yes">
  </typedef>

  <cjoker>
    ////////////////////////////////////////////////////////////////////////////////
    // gtes_TestFunctionBoard_Manual_Rf
    ////////////////////////////////////////////////////////////////////////////////
    /// Describe your test here.
    ////////////////////////////////////////////////////////////////////////////////
    
    PUBLIC GTES_TEST_ERR_T gtes_TestFunctionBoard_Manual_Rf(VOID);   

    ////////////////////////////////////////////////////////////////////////////////
    // gtes_RegisterBoard_Manual_Rf
    ////////////////////////////////////////////////////////////////////////////////
    /// This function register the test in the global array gtesTestsList defined
    /// in gtes.c
    ////////////////////////////////////////////////////////////////////////////////
    
    PUBLIC GTES_ADD_NEW_TEST_STATUS_T gtes_RegisterBoard_Manual_Rf(VOID);    
  </cjoker>


</archive>


<archive relative='../../../platform_test/hal/gtes/include/gtes_test_board_manual_key.xmd'  asm="no">


  <comment>
    Keypad test
  </comment>

  <include load="no" file="cs_types.h"/>
  <include load="no" file="gtes_config.h"/>
  <include load="no" file="gtes_m.h"/>

  <typedef name="GTES_TEST_PARAMS_BOARD_MANUAL_KEY" >
  </typedef>

  <enum name="GTES_TEST_BOARD_MANUAL_KEY_RES">
    <entry name="GTES_TEST_BOARD_MANUAL_KEY_OK">
      <comment> 
        Test success
      </comment>
    </entry>
    <entry name="GTES_TEST_BOARD_MANUAL_KEY_KO">
      <comment> 
        Test failed
      </comment>
    </entry>
  </enum>


  <typedef name="GTES_TEST_RESULTS_BOARD_MANUAL_KEY" >
    <instance name="result" type="GTES_TEST_BOARD_MANUAL_KEY_RES" />
  </typedef>

  <typedef name="gtes_test_board_manual_key_globals" rubyconstants="yes">
  </typedef>

  <cjoker>
    ////////////////////////////////////////////////////////////////////////////////
    // gtes_TestFunctionBoard_Manual_Key
    ////////////////////////////////////////////////////////////////////////////////
    /// Describe your test here.
    ////////////////////////////////////////////////////////////////////////////////
    
    PUBLIC GTES_TEST_ERR_T gtes_TestFunctionBoard_Manual_Key(VOID);   

    ////////////////////////////////////////////////////////////////////////////////
    // gtes_RegisterBoard_Manual_Key
    ////////////////////////////////////////////////////////////////////////////////
    /// This function register the test in the global array gtesTestsList defined
    /// in gtes.c
    ////////////////////////////////////////////////////////////////////////////////
    
    PUBLIC GTES_ADD_NEW_TEST_STATUS_T gtes_RegisterBoard_Manual_Key(VOID);    
  </cjoker>


</archive>


<archive relative='../../../platform_test/hal/gtes/include/gtes_test_board_manual_audio.xmd'  asm="no">


  <comment>
    Audio manual test
  </comment>

  <include load="no" file="cs_types.h"/>
  <include load="no" file="gtes_config.h"/>
  <include load="no" file="gtes_m.h"/>

  <enum name="GTES_TEST_BOARD_MANUAL_AUDIO_ACTION">
    <entry name="GTES_TEST_BOARD_MANUAL_AUDIO_ACTION_STOP" value="0">
      <comment> 
        Stop audio
      </comment>
    </entry>
    <entry name="GTES_TEST_BOARD_MANUAL_AUDIO_ACTION_PLAY">
      <comment> 
        Play sample
      </comment>
    </entry>
    <entry name="GTES_TEST_BOARD_MANUAL_AUDIO_ACTION_TONE">
      <comment> 
        Play a tone
      </comment>
    </entry>
    <entry name="GTES_TEST_BOARD_MANUAL_AUDIO_ACTION_LOOPBACK">
      <comment> 
        Loopback mode
      </comment>
    </entry>
  </enum>

  <typedef name="GTES_TEST_PARAMS_BOARD_MANUAL_AUDIO" >
    <instance type="GTES_TEST_BOARD_MANUAL_AUDIO_ACTION" name="action">
      <comment>
        Audio action
      </comment>
    </instance>
  </typedef>

  <typedef name="GTES_TEST_RESULTS_BOARD_MANUAL_AUDIO" >
  </typedef>

  <typedef name="gtes_test_board_manual_audio_globals" rubyconstants="yes">
  </typedef>

  <cjoker>
    ////////////////////////////////////////////////////////////////////////////////
    // gtes_TestFunctionBoard_Manual_Audio
    ////////////////////////////////////////////////////////////////////////////////
    /// Describe your test here.
    ////////////////////////////////////////////////////////////////////////////////
    
    PUBLIC GTES_TEST_ERR_T gtes_TestFunctionBoard_Manual_Audio(VOID);    

    ////////////////////////////////////////////////////////////////////////////////
    // gtes_RegisterBoard_Manual_Audio
    ////////////////////////////////////////////////////////////////////////////////
    /// This function register the test in the global array gtesTestsList defined
    /// in gtes.c
    ////////////////////////////////////////////////////////////////////////////////
    
    PUBLIC GTES_ADD_NEW_TEST_STATUS_T gtes_RegisterBoard_Manual_Audio(VOID); 
  </cjoker>


</archive>


<archive relative='../../../platform_test/hal/gtes/include/gtes_test_board_auto_i2c_maxim.xmd'  asm="no">


<comment>
I2C auto test
</comment>

<include load="no" file="cs_types.h"/>
<include load="no" file="gtes_config.h"/>
<include load="no" file="gtes_m.h"/>

<enum name="GTES_TEST_BOARD_AUTO_I2C_MAXIM_RES">
  <entry name="GTES_TEST_BOARD_AUTO_I2C_MAXIM_KO" value="0">
    <comment> 
      Test failed
    </comment>
  </entry>
  <entry name="GTES_TEST_BOARD_AUTO_I2C_MAXIM_OK">
    <comment> 
      Test success
    </comment>
  </entry>
</enum>


<typedef name="GTES_TEST_PARAMS_BOARD_AUTO_I2C_MAXIM" >
</typedef>

<typedef name="GTES_TEST_RESULTS_BOARD_AUTO_I2C_MAXIM" >
  <instance type="GTES_TEST_BOARD_AUTO_I2C_MAXIM_RES" name="result">
    <comment>
      Result of I2C Test
    </comment>
  </instance>
</typedef>

    <typedef name="gtes_test_board_auto_i2c_maxim_globals" rubyconstants="yes">
    </typedef>

<cjoker>
////////////////////////////////////////////////////////////////////////////////
// gtes_TestFunctionI2c
////////////////////////////////////////////////////////////////////////////////
/// Describe your test here.
////////////////////////////////////////////////////////////////////////////////
	
PUBLIC GTES_TEST_ERR_T gtes_TestFunctionBoard_Auto_I2c_Maxim(VOID);	

////////////////////////////////////////////////////////////////////////////////
// gtes_RegisterI2c
////////////////////////////////////////////////////////////////////////////////
/// This function register the test in the global array gtesTestsList defined
/// in gtes.c
////////////////////////////////////////////////////////////////////////////////
	
PUBLIC GTES_ADD_NEW_TEST_STATUS_T gtes_RegisterBoard_Auto_I2c_Maxim(VOID);	
</cjoker>


</archive>


<archive relative='../../../platform_test/hal/gtes/include/gtes_test_board_auto_pll.xmd'  asm="no">



<comment>
  PLL lock test
</comment>

<include load="no" file="cs_types.h"/>
<include load="no" file="gtes_config.h"/>
<include load="no" file="gtes_m.h"/>

<typedef name="GTES_TEST_PARAMS_BOARD_AUTO_PLL" >
</typedef>

<typedef name="GTES_TEST_RESULTS_BOARD_AUTO_PLL" >
  <UINT32 name="time">
    <comment>
      Time of PLL lock (1 unit = 10ms), if PLL not lock the value is 0xFFFFFFFF
    </comment>
  </UINT32>
</typedef>

<cjoker>
////////////////////////////////////////////////////////////////////////////////
// gtes_TestFunctionBoard_Auto_Pll
////////////////////////////////////////////////////////////////////////////////
/// Describe your test here.
////////////////////////////////////////////////////////////////////////////////
	
PUBLIC GTES_TEST_ERR_T gtes_TestFunctionBoard_Auto_Pll(VOID);	

////////////////////////////////////////////////////////////////////////////////
// gtes_RegisterBoard_Auto_Pll
////////////////////////////////////////////////////////////////////////////////
/// This function register the test in the global array gtesTestsList defined
/// in gtes.c
////////////////////////////////////////////////////////////////////////////////
	
PUBLIC GTES_ADD_NEW_TEST_STATUS_T gtes_RegisterBoard_Auto_Pll(VOID);	
</cjoker>


</archive>


<archive relative='../../../platform_test/hal/gtes/include/gtes_test_proto_auto_call.xmd'  asm="no">


<comment>
This header is a call test.
Test id and the errors it could rise are stored in gtes_config.h header.
</comment>

<include load="no" file="cs_types.h"/>
<include load="no" file="gtes_config.h"/>
<include load="no" file="gtes_m.h"/>

<typedef name="GTES_TEST_PARAMS_PROTO_AUTO_CALL" >
	
	<UINT32 name="start" >
		<comment>
		Start a call if 1, end the call if 0.
		</comment>
	</UINT32>
		
	<UINT8 name="callNumber" count="20">
		<comment>
		This stores the call Number.
		</comment>
	</UINT8>
		
</typedef>

<typedef name="GTES_TEST_RESULTS_PROTO_AUTO_CALL" >
	<UINT32 name="testResult" >
		<comment>
		1 if the test is successful, 0 otherwise.
		</comment>
	</UINT32>
	
	
</typedef>

<cjoker>
////////////////////////////////////////////////////////////////////////////////
// gtes_TestFunctionProto_Auto_Call
////////////////////////////////////////////////////////////////////////////////
/// This function start a proto_auto_call.
////////////////////////////////////////////////////////////////////////////////
	
PUBLIC GTES_TEST_ERR_T gtes_TestFunctionProto_Auto_Call(VOID);		

////////////////////////////////////////////////////////////////////////////////
// gtes_RegisterProto_Auto_Call
////////////////////////////////////////////////////////////////////////////////
/// This function register the test in the global array gtesTestsList defined
/// in gtes.c.
////////////////////////////////////////////////////////////////////////////////
	
PUBLIC GTES_ADD_NEW_TEST_STATUS_T gtes_RegisterProto_Auto_Call(VOID);	
</cjoker>

</archive>


<archive relative='../../../platform_test/hal/gtes/include/gtes_test_proto_auto_attach.xmd'  asm="no">


<comment>
This header is an attachement test.
Test id and the errors it could rise are stored in gtes_config.h header.
</comment>

<include load="no" file="cs_types.h"/>
<include load="no" file="gtes_config.h"/>
<include load="no" file="gtes_m.h"/>

<typedef name="GTES_TEST_PARAMS_PROTO_AUTO_ATTACH" >
	
	<UINT32 name="start" >
		<comment>
		Start a call if 1, end the call if 0.
		</comment>
	</UINT32>
		
</typedef>

<typedef name="GTES_TEST_RESULTS_PROTO_AUTO_ATTACH" >
	<UINT32 name="testResult" >
		<comment>
		1 if the test is successful, 0 otherwise.
		</comment>
	</UINT32>
	
	
</typedef>

<cjoker>
////////////////////////////////////////////////////////////////////////////////
// gtes_TestFunctionProto_Auto_Attach
////////////////////////////////////////////////////////////////////////////////
/// This function start a proto_auto_Attach.
////////////////////////////////////////////////////////////////////////////////
	
PUBLIC GTES_TEST_ERR_T gtes_TestFunctionProto_Auto_Attach(VOID);		

////////////////////////////////////////////////////////////////////////////////
// gtes_RegisterProto_Auto_Attach
////////////////////////////////////////////////////////////////////////////////
/// This function register the test in the global array gtesTestsList defined
/// in gtes.c.
////////////////////////////////////////////////////////////////////////////////
	
PUBLIC GTES_ADD_NEW_TEST_STATUS_T gtes_RegisterProto_Auto_Attach(VOID);	
</cjoker>

</archive>


<archive relative='../../../platform_test/hal/gtes/include/gtes_test_board_manual_helloWorld.xmd'  asm="no">


<comment>
This header is a demo one with a Hello World test.
Test id and the errors it could rise are stored in gtes_config.h header.
</comment>

<include load="no" file="cs_types.h"/>
<include load="no" file="gtes_config.h"/>
<include load="no" file="gtes_m.h"/>

<typedef name="GTES_TEST_PARAMS_BOARD_MANUAL_HELLOWORLD" >
	
	<UINT32 name="numberOfprintedHelloWorld" >
		<comment>
		This stores the number of "Hello Worlds which will be printed.
		</comment>
	</UINT32>
	
	<UINT32 name="anOtherParameter" >
		<comment>
		Unused.
		</comment>
	</UINT32>
   
</typedef>

<typedef name="GTES_TEST_RESULTS_BOARD_MANUAL_HELLOWORLD" >
	<UINT32 name="testResult" >
		<comment>
		1 if the test is successful, 0 otherwise.
		</comment>
	</UINT32>	
</typedef>

<cjoker>
////////////////////////////////////////////////////////////////////////////////
// gtes_TestFunctionBoard_Manual_HelloWorld
////////////////////////////////////////////////////////////////////////////////
/// This function is the Board_Manual_Hello World test one.
////////////////////////////////////////////////////////////////////////////////
	
PUBLIC GTES_TEST_ERR_T gtes_TestFunctionBoard_Manual_HelloWorld(VOID);		

////////////////////////////////////////////////////////////////////////////////
// gtes_RegisterBoard_Manual_HelloWorld
////////////////////////////////////////////////////////////////////////////////
/// This function register the test in the global array gtesTestsList defined
/// in gtes.c.
////////////////////////////////////////////////////////////////////////////////
	
PUBLIC GTES_ADD_NEW_TEST_STATUS_T gtes_RegisterBoard_Manual_HelloWorld(VOID);	
</cjoker>

</archive>


<archive relative='../../../platform_test/hal/gtes/include/gtes_test_hal_auto_uart.xmd'  asm="no">


    
    <comment>
    Auto Test UART
    </comment>
    
    <include load="no" file="cs_types.h"/>
    <include file="gtes_config.xmd"/>
    <include file="gtes_m.xmd"/>
   
    <typedef name="GTES_TEST_PARAMS_HAL_AUTO_UART" >
      
    <UINT32 name="BitRate1" >
		<comment>
		Primary Bitrate of UART port.
		</comment>
	</UINT32>
      
    <UINT32 name="BitRate2" >
		<comment>
		 Secondary Bitrate of UART port
		</comment>
	</UINT32>
      
    <BOOL name="Enable_BigPacket_Test">
        <comment>
            Enable Test: Behavior with Big Data
        </comment>
        </BOOL>
        <BOOL name="Enable_CtlFlows_Test">
        <comment>
            Enable Test: Control Flows
        </comment>
        </BOOL>
        <BOOL name="Enable_Data_Transmit_Parameter_Test">
        <comment>
            Enable Test: Data Transmit Paramater 7Bits, 2BitRate
        </comment>
        </BOOL>
    </typedef>
    
    <enum name="GTES_TEST_HAL_AUTO_UART_RES">
      <entry name="GTES_TEST_HAL_AUTO_UART_SHIP" value="0">
        <comment> 
          Test not executed
        </comment>
      </entry>
      <entry name="GTES_TEST_HAL_AUTO_UART_OK">
        <comment> 
          Test success
        </comment>
      </entry>
      <entry name="GTES_TEST_HAL_AUTO_UART_KO">
        <comment> 
          Test failed
        </comment>
      </entry>
    </enum>
    
    <typedef name="GTES_TEST_RESULTS_HAL_AUTO_UART" >
      
      <instance type="GTES_TEST_HAL_AUTO_UART_RES" name="Mode_Poll">
        <comment>
          Result of UART test on mode poll
        </comment>
      </instance>
      <instance type="GTES_TEST_HAL_AUTO_UART_RES" name="Mode_Poll_Irq">
        <comment>
          Result of UART test on mode poll et IRQ
        </comment>
      </instance>
      <instance type="GTES_TEST_HAL_AUTO_UART_RES" name="Mode_Dma">
        <comment>
          Result of UART test on mode DMA
        </comment>
      </instance>
      <instance type="GTES_TEST_HAL_AUTO_UART_RES" name="Mode_Dma_Irq">
        <comment>
          Result of UART test on mode DMA et IRQ
        </comment>
      </instance>
      
      <instance type="GTES_TEST_HAL_AUTO_UART_RES" name="Fifo_OVR">
        <comment>
          Result of UART test on FIFO Overflow
        </comment>
      </instance>
      <instance type="GTES_TEST_HAL_AUTO_UART_RES" name="BigPacket">
        <comment>
          Result of UART test on BigPacket with DMA mode
        </comment>
      </instance>
      
      <instance type="GTES_TEST_HAL_AUTO_UART_RES" name="CtlFlows">
        <comment>
          Result of UART test on flows control
        </comment>
      </instance>
      
      <instance type="GTES_TEST_HAL_AUTO_UART_RES" name="Mode7bits">
        <comment>
          Result of UART test on 7bits data mode
        </comment>
      </instance>
      <instance type="GTES_TEST_HAL_AUTO_UART_RES" name="Bitrate">
        <comment>
          Result of UART test on 2 bitrate 
        </comment>
      </instance>
    </typedef>

    <typedef name="gtes_test_hal_auto_uart_globals" rubyconstants="yes">
    </typedef>

    
    <cjoker>
      ////////////////////////////////////////////////////////////////////////////////
      // gtes_TestFunctionHal_Auto_Uart
      ////////////////////////////////////////////////////////////////////////////////
      /// Describe your test here.
      ////////////////////////////////////////////////////////////////////////////////
      
      PUBLIC GTES_TEST_ERR_T gtes_TestFunctionHal_Auto_Uart(VOID);	
    
    ////////////////////////////////////////////////////////////////////////////////
    // gtes_RegisterHal_Auto_Uart
    ////////////////////////////////////////////////////////////////////////////////
    /// This function register the test in the global array gtesTestsList defined
    /// in gtes.c
    ////////////////////////////////////////////////////////////////////////////////
    	
    PUBLIC GTES_ADD_NEW_TEST_STATUS_T gtes_RegisterHal_Auto_Uart(VOID);	
    </cjoker>


</archive>


<archive relative='../../../platform_test/hal/gtes/include/gtes_test_board_auto_sim.xmd'  asm="no">


  
  <comment>
    Auto Test Sim 
    ATR-> EPPS-> Select
  </comment>

  <include load="no" file="cs_types.h"/>
  <include load="no" file="gtes_config.h"/>
  <include load="no" file="gtes_m.h"/>

  <typedef name="GTES_TEST_PARAMS_BOARD_AUTO_SIM" >
  </typedef>

  <enum name="GTES_TEST_BOARD_AUTO_SIM_RES">
    <entry name="GTES_TEST_BOARD_AUTO_SIM_SHIP" value="0">
      <comment> 
        Test not executed
      </comment>
    </entry>
    <entry name="GTES_TEST_BOARD_AUTO_SIM_OK">
      <comment> 
        Test success
      </comment>
    </entry>
    <entry name="GTES_TEST_BOARD_AUTO_SIM_KO">
      <comment> 
        Test failed
      </comment>
    </entry>
  </enum>

  <typedef name="GTES_TEST_RESULTS_BOARD_AUTO_SIM">
      <instance name="ATR_Sim_Class_C" type="GTES_TEST_BOARD_AUTO_SIM_RES">
        <comment>
          Test if sim card is class C
        </comment>
      </instance>
      <instance name="ATR_Sim_Class_B" type="GTES_TEST_BOARD_AUTO_SIM_RES">
        <comment>
          Test if sim card is class B
        </comment>
      </instance>
      <instance name="ATR_Sim_Class_A" type="GTES_TEST_BOARD_AUTO_SIM_RES">
        <comment>
          Test if sim card is class A
        </comment>
      </instance>
      <instance name="EPPS"            type="GTES_TEST_BOARD_AUTO_SIM_RES">
        <comment>
          EPPS cmd: Switch clock
        </comment>
      </instance>
      <instance name="Select"          type="GTES_TEST_BOARD_AUTO_SIM_RES">
        <comment>
          Select cmd
        </comment>
      </instance>
  </typedef>

  <typedef name="gtes_test_board_auto_sim_globals" rubyconstants="yes">
  </typedef>

  <cjoker>
    ////////////////////////////////////////////////////////////////////////////////
    // gtes_TestFunctionBoard_Auto_Sim
    ////////////////////////////////////////////////////////////////////////////////
    /// Describe your test here.
    ////////////////////////////////////////////////////////////////////////////////
    
    PUBLIC GTES_TEST_ERR_T gtes_TestFunctionBoard_Auto_Sim(VOID);  

    ////////////////////////////////////////////////////////////////////////////////
    // gtes_RegisterBoard_Auto_Sim
    ////////////////////////////////////////////////////////////////////////////////
    /// This function register the test in the global array gtesTestsList defined
    /// in gtes.c
    ////////////////////////////////////////////////////////////////////////////////
    
    PUBLIC GTES_ADD_NEW_TEST_STATUS_T gtes_RegisterBoard_Auto_Sim(VOID);   
  </cjoker>


</archive>


<archive relative='../../../platform_test/hal/gtes/include/gtes_test_board_auto_mem.xmd'  asm="no">


  
  <comment>
    Description of your test.
  </comment>

  <include load="no" file="cs_types.h"/>
  <include load="no" file="gtes_config.h"/>
  <include load="no" file="gtes_m.h"/>

  <enum name="GTES_TEST_BOARD_AUTO_MEM_RES">
    <entry name="GTES_TEST_BOARD_AUTO_MEM_KO" value="0">
      <comment> 
        Test failed
      </comment>
    </entry>
    <entry name="GTES_TEST_BOARD_AUTO_MEM_OK">
      <comment> 
        Test success
      </comment>
    </entry>
  </enum>

  <typedef name="GTES_TEST_PARAMS_BOARD_AUTO_MEM" >
    <UINT32 name="addr_begin">
      <comment> 
        Begin memory address interval
      </comment>      
    </UINT32>
    <UINT32 name="addr_end">
      <comment> 
        End memory address interval
      </comment>      
    </UINT32>
  </typedef>

  <typedef name="GTES_TEST_RESULTS_BOARD_AUTO_MEM">
    <instance name="mem_result" type="GTES_TEST_BOARD_AUTO_MEM_RES">
      <comment> 
        Result of memtest
      </comment>            
    </instance>
    <UINT32 name="addr">
      <comment> 
        Memory address of error 
      </comment>      
    </UINT32>
  </typedef>

  <typedef name="gtes_test_board_auto_mem_globals" rubyconstants="yes">
  </typedef>

  <cjoker>
    ////////////////////////////////////////////////////////////////////////////////
    // gtes_TestFunctionBoard_Auto_Mem
    ////////////////////////////////////////////////////////////////////////////////
    /// Describe your test here.
    ////////////////////////////////////////////////////////////////////////////////
    
    PUBLIC GTES_TEST_ERR_T gtes_TestFunctionBoard_Auto_Mem(VOID);  

    ////////////////////////////////////////////////////////////////////////////////
    // gtes_RegisterBoard_Auto_Mem
    ////////////////////////////////////////////////////////////////////////////////
    /// This function register the test in the global array gtesTestsList defined
    /// in gtes.c
    ////////////////////////////////////////////////////////////////////////////////
    
    PUBLIC GTES_ADD_NEW_TEST_STATUS_T gtes_RegisterBoard_Auto_Mem(VOID);   
  </cjoker>


</archive>

<archive relative='../../../platform_test/hal/gtes/include/gtes_map.xmd'  asm="no">

    <comment>
        This file contains the portion of the GTES's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool).
    </comment>

    <include file="gtes_m.xmd"/>
    <include file="gtes_test_board_auto_uart.xmd"/>
    <include file="gtes_test_board_manual_gpo_clk.xmd"/>
    <include file="gtes_test_board_manual_rf.xmd"/>
    <include file="gtes_test_board_manual_key.xmd"/>
    <include file="gtes_test_board_manual_audio.xmd"/>
    <include file="gtes_test_board_auto_i2c_maxim.xmd"/>
    <include file="gtes_test_board_auto_pll.xmd"/>
    <include file="gtes_test_proto_auto_call.xmd"/>  
    <include file="gtes_test_proto_auto_attach.xmd"/>  
    <include file="gtes_test_board_manual_helloWorld.xmd"/>
    <include file="gtes_test_hal_auto_uart.xmd"/>
    <include file="gtes_test_board_auto_sim.xmd"/> 
    <include file="gtes_test_board_auto_mem.xmd"/>
            
    <alias name='GTES_MAP_ACCESS_T'>
        <instance name='g_gtesRemoteStructure' type='GTES_REMOTE_STRUCTURE'></instance>
    </alias>


</archive>

<archive relative='../../../platform/chip/pal/include/pal_map.xmd'  asm="no">


    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    


    


    
   <typedef name="PAL_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        
   </typedef>

<cjoker>

// =============================================================================
// pal_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID pal_RegisterYourself(VOID);

</cjoker>

</archive>

<archive relative='../../../platform/chip/bcpu/spal/include/spal_map.xmd'  asm="no">

    <comment>
        This file contains the portion of SPAL's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool).
    </comment>

<include load="no" file="cs_types.h"/>

    <typedef  name="SPAL_PROFILE_CONTROL">
        <comment> Profile control for SPAL, SPC, and SPP.
        </comment>

        <uint32     name="config" display="hex">
            <bits   name="spal" pos="0" access="rw" rst="0">
                <comment>
                    Enable profiling on SPAL.
                </comment>
            </bits>
            <bits   name="spc" pos="1" access="rw" rst="0">
                <comment>
                    Enable profiling on SPC.
                </comment>
            </bits>
            <bits   name="spp" pos="2" access="rw" rst="0">
                <comment>
                    Enable profiling on SPP.
                </comment>
            </bits>
            <bits   name="bb_irq" pos="3" access="rw" rst="0">
                <comment>
                    Enable profiling on BCPU IRQ.
                </comment>
            </bits>
            <bits   name="bb_rx_win" pos="4" access="rw" rst="0">
                <comment>
                    Enable profiling on the type of the BB Rx windows.
                </comment>
            </bits>
            <bits   name="bb_ifc2_sym_cnt" pos="5" access="rw" rst="0">
                <comment>
                    Enable profiling on the BB IFC2 symbol counter each time an interrupt occurs.
                </comment>
            </bits>
        </uint32>

        <ptr type="uint32" name="buffer_start" display="hex">
            <comment>
                The start address of the buffer to save the profile data.
            </comment>
        </ptr>

         <uint16     name="buffer_pos" display="hex">
            <comment>
                Next available word index in the buffer to save the profile data. One word is 4 bytes.
            </comment>
        </uint16>

       <uint16     name="buffer_size" display="hex">
            <comment>
                The buffer size in number of words. One word is 4 bytes.
            </comment>
        </uint16>

    </typedef>

    
    <typedef name="SPAL_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of SPAL.
        </comment>
        <ptr type="SPAL_PROFILE_CONTROL" name="profileControlPtr"/>
    </typedef>

</archive>
<archive relative='../../../platform/chip/bcpu/spp/include/spp_gsm.xmd'  asm="no">


<comment>
This document describes the structures and functions provided to SPC for
both baseband processing and low-level HW control.
Includes the definition of the various buffers used by HW modules during Rx and Tx.
</comment>

<include load="no" file="cs_types.h"/>
<include load="no" file="gsm.h"/>

<var name='SPP_EGPRS_IR_MEM_LEN' value='52*1024'>
    <comment>size of the memory used for saving the IR blocks</comment>
</var>
<var name='SPP_EGPRS_IR_SNS' value='2048'>
    <comment>TBF modulo</comment>
</var>

<var name='SPP_EGPRS_TX_BURST_LEN' value='44'>
    <comment>Size in bytes of on one Tx burst buffer</comment>
</var>

<var name='MCS_1_TO_4_UNCOMPRESSED_BLOCK_LEN' value='372'>
    <comment>size in bytes of one received MCS1 to MCS4 block prior to decoding</comment>
</var>
<var name='MCS_5_TO_6_UNCOMPRESSED_BLOCK_LEN' value='1248'>
    <comment>size in bytes of one received MCS5 to MCS6 block prior to decoding</comment>
</var>
<var name='MCS_7_TO_9_UNCOMPRESSED_BLOCK_LEN' value='612'>
    <comment>size in bytes of one received MCS7 to MCS9 block prior to decoding</comment>
</var>

<var name='MCS_1_TO_4_BLOCK_LEN' value='MCS_1_TO_4_UNCOMPRESSED_BLOCK_LEN/2'>
    <comment>size in bytes of one compressed MCS1 to MCS4 block prior to decoding</comment>
</var>
<var name='MCS_5_TO_6_BLOCK_LEN' value='MCS_5_TO_6_UNCOMPRESSED_BLOCK_LEN/2'>
    <comment>size in bytes of one compressed MCS5 to MCS6 block prior to decoding</comment>
</var>
<var name='MCS_7_TO_9_BLOCK_LEN' value='MCS_7_TO_9_UNCOMPRESSED_BLOCK_LEN/2'>
    <comment>size in bytes of one compressed MCS7 to MCS9 block prior to decoding</comment>
</var>

<var name='MCS_1_TO_4_BUFFER_LEN' value='SPP_EGPRS_IR_MEM_LEN/MCS_1_TO_4_BLOCK_LEN'>
    <comment>number of compressed MCS1 to MCS4 blocks that can be stored in the IR memory</comment>
</var>
<var name='MCS_5_TO_6_BUFFER_LEN' value='SPP_EGPRS_IR_MEM_LEN/MCS_5_TO_6_BLOCK_LEN'>
    <comment>number of compressed MCS5 to MCS6 blocks that can be stored in the IR memory</comment>
</var>
<var name='MCS_7_TO_9_BUFFER_LEN' value='SPP_EGPRS_IR_MEM_LEN/MCS_7_TO_9_BLOCK_LEN'>
    <comment>number of compressed MCS7 to MCS9 blocks that can be stored in the IR memory</comment>
</var>

<var name='MCS_MAX_BLOCK_LEN' value='MCS_5_TO_6_BLOCK_LEN'>
    <comment>maximum size of one received blocks regardless of the mode</comment>
</var>
<var name='MCS_MAX_BUFFER_LEN' value='MCS_1_TO_4_BUFFER_LEN'>
    <comment>maximum number of blocks that can contain the IR memory regardless of the mode</comment>

</var>
<var name='SPP_EGPRS_SIZE_HEAD_DECODE_MCS789' value='29'>
    <comment>size of table that gives the correct coding scheme between MCS7, MCS8 and MCS9 after the header decoding</comment>

</var>
<var name='SPP_EGPRS_SIZE_HEAD_DECODE_MCS56' value='6'>
    <comment>size of table that gives the correct coding scheme between MCS5 and MCS6 after the header decoding</comment>

</var>
<var name='SPP_EGPRS_SIZE_HEAD_DECODE_MCS1234' value='13'>
    <comment>size of table that gives the correct coding scheme between MCS1, MCS2, MCS3 and MCS4 after the header decoding</comment>

</var>
<var name='TRAIN_SEQ_LENGTH' value='26'>
    <comment>length of the training sequence</comment>
</var>
<var name='HALF_BURST_LEN' value='61'>
    <comment>length of the training sequence</comment>
</var>
<var name='SPP_LSE_TAP_NB' value='8'>
    <comment>length of the training sequence</comment>
</var>
<var name='QP' value='10'>
    <comment>quality factor for the prefilter</comment>
</var>
<var name='MAIN_TAP_LEN' value='2'>
    <comment>number of taps used in the DDFSE treillis</comment>
</var>
<var name='ALL_TAP_LEN' value='6'>
    <comment>number of taps used in the DDFSE equalizer</comment>
</var>
<var name='STATE_LEN' value='8'>
    <comment>size of the treillis for 8PSK equal to 8**(MAIN_TAP_LEN-1)</comment>
</var>
<var name='HASH_LEN' value='64'>
    <comment>length of the HASH TABLE (for IR)</comment>
</var>

<enum name='SPP_EGPRS_HEADER_DATA_DISCRIMINATOR'>
    <comment>discrimination between header and data for Egprs</comment>
    <entry name='HEAD_COD'></entry>
    <entry name='DATA_COD'></entry>
</enum>

<var name='SUCCESS' value='0'>
    <comment>crc decoding successful</comment>
</var>

<var name='FAIL' value='1'>
    <comment>crc decoding failing</comment>
</var>


<typedef name='SPP_FCCH_RESULT'>
    <comment>FCCH Result</comment>

    <int16 name='FOf'></int16>
    <int16 name='TOf'></int16>
</typedef>

<typedef name='SPP_FCCH_PARAM'>
    <int32 name='Acc_Energy'></int32>
    <int32 name='Acc_Corr_I'></int32>
    <int32 name='Acc_Corr_Q'></int32>
    <uint32 name='Max_Abs_Corr'></uint32>
    <int32 name='Corr_order_I'></int32>
    <int32 name='Corr_order_Q'></int32>
    <int16 name='samples_left'></int16>
    <int16 name='max_index'></int16>
    <uint8 name='FCCH_detected'></uint8>
    <uint8 name='counter_high'></uint8>
    <uint8 name='counter_low'></uint8>
    <uint8 name='lastIT'></uint8>
    <uint8 name='debug'></uint8>
</typedef>

<typedef name='SPP_COMPLEX'>
    <int16 name='i'></int16>
    <int16 name='q'></int16>
</typedef>

<typedef name='SPP_SCH_RESULT'>
    <comment>SCH Result</comment>

    <uint16 name='Pwr'></uint16>
    <int16 name='Snr'></int16>
    <int16 name='FOf'></int16>
    <uint8 name='TOf'></uint8>
    <uint8 name='Data' count='4'></uint8>
</typedef>

<typedef name='SPP_N_BURST_RESULT'>
    <comment>Normal Burst Result</comment>

    <uint16 name='Pwr'></uint16>
    <int16 name='Snr'></int16>
    <int16 name='FOf'></int16>
    <uint8 name='TOf'></uint8>
    <instance name='Dco' type='SPP_COMPLEX'></instance>
</typedef>

<typedef name='SPP_N_BLOCK_RESULT'>
    <comment>Normal block Result</comment>

    <bool name='Bfi'></bool>
    <uint8 name='Cs'></uint8>
    <uint8 name='Voc_Sid'></uint8>
    <uint8 name='MeanBEP'></uint8>
    <uint8 name='CvBEP'></uint8>
    <uint16 name='BitError'></uint16>
    <uint16 name='BitTotal'></uint16>
</typedef>

<typedef name='SPP_HEADER_RESULT'>
    <comment>Header structure for Egprs</comment>

    <uint16 name='bsn' count='2'></uint16>
    <uint8 name='mcs'></uint8>
    <uint8 name='cps' count='2'></uint8>
    <uint8 name='spb'></uint8>
    <uint8 name='bfi'></uint8>
</typedef>

<typedef name='SPP_NB_VITAC'>
    <comment>Viterbi NB Equalisation Buffers Structure  SPAL_ISI is fixed, equal to 5</comment>

    <uint32 name='PathMetric' ckeywords='VOLATILE' count='2*16/2'>
        <comment>2068 bytes</comment>
    </uint32>
    <uint32 name='path_diff_bkw' ckeywords='VOLATILE' count='61*16/4'></uint32>
    <uint32 name='path_diff_fwd' ckeywords='VOLATILE' count='61*16/4'></uint32>
    <int16 name='Xcorr' ckeywords='VOLATILE' count='2*(8+5+1)'></int16>
</typedef>

<typedef name='SPP_SCH_VITAC'>
    <comment>Viterbi SCH Equalisation Buffers Structure</comment>

    <uint32 name='PathMetric' ckeywords='VOLATILE' count='2*16/2'>
        <comment>1643 bytes</comment>
    </uint32>
    <uint32 name='path_diff_bkw' ckeywords='VOLATILE' count='42*16/4'></uint32>
    <uint32 name='path_diff_fwd' ckeywords='VOLATILE' count='42*16/4'></uint32>
    <int32 name='Xcorr_I' ckeywords='VOLATILE' count='24+5'></int32>
    <int32 name='Xcorr_Q' ckeywords='VOLATILE' count='24+5'></int32>
</typedef>

<typedef name='SPP_DECODE_VITAC'>
    <comment>Viterbi Decoding Buffers Structure</comment>

    <uint32 name='RxItlvBufferOut' ckeywords='VOLATILE' count='114'>
        <comment>2144 bytes</comment>
    </uint32>
    <uint32 name='ViterbiOut' ckeywords='VOLATILE' count='16'></uint32>
    <uint32 name='SurvivorMEM' ckeywords='VOLATILE' count='(64*171)/(16*2)'></uint32>
    <uint32 name='PathMetric' ckeywords='VOLATILE' count='64'></uint32>
</typedef>


<typedef name='SPP_EGPRS_PREFILTER_BUFS'>

<instance name='InArray' type='SPP_COMPLEX' count='157'></instance>
<instance name='RLS_W' type='SPP_COMPLEX' count='8'></instance>
<instance name='PrefiltMin' type='SPP_COMPLEX' count='10+8'></instance>
<instance name='PrefiltMax' type='SPP_COMPLEX' count='10+8'></instance>
<instance name='LpChan' type='SPP_COMPLEX' count='8'></instance>
<instance name='A1' type='SPP_COMPLEX' count='8'></instance>
<instance name='A2' type='SPP_COMPLEX' count='10'></instance>
<instance name='P_Array' type='SPP_COMPLEX' count='10+1'></instance>
<instance name='P_Array_New' type='SPP_COMPLEX' count='10'></instance>
<instance name='H_CorArray' type='SPP_COMPLEX' count='2*8-1'></instance>
<instance name='LocalTsc' type='SPP_COMPLEX' count='16'></instance>
<instance name='TscSym' type='SPP_COMPLEX' count='26'></instance>
<instance name='DcIqBufs' type='SPP_COMPLEX' count='11'></instance>
</typedef>

<typedef name='SPP_EGPRS_DDFSE_BUFS'>

<instance name='InArray' type='SPP_COMPLEX' count='157'></instance>
<instance name='RLS_W' type='SPP_COMPLEX' count='8'></instance>
<instance name='PrefiltMin' type='SPP_COMPLEX' count='10+8'></instance>
<instance name='PrefiltMax' type='SPP_COMPLEX' count='10+8'></instance>
<instance name='LpChan' type='SPP_COMPLEX' count='8'></instance>
<instance name='BmmlZfMetric' type='SPP_COMPLEX' count='6/2 * 8 * 8 + 1'></instance>
<uint8 name='SoftOutputFwd' count='8*61*4'></uint8>
<uint8 name='SoftOutputBck' count='8*61*4'></uint8>
<uint8 name='TscSym' count='26'></uint8>
</typedef>


<typedef name='SPP_EGPRS_DECODE_VITAC'>
    <comment>Viterbi Decoding Buffers Structure</comment>

    <uint32 name='CombinedData' ckeywords='VOLATILE' count='459'></uint32>
    <uint32 name='SurvivorData' ckeywords='VOLATILE' count='(64*612)/(16*2)'></uint32>
    <uint32 name='PunctTable' ckeywords='VOLATILE' count='58'></uint32>
    <uint32 name='PathMetric' ckeywords='VOLATILE' count='64'></uint32>
    <uint32 name='DecodedData' ckeywords='VOLATILE' count='20'></uint32>
</typedef>


<enum name='SPP_CODING_SCHEME'>
    <comment>This is an exhaustive enum containing all the coding schemes for GSM/GPRS/EGPRS</comment>
    <comment>It has been designed to optimise table size, do NOT modify without knowing EXACTLY the impact !</comment>
    <comment>CS needing SRC are packed toghether</comment>
    <comment>CS that doesn't need CRC/CONV params are packed toghether at the END to reduce tables</comment>

    <entry name='CS_RACH'></entry>
    <entry name='CS_PRACH'></entry>
    <entry name='CS_SCH'></entry>
    <entry name='CS_CS1'></entry>
    <entry name='CS_CS2'></entry>
    <entry name='CS_CS3'></entry>
    <entry name='CS_CS4'></entry>
    <entry name='CS_HEAD_1'></entry>
    <entry name='CS_HEAD_2'></entry>
    <entry name='CS_HEAD_3'></entry>
    <entry name='CS_MCS1'></entry>
    <entry name='CS_MCS2'></entry>
    <entry name='CS_MCS3'></entry>
    <entry name='CS_MCS4'></entry>
    <entry name='CS_MCS5'></entry>
    <entry name='CS_MCS6'></entry>
    <entry name='CS_MCS7'></entry>
    <entry name='CS_MCS8'></entry>
    <entry name='CS_MCS9'></entry>
    <entry name='CS_HR'></entry>
    <entry name='CS_FR'></entry>
    <entry name='CS_EFR'></entry>
    <entry name='CS_H24'></entry>
    <entry name='CS_H48'></entry>
    <entry name='CS_F24'></entry>
    <entry name='CS_F48'></entry>
    <entry name='CS_F96'></entry>
    <entry name='CS_F144'></entry>
    <entry name='CS_AFS_SPEECH_122'></entry>
    <entry name='CS_AFS_SPEECH_102'></entry>
    <entry name='CS_AFS_SPEECH_795'></entry>
    <entry name='CS_AFS_SPEECH_74'></entry>
    <entry name='CS_AFS_SPEECH_67'></entry>
    <entry name='CS_AFS_SPEECH_59'></entry>
    <entry name='CS_AFS_SPEECH_515'></entry>
    <entry name='CS_AFS_SPEECH_475'></entry>
    <entry name='CS_AHS_SPEECH_795'></entry>
    <entry name='CS_AHS_SPEECH_74'></entry>
    <entry name='CS_AHS_SPEECH_67'></entry>
    <entry name='CS_AHS_SPEECH_59'></entry>
    <entry name='CS_AHS_SPEECH_515'></entry>
    <entry name='CS_AHS_SPEECH_475'></entry>
    <entry name='CS_AFS_SID_UPDATE'></entry>
    <entry name='CS_AFS_RATSCCH'></entry>
    <entry name='CS_AHS_SID_UPDATE'></entry>
    <entry name='CS_AHS_RATSCCH_DATA'></entry>
    <entry name='CS_AFS_SID_FIRST'></entry>
    <entry name='CS_AFS_ONSET'></entry>
    <entry name='CS_AHS_SID_UPDATE_INH'></entry>
    <entry name='CS_AHS_SID_FIRST_P1'></entry>
    <entry name='CS_AHS_SID_FIRST_P2'></entry>
    <entry name='CS_AHS_SID_FIRST_INH'></entry>
    <entry name='CS_AHS_ONSET'></entry>
    <entry name='CS_AHS_RATSCCH_MARKER'></entry>
    <entry name='CS_QTY'></entry>
</enum>

<var name='CS_NEED_SRC' value='CS_AFS_SPEECH_122'>
    <comment>Offset for the SRC tables</comment>
</var>
<var name='CS_END_NEED_SRC' value='CS_AFS_SID_FIRST'>
    <comment>Offset for Post SRC tables</comment>
</var>
<var name='CS_PARAM_QTY' value='CS_END_NEED_SRC'>
    <comment>size of the CRC/CONV table</comment>
</var>
<var name='CS_SRC_PARAM_QTY' value='CS_END_NEED_SRC - CS_NEED_SRC'>
    <comment>size of the SRC table</comment>
</var>


<enum name='SPP_SPEECH_MODE'>
    <comment>vocoder mode</comment>

    <entry name='SPP_MR475_MODE'></entry>
    <entry name='SPP_MR515_MODE'></entry>
    <entry name='SPP_MR59_MODE'></entry>
    <entry name='SPP_MR67_MODE'></entry>
    <entry name='SPP_MR74_MODE'></entry>
    <entry name='SPP_MR795_MODE'></entry>
    <entry name='SPP_MR102_MODE'></entry>
    <entry name='SPP_MR122_MODE'></entry>
    <entry name='SPP_FR_MODE'></entry>
    <entry name='SPP_HR_MODE'></entry>
    <entry name='SPP_EFR_MODE'></entry>
    <entry name='SPP_INVALID_MODE'></entry>
</enum>

<enum name='SPP_RX_FRAME_TYPE'>
    <comment>AMR enum</comment>

    <entry name='SPP_RX_SPEECH_GOOD'></entry>
    <entry name='SPP_RX_SPEECH_DEGRADED'></entry>
    <entry name='SPP_RX_ONSET'></entry>
    <entry name='SPP_RX_SPEECH_BAD'></entry>
    <entry name='SPP_RX_SID_FIRST'></entry>
    <entry name='SPP_RX_SID_UPDATE'></entry>
    <entry name='SPP_RX_SID_BAD'></entry>
    <entry name='SPP_RX_NO_DATA'></entry>
</enum>

<enum name='SPP_TX_FRAME_TYPE'>
    <entry name='SPP_TX_SPEECH'></entry>
    <entry name='SPP_TX_SID_FIRST'></entry>
    <entry name='SPP_TX_SID_UPDATE'></entry>
    <entry name='SPP_TX_NO_DATA'></entry>
</enum>

<typedef name='SPP_AMR_CFG'>
    <comment>AMR Config</comment>

    <uint8 name='activeCodecSet' count='4'></uint8>
    <uint8 name='hysteresis' count='3'></uint8>
    <uint8 name='threshold' count='3'></uint8>
    <uint8 name='version'></uint8>
    <uint8 name='noiseSuppression'></uint8>
    <uint8 name='startModeIdx'></uint8>
    <uint8 name='nbActiveCodecSet'></uint8>
    <uint8 name='phase'></uint8>
</typedef>

<enum name='SPP_AFS_TYPE'>
    <entry name='SPP_AFS_SID_UPDATE'></entry>
    <entry name='SPP_AFS_SID_FIRST'></entry>
    <entry name='SPP_AFS_ONSET'></entry>
    <entry name='SPP_AFS_SPEECH'></entry>
    <entry name='SPP_AFS_RATSCCH'></entry>
    <entry name='SPP_AFS_NO_DATA'></entry>
</enum>

<enum name='SPP_AHS_TYPE'>
    <entry name='SPP_AHS_SID_UPDATE'></entry>
    <entry name='SPP_AHS_SID_UPDATE_INH'></entry>
    <entry name='SPP_AHS_SID_FIRST_P1'></entry>
    <entry name='SPP_AHS_SID_FIRST_P2'></entry>
    <entry name='SPP_AHS_SID_FIRST_INH'></entry>
    <entry name='SPP_AHS_ONSET'></entry>
    <entry name='SPP_AHS_SPEECH'></entry>
    <entry name='SPP_AHS_RATSCCH_MARKER'></entry>
    <entry name='SPP_AHS_RATSCCH_DATA'></entry>
    <entry name='SPP_AHS_NO_DATA'></entry>
</enum>

<enum name='SPP_FCCH_RETURN'>
    <entry name='FCCH_FOUND'></entry>
    <entry name='FCCH_NOT_FOUND'></entry>
    <entry name='FCCH_INVALID'></entry>
</enum>

<enum name='SPP_FCCH_MODE'>
    <entry name='FCCH_SLICED'></entry>
    <entry name='FCCH_FULL'></entry>
</enum>

<enum name='SPP_ITLV_TYPE'>
    <entry name='ITLV_TYPE_1A' value='0'></entry>
    <entry name='ITLV_TYPE_1B' value='1'></entry>
    <entry name='ITLV_TYPE_1C' value='2'></entry>
    <entry name='ITLV_TYPE_2A' value='3'></entry>
    <entry name='ITLV_TYPE_2B' value='4'></entry>
    <entry name='ITLV_TYPE_3' value='5'></entry>
    <entry name='ITLV_TYPE_H1' value='6'></entry>
    <entry name='ITLV_TYPE_H2' value='7'></entry>
    <entry name='ITLV_TYPE_H3' value='8'></entry>
    <entry name='ITLV_TYPE_H4' value='9'></entry>
    <entry name='ITLV_TYPE_D1' value='10'></entry>
    <entry name='ITLV_TYPE_D2' value='11'></entry>
    <entry name='ITLV_TYPE_D3' value='12'></entry>
</enum>

<enum name='SPP_MODULATION_TYPE'>
    <entry name='SPP_UNKNOWN_MOD'></entry>
    <entry name='SPP_GMSK_MOD'></entry>
    <entry name='SPP_8PSK_MOD'></entry>
</enum>

<enum name='SPP_HEADER_TYPE'>
    <entry name='SPP_HEADER_TYPE1'></entry>
    <entry name='SPP_HEADER_TYPE2'></entry>
    <entry name='SPP_HEADER_TYPE3'></entry>
    <entry name='SPP_HEADER_UNKNOWN'></entry>
</enum>

<enum name='SPP_DUMMY_PCH_RESULT'>
    <entry name='SPP_DUMMY_PCH_NOT_DETECTED' value='0'></entry>
    <entry name='SPP_DUMMY_PCH_A_DETECTED' value='1'></entry>
    <entry name='SPP_DUMMY_PCH_AB_DETECTED' value='2'></entry>
    <entry name='SPP_PCH_DECODING_COMPLETE' value='3'></entry>
    <entry name='SPP_DUMMY_PCH_NO_RESULT' value='0xFF'></entry>
</enum>

<enum name='SPP_FCCH_DELAY_TYPE'>
    <entry name='FCCH_DELAY2' value='0'></entry>
    <entry name='FCCH_DELAY4' value='1'></entry>
</enum>

<cjoker>

//-------------------
// SPP IR structures
//-------------------

typedef union
{
    struct
    {
        UINT32 bsn : 11;  // BSN number
        UINT32 mod : 1;   // Modulation (1 GMSK, 0 8PSK)
        UINT32 mcs : 4;   // MCS (+ SPB for GMSK only)
    };

    UINT16 ID;

} SPP_HEADER_CTX_T;

typedef union
{
    struct
    {
        UINT32 bsnresi  : 5;   // residuel BSN number
        UINT32 spb      : 2;   // SPB for GMSK only
        UINT32 next     : 9;   // index of next bock
    };

    UINT16 ID_H;

} SPP_EGPRS_IR_HASH;


typedef struct
{
    SPP_HEADER_CTX_T header[MCS_MAX_BUFFER_LEN];
    UINT32           receiveBufState[(MCS_MAX_BUFFER_LEN+31)/32];
    UINT8            cps[(MCS_MAX_BUFFER_LEN+3)/4];
    UINT8             ReceiveState[(SPP_EGPRS_IR_SNS+3)/4];
    UINT16             hashEntry[HASH_LEN];
    SPP_EGPRS_IR_HASH  tabHash[MCS_MAX_BUFFER_LEN];
    UINT16             MaxBufferLength;
    UINT16             BufLeft;
    UINT16             pw;
    UINT16             Vq;
    UINT16             Vr;
    UINT16             CptSearch;
    UINT8             OverFlow;
    UINT8            irOn;

} SPP_EGPRS_IR_CTX_T;


typedef union
{
    UINT8 mcs1To4[MCS_1_TO_4_BUFFER_LEN][MCS_1_TO_4_BLOCK_LEN];
    UINT8 mcs5To6[MCS_5_TO_6_BUFFER_LEN][MCS_5_TO_6_BLOCK_LEN];
    UINT8 mcs7To9[MCS_7_TO_9_BUFFER_LEN][MCS_7_TO_9_BLOCK_LEN];

} SPP_EGPRS_IR_BUF_T;


//------------------------------------------------------------------------------
// Includes
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Defines
//------------------------------------------------------------------------------

// SPP PUBLIC STRUCTURES/ ENUMS
///@defgroup gsm_struct GSM Structures and enums
///@{

//---------------
// SPP structures
//---------------

//volatile UINT8 decoded_out[5];

// Overlap Vitac Buffer Mapping (sequential use only)
typedef union
{
       SPP_NB_VITAC_T               NbVitac;
       SPP_SCH_VITAC_T              SchVitac;
       SPP_DECODE_VITAC_T           DecodeVitac;
       SPP_EGPRS_PREFILTER_BUFS_T   EgprsPrefilterBufs;
       SPP_EGPRS_DDFSE_BUFS_T       EgprsDdfseBufs;
       SPP_EGPRS_DECODE_VITAC_T     EgprsDecodeVitac;
} SPP_UNCACHED_BUFFERS_T;
//----------
// SPP Enums
//----------

///@}

//------------------------------------------------------------------------------
// Functions
//------------------------------------------------------------------------------

// SPP PUBLIC FUNCTIONS
///@defgroup gsm_rx_func Rx processing functions
///@{

//======================================================================
// FCCH Detection function
//----------------------------------------------------------------------
/// This function implements FCCH detection over large reception windows
/// (usually 9 Time Slots in @b sliced mode or 12 TDMA frames in @b Full
/// mode). For both modes, the reception window must be sliced in sub
/// parts. The function must be called for each sub part of the window
/// and will return an FCCH detection status each time. See FCCH
/// detection memory requirements.
/// @param RxBuffer UINT32*. Start address of the reception buffer.
/// @param Init BOOL. Takes following values:
/// - TRUE : first call for this FCCH window,
/// - FALSE: subsequent calls for a same FCCH window.
/// .
/// @param Mode SPP_FCCH_MODE_T. Takes following values:
/// - #FCCH_SLICED for detection during dedicated mode,
/// - #FCCH_FULL for initial cell syncronization process.
/// .
/// @param Res SPP_FCCH_RESULT_T*. Pointer to the FCCH Result structure.
///
/// @return Takes following values:
/// - #FCCH_FOUND if fcch has been detected (results valid),
/// - #FCCH_NOT_FOUND if no fcch has been detected,
/// - #FCCH_INVALID if fcch has been detected but conditions
/// of detection (window boundaries, suspect frequency error
/// ...) are imposing to discard the detection results.
/// .
//======================================================================
PUBLIC SPP_FCCH_RETURN_T spp_SearchFcch(UINT32* RxBuffer,
                      BOOL Init,
                      SPP_FCCH_MODE_T Mode,
                      SPP_FCCH_DELAY_TYPE_T DelayType,
                      SPP_FCCH_RESULT_T* Res);

PUBLIC SPP_FCCH_RETURN_T  spp_SearchFcchFilter(UINT32* RxBuffer,
                      BOOL Init,
                      SPP_FCCH_MODE_T Mode,
                      SPP_FCCH_RESULT_T* Res);

PUBLIC BOOL spp_FcchDetect(UINT32* Ptr_old,
                      UINT32* Ptr_new,
                      SPP_FCCH_PARAM_T* Params,
                      SPP_FCCH_RESULT_T* Res);

PUBLIC BOOL spp_FcchDetectAsm(UINT32* Ptr_old,
                      UINT32* Ptr_new,
                      SPP_FCCH_PARAM_T* Params,
                      SPP_FCCH_RESULT_T* Res);

PUBLIC BOOL spp_FcchDetectFilterAsm(UINT32* Ptr_old,
                      UINT32* Ptr_new,
                      SPP_FCCH_PARAM_T* Params,
                      SPP_FCCH_RESULT_T* Res);

//======================================================================
// SCH Equalize and Decode function
//----------------------------------------------------------------------
/// Performs SCH burst equalization including:
/// - DC offset estimation and correction,
/// - channel estimation,
/// - SNR estimation,
/// - Viterbi equalization and traceback,
/// - Frequency Offset estimation.
/// .
/// @param RxBuffer : Pointer to the beginning of the RF samples buffer
/// @param UncachedBuffers : uncached working memory space
/// @param Res : Pointer to the SCH Result structure
//======================================================================
PUBLIC BOOL spp_EqualizeDecodeSch(UINT32* RxBuffer,
    SPP_UNCACHED_BUFFERS_T* UncachedBuffers,
    SPP_SCH_RESULT_T* Res);

//======================================================================
// spp_EqualizeNBurst
//----------------------------------------------------------------------
/// Performs normal burst equalization including:
/// - DC offset estimation and correction,
/// - channel estimation,
/// - SNR estimation,
/// - Viterbi equalization and traceback,
/// - Frequency Offset estimation.
/// .
///
/// @param RxBuffer (UINT32*): Pointer to the beginning of the RF samples buffer
/// @param Tsc (UINT8): Training sequence number
/// @param EqBufferOut (UINT32*): Pointer to the equalized output
/// @param UncachedBuffers : uncached working memory space
/// @param Res (SPP_N_BURST_RESULT_T*): Pointer to the Normal Burst Result structure
//======================================================================
PUBLIC VOID spp_EqualizeNBurst(UINT32* RxBuffer,
    UINT8 Tsc,
    UINT32* EqBufferOut,
    SPP_UNCACHED_BUFFERS_T* UncachedBuffers,
    SPP_N_BURST_RESULT_T* Res);

//======================================================================
// spp_DecodeStealingBits
//----------------------------------------------------------------------
/// Decode Stealing Flags of Normal Bursts.
///
/// @param RxBuffer UINT32*. Pointer to the beginning of the RF samples buffer.
/// @param StealMode BOOL. Takes following values:
/// - TRUE for PDCH Steal flags type,
/// - FALSE for TCH Steal flags type.
/// .
/// @param StealingResult UINT8*. Output pointer.
/// @param Threshold INT16. Decision threshold (for TCH only).
//======================================================================
PUBLIC VOID spp_DecodeStealingBits(UINT32* RxBuffer,
    BOOL StealMode,
    UINT8* StealingResult,
    INT16 Threshold);

//======================================================================
// spp_DeinterleaveBlock
//----------------------------------------------------------------------
/// DeInterleaving of a data block
///
/// @param BufferIn UINT32*. INPUT. Pointer to equalized bursts buffer.
/// @param InterleaverType UINT8. INPUT. InterleaverType may take the following values:
/// - 0 : TYPE_1A. Valid for TCH/FS, TCH/EFS, FACCH/F, TCH/F2.4,
/// TCH/AFS (speech, ratscch, sid_first).
/// - 1 : TYPE_1B. Valid for SACCH, SDCCH, TCH/AFS(sid_update), PDTCH(CS-1 to CS-4),
/// BCCH, PCH, AGCH, PACCH, PBCCH, PAGCH, PPCH, PNCH, PTCCH/D.
/// - 2 : TYPE_1C. Valid for FACCH/H.
/// - 3 : TYPE_2A. Valid for TCH/HS and TCH/AHS (speech, ratscch, sid_first).
/// - 4 : TYPE_2B. Valid for TCH/AHS (sid_update).
/// - 5 : TYPE_3. Valid for TCH/F14.4, TCH/F9.6, TCH/F4.8, TCH/H4.8
/// and TCH/H2.4.
/// - 6 : TYPE_H1. Valid for EGPRS HEADER TYPE2 in Rx.
/// - 7 : TYPE_H2. Valid for EGPRS HEADER TYPE2 in Tx.
/// - 8 : TYPE_H3. Valid for EGPRS HEADER TYPE1 in Rx.
/// - 9 : TYPE_H4. Valid for EGPRS HEADER TYPE1 in Tx.
/// - 10 : TYPE_D1. Valid for EGPRS MCS5/6.
/// - 11 : TYPE_D2. Valid for EGPRS MCS7.
/// - 12 : TYPE_D3. Valid for EGPRS MCS8/9.
/// @param BurstOffset UINT8. INPUT. Offset position for deinterleaving (see ITLV
/// documentation).
/// @param BufferOut UINT32*. OUTPUT. Output pointer.
//======================================================================
PUBLIC VOID spp_DeinterleaveBlock(UINT32* BufferIn,
    UINT8 InterleaverType,
    UINT8 BurstOffset,
    UINT32* BufferOut);

//======================================================================
// spp_DecodeBlock
//----------------------------------------------------------------------
/// Decoding of a data block
///
/// @param BufferIn UINT32*. Pointer to the deinterleaved data frame.
/// @param ChMode UINT16. Channel Type (PAL API format).
/// @param AmrFrameType UINT8. Type of AMR frame (set to 0 excepted for AMR).
/// @param AmrMode UINT8. Codec Mode (set to 0 excepted for AMR).
/// @param BufferOut UINT32*. Output pointer.
/// @param Usf UINT8. Uplink State Flag.
/// @param UncachedBuffers : uncached working memory space
/// @param Res SPP_N_BLOCK_RESULT_T*. Pointer to the Block Result structure.
//======================================================================
PUBLIC VOID spp_DecodeBlock(UINT32* BufferIn,
    UINT16 ChMode,
    UINT8 AmrFrameType,
    UINT8 AmrMode,
    UINT32* BufferOut,
    UINT8 Usf,
    SPP_UNCACHED_BUFFERS_T* UncachedBuffers,
    SPP_N_BLOCK_RESULT_T* Res);

//======================================================================
// spp_GetUSF
//----------------------------------------------------------------------
/// Uplink State Flag extraction
///
/// @param BufferIn UINT32*. Pointer to the beginning of the RF samples buffer.
/// @param CS UINT8. Coding scheme.
///
/// @return UINT8. Uplink State Flag
//======================================================================
PUBLIC UINT8 spp_GetUSF(UINT32* BufferIn,
    UINT8 CS);

//======================================================================
// spp_DetectDummyPCH
//----------------------------------------------------------------------
/// Dummy PCH detection
///
/// @param BufferIn UINT32* Pointer to the beginning of the softbits.
/// @param Idx      UINT8   Index of the received burst
/// @param Thresh_a UINT8   Threshold for vector A detection
/// @param Thresh_b UINT8   Threshold for vector B detection
//
/// @return         UINT8   0xFF: false, 0x1: only A, 0x2: AB detected
//======================================================================
UINT8 spp_DetectDummyPCH(UINT32 *Buffer,
                         UINT8 Idx,
                         UINT8 Thresh_a,
                         UINT8 Thresh_b);

//======================================================================
// spp_GetMonPower
//----------------------------------------------------------------------
/// Calculate Power for Monitoring (and Interference) windows.
///
/// @param MonIdx UINT8. Index of the monitoring (or interference) window.
/// @param RxBuffer UINT32*. Pointer to the Rx buffer.
/// @param power UINT32*. Pointer to the resulting calculated power.
//======================================================================
PUBLIC VOID spp_GetMonPower(UINT8 MonIdx,
    UINT32* RxBuffer,
    UINT32* power);

//======================================================================
// Decoding of AMR Inband Data (DTX and RATSCCH frames)
//----------------------------------------------------------------------
/// This function decodes inband data for AFS or AHS
/// deinterleaved softbit frames (SPEECH, SIDUPDATE, RATSCCH)
///
/// @param softBit : Pointer to the decoded data
/// @param mode : type of frame: 0 -&amp;gt; AFS, 1 -&amp;gt; AHS, 2 -&amp;gt; SIDUPDATE/RATSCCH
///
/// @return UINT8. Inband Data.
//======================================================================
PUBLIC UINT8 spp_GetAmrIc(UINT8 *softBit,
    UINT8 mode);

//======================================================================
// Search AMR frame markers
//----------------------------------------------------------------------
/// This function searches AMR frame markers and returns the most
/// likely frame type. It decode also the associated in band data.
///
/// @param BufferIn UINT32*. Pointer to the deinterleaved decoded data.
/// @param id1 UINT8*. Pointer to ther first decoded in band data.
/// @param id2 UINT8*. Pointer to the second decoded in band data.
/// @param mode UINT8. TCH rate: 0 -&amp;gt; AFS, 1 -&amp;gt; AHS.
///
/// @return UINT8. Most likely frame type.
//======================================================================
PUBLIC UINT8 spp_SearchAmrMarker(UINT32 *BufferIn,
    UINT8 *id1,
    UINT8 *id2,
    UINT8 mode);

//=============================================================================
// spp_GetAmrMetric
//-----------------------------------------------------------------------------
// This function return amr metric
// @param softBit UINT8*. Pointer to the decoded data.
// @param rate FR/HR
// @param ic inband data
// @param biterror BER
//=============================================================================
PUBLIC UINT8 spp_GetAmrMetric(UINT8* softBit, UINT8 rate, UINT8 ic, UINT8 *biterror);

//======================================================================
// spp_EgprsBlindDetection
//----------------------------------------------------------------------
/// Performs modulation blind detection and TOf estimation:
///.
/// @param RxBuffer (UINT32*): Pointer to the beginning of the RF samples buffer
/// @param burstIdx (UINT8): burst index number
/// @param tsc UINT8 : training sequence Id
/// @param modulation (SPP_MODULATION_TYPE_T*): Pointer to modulation result
/// @param TOf_in_Qb (UINT8*): Pointer to timing offset result in quarter of bit
/// @param TOf (UINT8*): Pointer to timing offset result
//======================================================================
PUBLIC VOID spp_EgprsBlindDetection(UINT32* RxBuffer,
    UINT8 burstIdx,
    UINT8 tsc,
    SPP_MODULATION_TYPE_T* modulation,
    UINT8* TOf_in_Qb,
    UINT8* TOf);

//======================================================================
// spp_EgprsEqualizeNBurst
//----------------------------------------------------------------------
/// Performs normal burst equalization including:
/// - DC offset estimation and correction,
/// - IQ imbalance estimation and correction,
/// - channel estimation,
/// - SNR estimation,
/// - Viterbi equalization and traceback,
/// - Frequency Offset estimation.
/// .
///
/// @param RxBuffer (UINT32*): Pointer to the beginning of the RF samples buffer
/// @param Tsc (UINT8): Training sequence number
/// @param EqBufferOut (UINT32*): Pointer to the equalized output
/// @param UncachedBuffers : uncached working memory space
/// @param Res (SPP_N_BURST_RESULT_T*): Pointer to the Normal Burst Result structure
//======================================================================
PUBLIC VOID spp_EgprsEqualizeNBurst(UINT32* RxBuffer,
    UINT8 Tsc,
    UINT32* EqBufferOut,
    SPP_UNCACHED_BUFFERS_T* UncachedBuffers,
    SPP_N_BURST_RESULT_T* Res);

//======================================================================
// spp_EgprsBurstDemapping
//----------------------------------------------------------------------
/// Performs burst demapping for EDGE:
/// .
/// @param BufferIn (UINT32*): Pointer to the sofbit buffer
/// @param headertype (SPP_HEADER_TYPE_T): haeder type of the block
/// @param BufferOut (UINT32*): Pointer to the block's softbits (MCS1-4)
/// @param HeaderBufferOut (UINT32*): Pointer to the Header sofbits (MCS5-9)
/// @param DataBufferOut (UINT32*): Pointer to the Data sofbits (MCS5-9)
//======================================================================
PUBLIC VOID spp_EgprsBurstDemapping(UINT32* BufferIn,
    UINT32* HeaderBufferOut,
    UINT32* DataBufferOut,
    SPP_HEADER_TYPE_T headerType);

//======================================================================
// spp_EgprsDecodeStealingBits
//----------------------------------------------------------------------
/// Decode Stealing Flags of Normal Bursts.
///
/// @param RxBuffer UINT32*. Pointer to the beginning of the RF samples buffer.
/// @param headertype SPP_HEADER_TYPE_T*. Output pointer.
//======================================================================
PUBLIC VOID spp_EgprsDecodeStealingBits(UINT32* RxBuffer,
    SPP_HEADER_TYPE_T* headertype);

//======================================================================
// spp_EgprsDecodeHeader
//----------------------------------------------------------------------
/// Decoding of a data block
///
/// @param BufferIn UINT8*. Pointer to the deinterleaved data frame.
/// @param header_type SPP_HEADER_TYPE_T. Channel Type (PAL API format).
/// @param Usf UINT8 3 decoded usf bit .
/// @param BufferOut UINT8*. Output pointer.
/// @param UncachedBuffers : uncached working memory space
/// @param Res SPP_HEADER_RESULT_T*. Pointer to the Header Result structure.
//======================================================================
PUBLIC VOID spp_EgprsDecodeHeader(UINT8 *BufferIn,
                                    SPP_HEADER_TYPE_T HeadType,
                                    UINT8 Usf,
                                    UINT8 *BufferOut,
                                    SPP_UNCACHED_BUFFERS_T* UncachedBuffers,
                                    SPP_HEADER_RESULT_T* Res);

//======================================================================
// spp_EgprsDecodeData
//----------------------------------------------------------------------
/// Decoding of a data block
///
/// @param BufferIn UINT8*. Pointer to the deinterleaved data frame.
/// @param Header SPP_HEADER_RESULT_T. decoded Header structure.
/// @param BufferOut0 UINT8*. Output pointer for the first RLC data block.
/// @param BufferOut1 UINT8*. Output pointer for the second RLC data block (MCS 7,8,9 only).
/// @param irCtx : uncached IR context memory space
/// @param irBuf : uncached IR buffer memory space
/// @param UncachedBuffers : uncached working memory space
/// @param Res SPP_N_BLOCK_RESULT_T*. Pointer to the Block Result structure.
//======================================================================
PUBLIC VOID spp_EgprsDecodeData(UINT8                       *BufferIn,
                                SPP_HEADER_RESULT_T             Header,
                                UINT8                        *BufferOut0,
                                UINT8                        *BufferOut1,
                                SPP_EGPRS_IR_CTX_T            *irCtx,
                                SPP_EGPRS_IR_BUF_T            *irBuf,
                                SPP_UNCACHED_BUFFERS_T        *UncachedBuffers,
                                SPP_N_BLOCK_RESULT_T        *Res);

//======================================================================
// spp_EgprsGetUSF
//----------------------------------------------------------------------
/// Uplink State Flag extraction
///
/// @param BufferIn UINT32*. Pointer to the beginning of the RF samples buffer.
/// @return UINT8. Uplink State Flag
//======================================================================
PUBLIC UINT8 spp_EgprsGetUSF(UINT32* BufferIn);

//======================================================================
// spp_EgprsDeinterleaveBlock
//----------------------------------------------------------------------
/// DeInterleaving of a data block
///
/// @param BufferIn UINT32*. INPUT. Pointer to equalized bursts buffer.
/// @param InterleaverType UINT8. INPUT. InterleaverType may take the following values:
/// - 6 : TYPE_H1. Valid for EGPRS HEADER TYPE2 in Rx.
/// - 7 : TYPE_H2. Valid for EGPRS HEADER TYPE2 in Tx.
/// - 8 : TYPE_H3. Valid for EGPRS HEADER TYPE1 in Rx.
/// - 9 : TYPE_H4. Valid for EGPRS HEADER TYPE1 in Tx.
/// - 10 : TYPE_D1. Valid for EGPRS MCS5/6.
/// - 11 : TYPE_D2. Valid for EGPRS MCS7.
/// - 12 : TYPE_D3. Valid for EGPRS MCS8/9.
/// @param BufferOut UINT32*. OUTPUT. Output pointer.
//======================================================================
PUBLIC VOID spp_EgprsDeinterleaveBlock(UINT32* BufferIn,
    SPP_ITLV_TYPE_T InterleaverType,
    UINT32* BufferOut);



//=============================================================================
//  spp_EgprsIrInitCtx
//-----------------------------------------------------------------------------
/// for IR initial.
///
/// @param IR SPP_EGPRS_IR_CTX_T*. Incremental Redundancy related structure.
/// @param ChSubMode GSM_CS_T. Channel mode.
///
/// @author zhangchangchun
/// @date 2007/09/18
//=============================================================================
PUBLIC VOID spp_EgprsIrInitCtx(SPP_EGPRS_IR_CTX_T *IR, GSM_CS_T ChSubMode);



///@}

///@defgroup gsm_tx_func Tx processing functions
///@{
//-----------------------
// Transmission Functions
//-----------------------
//======================================================================
// spp_EncodeABurst
//----------------------------------------------------------------------
/// Access Burst encoding
///
/// @param BufferIn UINT32*. Pointer to the data to be encoded.
/// @param Bsic UINT8. Base Station BSIC.
/// @param size UINT8. 8 or 11 bits Access Burst.
/// @param BufferOut UINT32*. Encoded data output pointer.
//======================================================================
PUBLIC VOID spp_EncodeABurst(UINT32* BufferIn,
    UINT8 Bsic,
    UINT8 size,
    UINT32* BufferOut);

//======================================================================
// spp_EncodeBlock
//----------------------------------------------------------------------
/// Normal BLOCK encoding
///
/// @param InTxBuffer UINT32*. Pointer to the data to be encoded.
/// @param ChMode UINT16. Channel Type (PAL API format).
/// @param AmrFrameType UINT8. Type of AMR frame (set to 0 excepted for AMR).
/// @param AmrMode UINT8. Codec Mode (set to 0 excepted for AMR).
/// @param AmrInBandData UINT8*. AMR in Band Data (set to NULL excepted for AMR).
/// @param BurstOffset UINT8. Offset position for interleaving. Interleaving
/// is performed over a number of Tx bursts. The Offset position corresponds to
/// the offset number of bursts in the interleaving buffer. For example, in
/// FR mode, BurstOffset can be 0 or 4 as one coded block is interleaved over
/// 8 consecutive bursts, and each coded block has 4 bursts worth of payload.
/// (see ITLV documentation).
/// @param InterleaverType UINT8. INPUT. InterleaverType may take the following values:
/// - 0 : TYPE_1A. Valid for TCH/FS, TCH/EFS, FACCH/F, TCH/F2.4,
/// TCH/AFS (speech, ratscch, sid_first).
/// - 1 : TYPE_1B. Valid for SACCH, SDCCH, TCH/AFS(sid_update), PDTCH(CS-1 to CS-4),
/// BCCH, PCH, AGCH, PACCH, PBCCH, PAGCH, PPCH, PNCH, PTCCH/D.
/// - 2 : TYPE_1C. Valid for FACCH/H.
/// - 3 : TYPE_2A. Valid for TCH/HS and TCH/AHS (speech, ratscch, sid_first).
/// - 4 : TYPE_2B. Valid for TCH/AHS (sid_update).
/// - 5 : TYPE_3. Valid for TCH/F14.4, TCH/F9.6, TCH/F4.8, TCH/H4.8
/// and TCH/H2.4.
/// .
/// @param BufferOut UINT32*. Encoded data output pointer. The function
/// stores the output (the interleaved and encoded bits) in the Tx interleaver buffer.
/// BufferOut should point to the beginning of the Tx interleaver buffer.
//======================================================================
PUBLIC VOID spp_EncodeBlock(UINT32* InTxBuffer,
    UINT16 ChMode,
    UINT8 AmrFrameType,
    UINT8 AmrMode,
    UINT8* AmrInBandData,
    UINT8 BurstOffset,
    UINT8 InterleaverType,
    UINT32* BufferOut);

//======================================================================
// spp_BuildNBurst
//----------------------------------------------------------------------
/// Normal Burst building and mapping
///
/// @param TxBuffer UINT32*. Pointer to the encoded data.
/// @param Tsc UINT8. Training sequence number.
/// @param StealFlag UINT8. Stealing Flags.
/// @param BufferOut UINT32*. Burst output pointer.
//======================================================================
PUBLIC VOID spp_BuildNBurst(UINT32* TxBuffer,
    UINT8 Tsc,
    UINT8 StealFlag,
    UINT32* BufferOut);

//======================================================================
// spp_Modulation
//----------------------------------------------------------------------
/// This function handles the modulation of the (multiple) burst(s)
/// constituting the full Tx window.
/// The following is true for Granite TC and Greenstone :
/// resulting modulated structure :
/// - Preamble
/// - 1st burst (156 bits)
/// - eventual 2nd burst (156 bits)
/// - eventual 3nd burst (156 bits)
/// - eventual 4nd burst (156 bits)
/// - Postamble (enough for 32 bits)
///
/// Preamble are filled with '1'
/// Postamble are filled with '1'
/// Eventual "Holes" in burst Bitmap are filled with '1' because
/// multislot transmission is continuous from GMSK point of view
///
/// For Emerald:
/// depending on modulation one symbol is either 1 or 3 bits.
/// Modulation can change for each slot. 'Holes' are not sent.
/// resulting modulated structure if burst N is the first active
/// burst or if burst N-1 is inactive:
///
/// - bstN definition for RF_IF
/// - Preamble symb                 |
/// - bstN active part (148 symb)   |
///                                 | in burst N modulation
/// then if bstN+1 is active:       |
/// - (8-guardStart) symb           |
/// - bstN+1 definition for RF_IF
/// - guardStart symb               |
/// - bstN+1 active part (148 symb) | in burst N+1 modulation
/// - ... and so on until inactive burst
///
/// else if bstN+1 is inactive:
/// - Postamble symb                | in burst N modulation
/// - End of transmit for RF_IF
///
/// @param BufferIn pointer to the mapped burst(s) data
/// @param Bitmap Tx window bitmap allocation (first active bit is
/// considered as 1st burst)
/// @param preamble Burst Mapping parameters
/// @param postamble Burst Mapping parameters
/// @param guardStart Burst Mapping parameters
/// @param BufferOut Pointer to the output sw fifo (if relevant
//         for HW implementation)
/// @param BstMod Type of the modulation, 8PSK or GMSK.
/// @param NormalBst 0:Access Burst 1:Normal Burst
/// @todo  change modulation field to a bitmap to handle multislot.
/// @todo  do a structure for Burst Mapping parameters
/// @todo  include the burst type (AB/NB) in the modulation bitmap...
//======================================================================

PUBLIC VOID spp_Modulation(UINT32* BufferIn,
    UINT8 Bitmap,
                            UINT16 preamble,
                            UINT16 postamble,
                            UINT16 guardStart,
    UINT32* BufferOut,
                            SPP_MODULATION_TYPE_T BstMod,
                            BOOL NormalBst);

//======================================================================
// spp_EgprsEncodeBlock
//----------------------------------------------------------------------
/// Normal BLOCK encoding
///
/// @param InData0 UINT32*. Pointer to the 1st Tx buffer (for all MCS) to be encoded.
/// @param InData0 UINT32*. Pointer to the 2nd Tx buffer (for MCS > MCS6) to be encoded.
/// @param InHeader UINT32*. Pointer to the header buffer (for all MCS).
/// @param  header_type SPP_HEADER_TYPE_T. type of the header.
/// @param BufferOut UINT32*. Encoded data output pointer. The function
/// stores the output (the interleaved and encoded bits) in the Tx interleaver buffer.
/// BufferOut should point to the beginning of the Tx interleaver buffer.
//======================================================================
PUBLIC VOID spp_EgprsEncodeBlock(UINT32* InData0,
                                 UINT32* InData1,
                                 UINT32* InHeader,
                                 SPP_HEADER_TYPE_T header_type,
                                 UINT32* BufferOut);

//======================================================================
// spp_EgprsBuildNBurst
//----------------------------------------------------------------------
/// Normal Burst building and mapping
///
/// @param TxBuffer UINT32*. Pointer to the encoded data.
/// @param Tsc UINT8. Training sequence number.
/// @header_type SPP_HEADER_TYPE_T. type of the header.
/// @param BufferOut UINT32*. Burst output pointer.
//======================================================================
PUBLIC VOID spp_EgprsBuildNBurst(UINT32* TxBuffer,
    UINT8 Tsc,
    SPP_HEADER_TYPE_T headerType,
    UINT32* BufferOut);

//-----------------------
// Ciphering Functions
//-----------------------
///@defgroup gsm_ciphering_func GSM/GPRS Miscellanous Functions
///@{

//======================================================================
// spp_CipherCipherNB
//----------------------------------------------------------------------
/// This function ciphers 114 bits for normal burst.
///
/// @param BufferIn UINT32*. Pointer to input buffer.
/// @param BufferOut UINT32*. Pointer to output buffer.
///
//======================================================================
PUBLIC VOID spp_CipherCipherNb(UINT32* BufferIn, UINT32* BufferOut);

//======================================================================
// spp_CipherCipherNB
//----------------------------------------------------------------------
/// This function deciphers 114 bits for normal burst.
///
/// @param BufferIn UINT32*. Pointer to input buffer.
/// @param BufferOut UINT32*. Pointer to output buffer.
///
//======================================================================
PUBLIC VOID spp_CipherDecipherNb(UINT32* BufferIn, UINT32* BufferOut);

//======================================================================
// Initialize the count register
//----------------------------------------------------------------------
/// This function initializes the count register.
///
/// @param count UINT32. Counter register.
//======================================================================
PUBLIC UINT8 spp_CipherCountInit(UINT32 count);

//======================================================================
// spp_CipherStart
//----------------------------------------------------------------------
/// Start the encipherment.
///
/// @param algo UINT8.
///
/// @return UINT8. Error or no error???
//======================================================================
PUBLIC UINT8 spp_CipherStart(UINT8 algo);

/// @}


//-----------------------
// Miscellanous Functions
//-----------------------
///@defgroup gsm_misc_func GSM/GPRS Miscellanous Functions
///@{

// =============================================================================
// spp_FullBurstReady
// -----------------------------------------------------------------------------
/// This function MUST be in RAM and not in ROM !
/// This function returns the number of completely received (and not treated)
/// bursts in the active frame.
/// @return
// =============================================================================
PUBLIC UINT8 spp_FullBurstReady(VOID);

// =============================================================================
// spp_ResetFullBurstReady
// -----------------------------------------------------------------------------
/// This function MUST be in RAM and not in ROM !
/// This function resets the number of completely received bursts in the active
/// frame.
// =============================================================================
PUBLIC VOID spp_ResetFullBurstReady(VOID);

// =============================================================================
// spp_OneFullBurstReady
// -----------------------------------------------------------------------------
/// This function MUST be in RAM and not in ROM !
/// This function flags that a burst has been completely received in the active
/// frame.
// =============================================================================
PUBLIC VOID spp_OneFullBurstReady(VOID);

// =============================================================================
// spp_OneFullBurstDone
// -----------------------------------------------------------------------------
/// This function MUST be in RAM and not in ROM !
/// This function flags that a burst has been fully processed in the active
/// frame.
// =============================================================================
PUBLIC VOID spp_OneFullBurstDone(VOID);

/// @}


</cjoker>
</archive>
<archive relative='../../../platform/base/common/include/baseband_defs.xmd'  asm="no">

<var name='BB_RX_SCH_MARGIN' value='12'>
    <comment>--------------------------------------------------------------------    Timings and Sizes   These timings are shared by different SW modules and are derived   from baseband signal processing capabilities and needs  --------------------------------------------------------------------  Values in symbols</comment>
</var>

<var name='BB_RX_NBURST_MARGIN' value='4'></var>

<var name='BB_BURST_TOTAL_SIZE' value='156'>
    <comment>One Qb is dropped</comment>
</var>

<var name='BB_BURST_HALF_SIZE' value='96'>
    <comment>Used for EQU_HBURST_MODE'</comment>
</var>

<var name='BB_BURST_ACTIVE_SIZE' value='148'></var>

<var name='BB_SCH_TOTAL_SIZE' value='(BB_BURST_ACTIVE_SIZE + 2*BB_RX_SCH_MARGIN)'></var>


<cjoker>
/**
@file
Defines related to the BaseBand signal processing
*/
</cjoker>
</archive>

<archive relative='../../../platform/chip/bcpu/spp/include/spp_map.xmd'  asm="no">

    <comment>
        This file contains the portion of SPP's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool).
    </comment>

    <include file="spp_gsm.xmd"/>
    <include file="../../../../base/common/include/baseband_defs.xmd"/>

    
    <typedef name="SPP_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of SPP.
        </comment>
        <int8 name="noneYet"/>
    </typedef>

</archive>

<archive relative='../../../platform/chip/bcpu/include/spc_mailbox_v3.xmd'  asm="no">


<comment>
@file spc_mailbox.h<br/>
This File contains SPC API<br/>
<br/>
@mainpage Modem2G Signal Processing Control API<br/>
@page spc_mainpage Modem2G Signal Processing Control API<br/>
<br/>
Modem2G Signal Processing Control (SPC) API description.<br/>
@author Coolsand Technologies, Inc.<br/>
@version 2.0<br/>
@date april 2009<br/>
<br/>
@par Purpose<br/>
<br/>
This document describes the Modem2G software interface between SPC &amp; PAL.<br/>
This interface is realized by means of different structures<br/>
contained in a part of the memory that we call mailbox.<br/>
Each involved layer, i.e. SPC and PAL have a dedicated structure to<br/>
transfer information to the other part.<br/>
<br/>
@par<br/>
<br/>
SPC API is composed of the following division :<br/>
- @ref spc2pal "SPC to PAL structures " \n<br/>
- @ref pal2spc "PAL to SPC structures " \n<br/>
- @ref mbox "main mailbox structure" \n<br/>
<br/>
This mailbox allows the XCPU to progam different processings on BCPU<br/>
and to retrieve associated results.<br/>
<br/>
@defgroup mbox
<br/>
@{
</comment>

<include load="no" file="cs_types.h"/>

<var name='BB_FCCH_SIZE' value='142'>
    <comment>FCCH search related constants: do not change unless you know what you're doing ! Granularity of FCCH search in symbols.</comment>
</var>

<var name='BB_FCCH_NB_WIN' value='((625*9)/(BB_FCCH_SIZE*4) + 1)'></var>

<var name='BB_FCCH_PRE_OPENING' value='(BB_FCCH_NB_WIN*BB_FCCH_SIZE - ((625*9)/4))'></var>

<var name='MBOX_CTX_SNAP_QTY' value='3'>
    <comment>number of context duplicates</comment>
</var>

<var name='MBOX_WINDOWS_QTY' value='5'>
    <comment>max number of windows in a burts</comment>
</var>

<var name='MBOX_WIN_IDX_QTY' value='MBOX_WINDOWS_QTY'>
    <comment>max number of windows index</comment>
</var>

<var name='MBOX_MON_WIN_SIZE' value='32'></var>

<var name='MBOX_MONIT_WIN_QTY' value='MBOX_WINDOWS_QTY'>
    <comment>max number of monitoring windows</comment>
</var>

<var name='MBOX_MONIT_EXT_WIN_QTY' value='7-MBOX_WINDOWS_QTY'>
    <comment>max number of extra monitoring windows</comment>
</var>

<var name='MBOX_INTRF_SLOT_QTY' value='6'>
    <comment>max number of slots for an interference measurement window</comment>
</var>

<var name='MBOX_SCH_QTY' value='1'>
    <comment>max number of synchonization burst window</comment>
</var>

<var name='MBOX_SCH_DATA_BYTE_QTY' value='4'>
    <comment>number of data byte in a decoded SCH burst</comment>
</var>

<var name='MBOX_NBURST_DATA_QTY' value='2'>
    <comment>number of data output address</comment>
</var>

<var name='MBOX_MAX_TS_QTY' value='4'>
    <comment>max number of slots in a window</comment>
</var>

<var name='MBOX_MAX_BUF_IDX_QTY' value='5'>
    <comment>max number of buffer index</comment>
</var>

<var name='MBOX_MAX_SPEECH_FRAME_SIZE' value='18'>
    <comment>max number of words in a compressed speech frame</comment>
</var>

<var name='MBOX_NO_TCH' value='0x00'>
    <comment>Channel Mode comming from stack</comment>
</var>

<var name='MBOX_TCH_FR' value='0x04'></var>

<var name='MBOX_TCH_EFR' value='0x14'></var>

<var name='MBOX_TCH_HR' value='0x05'></var>

<var name='MBOX_TCH_AFS' value='0x24'></var>

<var name='MBOX_TCH_AHS' value='0x25'></var>

<var name='MBOX_TCH_F48' value='0x48'></var>

<var name='MBOX_TCH_F96' value='0x88'></var>

<var name='MBOX_TCH_F144' value='0xC8'></var>

<var name='MBOX_XCPU_HELLO_WORD' value='0xBB08E770'>
    <comment>BCPU starting handshake</comment>
</var>

<var name='MBOX_BCPU_ACKNOWLEDGE_WORD' value='0xBB04EAD1'></var>

<var name='MBOX_BCPU_ERROR_WORD' value='0xBB0E4404'></var>

<var name='MBOX_CIPH_MODE_A51' value='0'>
    <comment>Ciphering algorithm</comment>
</var>

<var name='MBOX_CIPH_MODE_A52' value='1'></var>

<var name='MBOX_CIPH_MODE_A53' value='2'></var>

<var name='MBOX_LOOP_CLOSE_A' value='1'>
    <comment>Loop modes see 3GPP 44.014 for more details</comment>
</var>

<var name='MBOX_LOOP_CLOSE_B' value='2'></var>

<var name='MBOX_LOOP_CLOSE_C' value='3'></var>

<var name='MBOX_LOOP_CLOSE_D' value='4'></var>

<var name='MBOX_LOOP_CLOSE_E' value='5'></var>

<var name='MBOX_LOOP_CLOSE_F' value='6'></var>

<var name='MBOX_LOOP_SPCH_DECOD' value='7'></var>

<var name='MBOX_LOOP_SPCH_ENCOD' value='8'></var>

<var name='MBOX_LOOP_ACOUSTIC_TEST' value='9'></var>

<var name='MBOX_LOOP_OPEN' value='10'></var>

<var name='MBOX_LOOP_CLOSE_I' value='11'></var>

<var name='MBOX_LOOP_CLOSE_EGPRS' value='12'></var>

<enum name='SPC_MBOX_DSP_ITR'>
    <comment>BCPU to XCPU interrupts</comment>

    <entry name='MBOX_DSP_NO_ITR' value='0'>
        <comment>no interrupt</comment>
    </entry>
    <entry name='MBOX_DSP_SCH_DECODING_COMPLETE' value='0x1'>
        <comment>synchro burst decoding done</comment>
    </entry>
   <entry name='MBOX_DSP_PCH_READY' value='0x2'>
        <comment>dummy PCH detection done</comment>
    </entry>
   <entry name='MBOX_DSP_USF_READY' value='0x4'>
        <comment>USF decoding done for GPRS</comment>
    </entry>
    <entry name='MBOX_DSP_EQUALIZATION_COMPLETE' value='0x8'>
        <comment>normal burst equalization done</comment>
    </entry>
    <entry name='MBOX_DSP_TASK_COMPLETE' value='0x10'>
        <comment>Dsp Task complete</comment>
    </entry>
</enum>

<enum name='SPC_MBOX_XCPU_ITR'>
    <comment>XCPU to BCPU interrupts  in the mailbox regs are from bits 8 to 15</comment>

    <entry name='MBOX_XCPU_NO_ITR' value='0'>
        <comment>no interrupt from XCPU</comment>
    </entry>
    <entry name='MBOX_XCPU_AUDIO' value='0x100'>
        <comment>audio interrupt from XCPU</comment>
    </entry>
</enum>

<enum name='SPC_MBOX_CHAN_TYPES'>
    <comment>GSM/GPRS logical channels types</comment>

    <entry name='MBOX_CCH_CHN'>
        <comment>control channel</comment>
    </entry>
    <entry name='MBOX_PDCH_CHN'>
        <comment>packet data channel</comment>
    </entry>
    <entry name='MBOX_TCHF_CHN'>
        <comment>traffic channel full rate</comment>
    </entry>
    <entry name='MBOX_TCHH_CHN'>
        <comment>traffic channel half rate</comment>
    </entry>
    <entry name='MBOX_FACCH_CHN'>
        <comment>fast associated control channel</comment>
    </entry>
    <entry name='MBOX_CDATA_CHN'>
        <comment>circuit switched data channel</comment>
    </entry>
    <entry name='MBOX_CHAN_TYPE_RACH'>
        <comment>random access channel (not defined in palcgsm.h)</comment>
    </entry>
</enum>

<enum name='SPC_MBOX_EGPRS_MODE'>
    <comment>EGPRS mode </comment>

    <entry name='MBOX_NO_EGPRS'>
        <comment> no egprs </comment>
    </entry>
    <entry name='MBOX_EGPRS_NO_IR'>
        <comment> egprs without incremental redundancy </comment>
    </entry>
    <entry name='MBOX_EGPRS_WITH_IR'>
        <comment> egprs with incremental redundancy </comment>
    </entry>
</enum>

<enum name='MBOX_SPEECH_MODE'>
    <entry name='MBOX_AMR475_DEC_MODE' value='0x00f0'></entry>
    <entry name='MBOX_AMR475_ENC_MODE' value='0x000f'></entry>
    <entry name='MBOX_AMR515_DEC_MODE' value='0x00f1'></entry>
    <entry name='MBOX_AMR515_ENC_MODE' value='0x001f'></entry>
    <entry name='MBOX_AMR59_DEC_MODE' value='0x00f2'></entry>
    <entry name='MBOX_AMR59_ENC_MODE' value='0x002f'></entry>
    <entry name='MBOX_AMR67_DEC_MODE' value='0x00f3'></entry>
    <entry name='MBOX_AMR67_ENC_MODE' value='0x003f'></entry>
    <entry name='MBOX_AMR74_DEC_MODE' value='0x00f4'></entry>
    <entry name='MBOX_AMR74_ENC_MODE' value='0x004f'></entry>
    <entry name='MBOX_AMR795_DEC_MODE' value='0x00f5'></entry>
    <entry name='MBOX_AMR795_ENC_MODE' value='0x005f'></entry>
    <entry name='MBOX_AMR102_DEC_MODE' value='0x00f6'></entry>
    <entry name='MBOX_AMR102_ENC_MODE' value='0x006f'></entry>
    <entry name='MBOX_AMR122_DEC_MODE' value='0x00f7'></entry>
    <entry name='MBOX_AMR122_ENC_MODE' value='0x007f'></entry>
    <entry name='MBOX_EFR_MODE' value='0x0177'></entry>
    <entry name='MBOX_FR_MODE' value='0x1fff'></entry>
    <entry name='MBOX_HR_MODE' value='0x2fff'></entry>
    <entry name='MBOX_INVALID_MODE' value='0xffff'></entry>
</enum>

<enum name='SPC_DIGRF_CLKPOL'>
    <entry name='SPC_DIGRF_NORM_CLK_POL' value='0'></entry>
    <entry name='SPC_DIGRF_INV_CLK_POL' value='1'></entry>
</enum>

<enum name='SPC_DIGRF_OVERSAMP'>
    <entry name='SPC_DIGRF_1_SAMPLE_PER_SYMB' value='0'></entry>
    <entry name='SPC_DIGRF_2_SAMPLE_PER_SYMB' value='1'></entry>
</enum>

<enum name='SPC_DIGRF_TX_MODE'>
    <entry name='SPC_DIGRF_TX_STREAM' value='0'></entry>
    <entry name='SPC_DIGRF_TX_BLOCK' value='1'></entry>
</enum>

<enum name='SPC_DIGRF_RX_SAMPLE_ALIGNMENT'>
    <entry name='SPC_DIGRF_SAMPLE_ALIGN_MSB' value='0'></entry>
    <entry name='SPC_DIGRF_SAMPLE_ALIGN_LSB' value='1'></entry>
</enum>

<enum name='SPC_DCOC_MODE'>
    <entry name='SPC_NO_DCOC' value='0'></entry>
    <entry name='SPC_HW_DCOC_ENABLED' value='1'></entry>
    <entry name='SPC_SW_DCOC_ENABLED' value='2'></entry>
</enum>

<typedef name='SPC_MBOX_SPEECH_ENC_OUT'>
    <comment>Structure used to configure VOC frame encode</comment>

    <uint16 name='encMode'>
        <comment>Mode of the voice coded output frame</comment>
    </uint16>
    <uint16 name='encFrameType'>
        <comment>Type of the coded output frame (AMR only)</comment>
    </uint16>
    <uint16 name='echoSkipEncFrame'>
        <comment>Flag for skipping the encoded frame, only valid when the ES is activated (replaces the unused VAD flag)</comment>
    </uint16>
    <uint16 name='sp'>
        <comment>Speech flag (all except AMR)</comment>
    </uint16>
    <uint16 name='encOutBuf' count='MBOX_MAX_SPEECH_FRAME_SIZE'>
        <comment>Encoder output buffer (coded frame in enc_mode)</comment>
    </uint16>
</typedef>

<typedef name='SPC_MBOX_SPEECH_DEC_IN'>
    <comment>Structure used to configure VOC frame decode</comment>

    <uint16 name='dtxOn'>
        <comment>DTX allowed by the network, active-&amp;gt;1</comment>
    </uint16>
    <uint16 name='codecMode'>
        <comment>mode of the next encoder speech frame output  and the current decoder speech frame input</comment>
    </uint16>
    <uint16 name='decFrameType'>
        <comment>Type of the coded input frame (AMR only)</comment>
    </uint16>
    <uint16 name='bfi'>
        <comment>BFI flag (all vocoders except AMR)</comment>
    </uint16>
    <uint16 name='sid'>
        <comment>SID flag (all vocoders except AMR)</comment>
    </uint16>
    <uint16 name='taf'>
        <comment>TAF flag (all vocoders except AMR)</comment>
    </uint16>
    <uint16 name='ufi'>
        <comment>UFI flag (HR only)</comment>
    </uint16>
    <uint16 name='reserved'>
        <comment>reserved (for alignment)</comment>
    </uint16>
    <uint16 name='decInBuf' count='MBOX_MAX_SPEECH_FRAME_SIZE'>
        <comment>Decoder input buffer (coded frame in dec_mode)</comment>
    </uint16>
</typedef>

<typedef name='SPC_MBOX_FCCH_RESULT'>
    <comment>Result structure used for the frequency burst search  the BCPU writes it when the FB has been found or when the  reception window is over.</comment>

    <uint16 name='fof'>
        <comment>frequency offset</comment>
    </uint16>
    <int16 name='tof'>
        <comment>timing offset</comment>
    </int16>
    <bool name='valid'>
        <comment>indicates if FCCH has been found</comment>
    </bool>
</typedef>

<typedef name='SPC_MBOX_SCH_RESULT'>
    <comment>Result structure used for the synchronization burst reception  the BCPU writes it after the SB has been processed.</comment>

    <uint16 name='snr'>
        <comment>signal to noise ratio in dB</comment>
    </uint16>
    <int16 name='fof'>
        <comment>frequency offset computed on the burst</comment>
    </int16>
    <uint8 name='data' count='MBOX_SCH_DATA_BYTE_QTY'>
        <comment>data of the synchro burst</comment>
    </uint8>
    <bool name='valid'>
        <comment>indicates if the SCH has been decoded correctly</comment>
    </bool>
    <int8 name='tof'>
        <comment>timing offset</comment>
    </int8>
    <uint8 name='power'>
        <comment>power computed on the burst</comment>
    </uint8>
</typedef>

<typedef name='SPC_MBOX_MON_RESULT'>
    <comment>Result structure used for monitoring and interference windows</comment>

    <uint8 name='power'></uint8>
</typedef>

<typedef name='SPC_MBOX_NBLOCK_RESULT'>
    <comment>Result structure used for block decoding  when the BCPU has received enough bursts  it decodes a block and writes related  results</comment>

    <ptr name='data' type='uint8' count='MBOX_NBURST_DATA_QTY'>
        <comment>pointer on decoded data</comment>
    </ptr>
    <uint16 name='bitError'>
        <comment>number of corrected bit in the block</comment>
    </uint16>
    <uint16 name='bitTotal'>
        <comment>number of protected bit in the block</comment>
    </uint16>
    <uint8 name='meanBep'>
        <comment>bit error probability on the block</comment>
    </uint8>
    <uint8 name='cvBep'>
        <comment>coefficient of variance of meanBep</comment>
    </uint8>
    <uint8 name='bfi'>
        <comment>bad frame indicator</comment>
    </uint8>
    <uint8 name='cs'>
        <comment>decoded coding scheme in GPRS</comment>
    </uint8>
    <uint8 name='sid'>
        <comment>indicates the silence frame detection</comment>
    </uint8>
    <uint8 name='irBufOvfl'>
        <comment>indicates when IR buffer is in overflow</comment>
    </uint8>
</typedef>

<typedef name='SPC_MBOX_NBURST_RESULT'>
    <comment>Result structure used for normal burst reception</comment>

    <int16 name='dco_I'>
        <comment>DC offset on I samples</comment>
    </int16>
    <int16 name='dco_Q'>
        <comment>DC offset on Q samples</comment>
    </int16>
    <int16 name='fof'>
        <comment>frequency offset measured on the burst</comment>
    </int16>
    <int8 name='tof'>
        <comment>timing offset</comment>
    </int8>
    <uint8 name='snr'>
        <comment>signal to noise ratio in dB</comment>
    </uint8>
    <uint8 name='pwr'>
        <comment>power measured on the burst</comment>
    </uint8>
    <uint8 name='sid'>
        <comment>indicates if the burst belongs to a silence frame</comment>
    </uint8>
</typedef>

<typedef name='SPC_MBOX_WIN_SPC_TO_PAL_RX'>
    <comment>Structure used for burst related Rx results from SPC to PAL</comment>

    <instance name='burstRes' type='SPC_MBOX_NBURST_RESULT'>
        <comment>Used for normal burst reception results</comment>
    </instance>
    <instance name='monRes' type='SPC_MBOX_MON_RESULT' count='MBOX_INTRF_SLOT_QTY'>
        <comment>Used for both multiple Monitoring windows and Interference window</comment>
    </instance>
</typedef>

<typedef name='SPC_MBOX_WIN_SPC_TO_PAL'>
    <comment>Structure defined only to have the same organization as for PAL to SPC</comment>

    <instance name='rx' type='SPC_MBOX_WIN_SPC_TO_PAL_RX'></instance>
</typedef>

<typedef name='SPC_MBOX_STATIC_SPC_TO_PAL_RX'>
    <comment>Structure used for block related Rx results from SPC to PAL</comment>

    <instance name='fcch' type='SPC_MBOX_FCCH_RESULT'>
        <comment>fcch results structure</comment>
    </instance>
    <instance name='sch' type='SPC_MBOX_SCH_RESULT' count='MBOX_SCH_QTY'>
        <comment>sch results structure</comment>
    </instance>
    <instance name='nBlock' type='SPC_MBOX_NBLOCK_RESULT' count='MBOX_MAX_BUF_IDX_QTY'>
        <comment>normal block results structure</comment>
    </instance>
    <uint8 name='decodedUsf' count='MBOX_MAX_TS_QTY'>
        <comment>array of decoded USF in GPRS</comment>
    </uint8>
</typedef>

<typedef name='SPC_MBOX_STATIC_SPC_TO_PAL'>
    <comment>Structure defined only to have the same organization as for PAL to SPC</comment>

    <instance name='rx' type='SPC_MBOX_STATIC_SPC_TO_PAL_RX'></instance>
</typedef>

<typedef name='SPC_MBOX_SPC_TO_PAL'>
    <comment>main structure for SPC to PAL</comment>

    <instance name='win' type='SPC_MBOX_WIN_SPC_TO_PAL' count='MBOX_CTX_SNAP_QTY'>
        <comment>window related results</comment>
    </instance>
    <instance name='statWin' type='SPC_MBOX_STATIC_SPC_TO_PAL'>
        <comment>block related results</comment>
    </instance>
    <instance name='speechDecIn' type='SPC_MBOX_SPEECH_DEC_IN'>
        <comment>decoding structure for VOC</comment>
    </instance>
    <ptr name='encBuff' type='uint8' count='MBOX_MAX_BUF_IDX_QTY+1'>
        <comment>array of pointer given by SPC to store the data to encode  +1 for CSD block to encode</comment>
    </ptr>
    <bool name='dtxUsed'>
        <comment>used by SPC to warn PAL that DTX uplink has been used</comment>
    </bool>
    <uint32 name='debug' count='13'>
        <comment>debug for BCPU</comment>
    </uint32>
</typedef>

<typedef name='SPC_MBOX_AMR_CFG'>
    <comment>Structure used for the AMR management, it contains all the configuration  parameters relative to the AMR modes and link adaptation.  The XCPU writes it at init but can also read it to retrieve the last  AMR configuration.</comment>

    <uint8 name='version'></uint8>
    <uint8 name='noiseSuppression'></uint8>
    <uint8 name='startModeIdx'></uint8>
    <uint8 name='nbActiveCodecSet'></uint8>
    <uint8 name='activeCodecSet' count='4'></uint8>
    <uint8 name='hysteresis' count='3'></uint8>
    <uint8 name='threshold' count='3'></uint8>
    <uint8 name='CMIPhase'></uint8>
</typedef>

<typedef name='SPC_MBOX_RX_NBURST'>
    <comment>Structure used by PAL to parameter a Rx window</comment>

    <uint8 name='bufIdx'>
        <comment>buffer index of the normal burst (from 0 to 4)</comment>
    </uint8>
    <uint8 name='bstIdx'>
        <comment>burst index of the burst (from 0 to 3)</comment>
    </uint8>
    <uint8 name='tsc'>
        <comment>color of the training sequence</comment>
    </uint8>
    <uint8 name='bitMap'>
        <comment>indicates which slots are used in the RX window</comment>
    </uint8>
</typedef>

<typedef name='SPC_MBOX_STATWIN_RX_CFG'>
    <comment>Structure used to describe the logical channel associated with a Rx buffer  index and to indicate wether a decoding interruption is asked or not.</comment>

    <uint8 name='type'>
        <comment>logical channel type</comment>
    </uint8>
    <uint8 name='itr'>
        <comment>indicates if the decoding interruption is requested by PAL</comment>
    </uint8>
    <uint8 name='egprs'>
        <comment>indicates which EGPRS mode is used: 0-> not egprs, 1->egprs with IR, 2-> egprs without IR</comment>
    </uint8>
</typedef>

<typedef name='SPC_MBOX_WIN_TX_ACCESS_ENC'>
    <comment>Structure dedicated to AB encoding</comment>

    <uint16 name='data'>
        <comment>data to encode</comment>
    </uint16>
    <uint8 name='bsic'>
        <comment>base transceiver station identity code</comment>
    </uint8>
    <uint8 name='size'>
        <comment>size of the data in bits</comment>
    </uint8>
</typedef>

<typedef name='SPC_MBOX_STATWIN_TX_CTX'>
    <comment>Structure used to describe the logical channel and coding scheme in case  of GPRS associated with a Tx buffer index and also to indicates if the  data have been encoded or not.</comment>

    <uint8 name='type'>
        <comment>logical channel type associated with a buffer index</comment>
    </uint8>
    <uint8 name='encDone'>
        <comment>set by PAL to ask for encoding of the block and reset  by SPC when encoding has been done</comment>
    </uint8>
    <uint8 name='cs'>
        <comment>block coding scheme in GPRS</comment>
    </uint8>
</typedef>

<typedef name='SPC_MBOX_WIN_PAL_TO_SPC_TX'>
    <comment>Structure used for windows emission programming</comment>

    <uint8 name='routeMap' count='MBOX_MAX_TS_QTY'>
        <comment>this array gives the buffer indexes associated with the slots  in the Tx window (it contains more than one usefull value  only in case of GPRS multislot window)</comment>
    </uint8>
    <uint8 name='winIdx'>
        <comment>index of the Tx window in the frame</comment>
    </uint8>
    <uint8 name='bstIdx'>
        <comment>burst index (from 0 to 3)</comment>
    </uint8>
    <uint8 name='tsc'>
        <comment>training sequence color</comment>
    </uint8>
    <uint8 name='qty'>
        <comment>number of programmed Tx windows</comment>
    </uint8>
    <uint8 name='bitMap'>
        <comment>indicates which slots are used in the Tx window</comment>
    </uint8>
    <bool name='swapIQ'>
        <comment>indicates if I and Q have to be swapped</comment>
    </bool>
</typedef>

<typedef name='SPC_MBOX_WIN_PAL_TO_SPC_RX'>
    <comment>Structure used for window related Rx parameters, from PAL to SPC</comment>

    <uint8 name='qty'>
        <comment>number of programmed Rx window</comment>
    </uint8>
    <uint8 name='rxTypeWin' count='MBOX_WINDOWS_QTY'>
        <comment>type of the Rx window (FB, SB, NB or monitoring)  only one FB window can be programmed per TDMA frame  only one SB window can be programmed per TDMA frame  only one NB window can be programmed per TDMA frame</comment>
    </uint8>
    <uint8 name='monWinIdx' count='MBOX_WINDOWS_QTY'>
        <comment>index of the programmed monitoring windows  used for both monitoring and interference windows</comment>
    </uint8>
    <instance name='nBurst' type='SPC_MBOX_RX_NBURST'>
        <comment>parameters of the programmed NB Rx window</comment>
    </instance>
    <bool name='swapIQ' count='MBOX_WINDOWS_QTY'>
        <comment>indicates for each Rx window if I and Q have to be swapped</comment>
    </bool>
</typedef>

<typedef name='SPC_MBOX_WIN_PAL_TO_SPC'>
    <comment>Structure all window related from PAL to SPC</comment>

    <instance name='tx' type='SPC_MBOX_WIN_PAL_TO_SPC_TX'></instance>
    <instance name='rx' type='SPC_MBOX_WIN_PAL_TO_SPC_RX'></instance>
</typedef>

<typedef name='SPC_MBOX_STATIC_PAL_TO_SPC_TX'>
    <comment>Structure used for blocks related Tx parameters, from PAL to SPC</comment>

    <instance name='enc' type='SPC_MBOX_WIN_TX_ACCESS_ENC'></instance>
    <instance name='ctx' type='SPC_MBOX_STATWIN_TX_CTX' count='MBOX_MAX_BUF_IDX_QTY'></instance>
</typedef>

<typedef name='SPC_MBOX_STATIC_PAL_TO_SPC_RX'>
    <comment>Structure used for blocks related Rx parameters, from PAL to SPC</comment>

    <instance name='cfg' type='SPC_MBOX_STATWIN_RX_CFG' count='MBOX_MAX_BUF_IDX_QTY'></instance>
</typedef>

<typedef name='SPC_MBOX_STATIC_PAL_TO_SPC_DEDICATED'>
    <comment>Structure concerning the current dedicated TCH</comment>

    <instance name='AMRCfg' type='SPC_MBOX_AMR_CFG'>
        <comment>AMR configuration</comment>
    </instance>
    <uint8 name='changedAMRCfg'>
        <comment>indicates if the AMR configuration has been modified by PAL</comment>
    </uint8>
    <uint8 name='mode'>
        <comment>current mode of the TCH as defined in PAL interface</comment>
    </uint8>
    <bool name='active'>
        <comment>indicates if the TCH is started or stopped (respectively 1 and 0)</comment>
    </bool>
    <bool name='initTch'>
        <comment>indicates if the parameters of the TCH has to be reinitialized</comment>
    </bool>
</typedef>

<typedef name='SPC_MBOX_STATIC_PAL_TO_SPC'>
    <comment>Structure used for blocks related parameters, from PAL to SPC</comment>

    <instance name='tx' type='SPC_MBOX_STATIC_PAL_TO_SPC_TX'></instance>
    <instance name='rx' type='SPC_MBOX_STATIC_PAL_TO_SPC_RX'></instance>
    <instance name='dedicated' type='SPC_MBOX_STATIC_PAL_TO_SPC_DEDICATED'></instance>
    <uint8 name='loopMode'>
        <comment>mode for test loop see 3GPP 44.014 for more details</comment>
    </uint8>
    <uint8 name='ciphMode'>
        <comment>mode of ciphering if enabled</comment>
    </uint8>
</typedef>

<typedef name='SPC_MBOX_GSM_COUNTERS'>
    <comment>Structure used to store GSM TDMA frame counters</comment>

    <uint16 name='T1'></uint16>
    <uint8 name='T2'></uint8>
    <uint8 name='T3'></uint8>
</typedef>

<typedef name='SPC_MBOX_TX_BURST_MAPPING_PARAMS'>
    <uint8 name='preamble'></uint8>
    <uint8 name='guardStart'></uint8>
    <uint8 name='postamble'></uint8>
</typedef>

<typedef name='SPC_MBOX_RF_PARAMS'>
    <comment>Structure containing all RF-control related parameters</comment>

    <uint32 name='dtxTcoSettings'>
        <comment>settings for TCO during DTX uplink</comment>
    </uint32>
    <bool name='digrfEnable'>
        <comment>DigRf settings</comment>
    </bool>
    <uint8 name='digrfRxRate'></uint8>
    <uint8 name='digrfRxSampleWidth'></uint8>
    <uint8 name='digrfRxSampleAlign'></uint8>
    <uint8 name='digrfRxClkPol'></uint8>
    <uint8 name='digrfTxMode'></uint8>
    <uint8 name='digrfTxClkPol'></uint8>
    <instance name='txBstMap' type='SPC_MBOX_TX_BURST_MAPPING_PARAMS'></instance>
    <bool name='dcoCalEnable'>
        <comment>Enable Automatic DC Offset calibration mechanism</comment>
    </bool>
</typedef>

<typedef name='SPC_MBOX_PAL_TO_SPC'>
    <comment>main Structure for PAL to SPC</comment>

    <instance name='win' type='SPC_MBOX_WIN_PAL_TO_SPC' count='MBOX_CTX_SNAP_QTY'>
        <comment>window related programmations</comment>
    </instance>
    <instance name='statWin' type='SPC_MBOX_STATIC_PAL_TO_SPC'>
        <comment>block related programmations</comment>
    </instance>
    <instance name='counters' type='SPC_MBOX_GSM_COUNTERS' count='MBOX_CTX_SNAP_QTY'>
        <comment>GSM TDMA counter</comment>
    </instance>
    <instance name='speechEncOut' type='SPC_MBOX_SPEECH_ENC_OUT'>
        <comment>encoding structure comming from VOC</comment>
    </instance>
    <bool name='dtxAllowed'>
        <comment>indicates to SPC if the DTX uplink is allowed for the current TCH</comment>
    </bool>
    <instance name='rf' type='SPC_MBOX_RF_PARAMS'>
        <comment>RF parameters</comment>
    </instance>
</typedef>

<enum name='SPC_MBOX_DBG_REQ'>
    <comment>The debug mechanism is "block based" i.e. it allows  to dump samples (or use external ones) on 4 consecutives  bursts constituting a block.  Debug requests must be done through PAL, which is handling  the frame based mechanism.</comment>

    <entry name='MBOX_DBG_EXT_SAMPLES' value='0x1'></entry>
    <entry name='MBOX_DBG_REC_SAMPLES' value='0x2'></entry>
    <entry name='MBOX_DBG_REC_REF' value='0x4'></entry>
    <entry name='MBOX_DBG_REC_TAPS' value='0x8'></entry>
    <entry name='MBOX_DBG_BST_PARAM' value='0x10'></entry>
</enum>

<typedef name='SPC_MBOX_DEBUG'>
    <ptr name='ext_samples' type='uint32'></ptr>
    <ptr name='samples' type='uint32'></ptr>
    <ptr name='ref' type='uint32'></ptr>
    <ptr name='taps' type='uint32'></ptr>
    <uint32 name='req'></uint32>
</typedef>

<typedef name='SPC_MBX_EXT_SPC_TO_PAL'>
    <comment>Structure used for extra windows, from PAL to SPC</comment>
    <instance name='rxwin' type='SPC_MBOX_WIN_SPC_TO_PAL_RX' count='MBOX_CTX_SNAP_QTY'>
        <comment>window related programmations</comment>
    </instance>
</typedef>

<typedef name='SPC_MBX_EXT_PAL_TO_SPC'>
    <comment>Structure used for extra windows, from SPC to PAL</comment>
    <instance name='rxwin' type='SPC_MBOX_WIN_PAL_TO_SPC_RX' count='MBOX_CTX_SNAP_QTY'>
        <comment>window related results</comment>
    </instance>
</typedef>

<typedef name='SPC_MBX_EXT'>
    <comment>Structure used for extra windows</comment>
    <instance name='spc2pal' type='SPC_MBX_EXT_SPC_TO_PAL'>
        <comment>structure used to program BCPU and give context parameters values</comment>
    </instance>
    <instance name='pal2spc' type='SPC_MBX_EXT_PAL_TO_SPC'>
        <comment>structure used to exchange BCPU processing results</comment>
    </instance>
</typedef>


<typedef name='SPC_MAILBOX'>
    <comment>The main structure which gathers the three different parts  of the mailbox.</comment>

    <instance name='pal2spc' type='SPC_MBOX_PAL_TO_SPC'>
        <comment>structure used to program BCPU and give context parameters values</comment>
    </instance>
    <instance name='spc2pal' type='SPC_MBOX_SPC_TO_PAL'>
        <comment>structure used to exchange BCPU processing results</comment>
    </instance>
    <ptr name='extRef' type='SPC_MBX_EXT_T'>
    <comment>external reference for extra windows</comment>
    </ptr>
    <uint32 name='rxOnTcoSettings'></uint32>
    <uint16 name='dummyPchResult'></uint16>
    <uint16 name='dummyPchThresh'></uint16>
    <instance name='dbg' type='SPC_MBOX_DEBUG' count='MBOX_CTX_SNAP_QTY'>
        <comment>#ifdef __MBOX_DEBUG__  This is used by the embedded debug stub</comment>
    </instance>
    <uint32 name='palDbgReq'></uint32>
    <uint32 name='palDbgAck'></uint32>
</typedef>

<cjoker>
/// g_mailbox is a global variable of type SPC_MAILBOX_T which is used
extern volatile SPC_MAILBOX_T g_mailbox;


// =============================================================================
// bcpu_main
// -----------------------------------------------------------------------------
/// BCPU main function.
// =============================================================================
PUBLIC EXPORT VOID bcpu_main(VOID);


/// @}
</cjoker>

</archive>

<archive relative='../../../platform/chip/bcpu/include/spc_mailbox.xmd'  asm="no">


<comment>
@file spc_mailbox.h<br/>
This File contains SPC API selection, between GSM and Edge.<br/>
<br/>
@author Coolsand Technologies, Inc.<br/>
@version 1.0<br/>
@date january 2008<br/>
<br/>
- @ref spc2pal "SPC to PAL structures " \n<br/>
- @ref pal2spc "PAL to SPC structures " \n<br/>
- @ref mbox "main mailbox structure" \n<br/>
<br/>
</comment>

<include>
    <comment>Mailbox definition selection, depending on the chip.</comment>
    <case cond="(SPC_IF_VER == 0)" file="spc_mailbox_v0.xmd"/>
    <case cond="(SPC_IF_VER == 1)" file="spc_mailbox_v1.xmd"/>
    <case cond="(SPC_IF_VER == 2)" file="spc_mailbox_v2.xmd"/>
    <case cond="(SPC_IF_VER == 3)" file="spc_mailbox_v3.xmd"/>
    <case cond="(SPC_IF_VER == 4)" file="spc_mailbox_v4.xmd"/>
    <default file="spc_mailbox_std.xmd"/>
</include>

</archive>

<archive relative='../../../platform/chip/bcpu/spc/include/spc_define_std.xmd'  asm="no">


<comment>
Contains defines for spc.xmd
</comment>

<alias name='SPC_PDCH_DATA_BLOCK'>
    <uint32 name='unused' count='14'>
        <comment>Global Context Structure</comment>
    </uint32>
</alias>

<var name='SPC_ITLV_BUFF_TX_DEDICATED' value='22*4'></var>

<var name='SPC_ITLV_BUFF_RX_DEDICATED' value='22*32'></var>

<var name='SPC_ITLV_RX_BUFF_OFFSET' value='128'>
</var>

<var name='SPC_ITLV_TX_BUFF_OFFSET' value='4*4'>
</var>

<var name='SPC_TMP_ITLV_RX_BUFF_OFFSET' value='5*128'>
</var>

<var name='SPC_PDCH_DATA_BLOCK_SIZE' value='14'>
</var>

<var name='GMSK_BLK_EQOUT_SIZE' value='32'>
</var>
</archive>

<archive relative='../../../platform/chip/bcpu/spc/include/spc_ctx_v3.xmd'  asm="no">


<comment>
Contains stuctures and function definitions for SPC use.
</comment>

<include load="no" file="cs_types.h"/>
<include load="no" file="spp_m.h"/>

<include>
    <comment>different buffers sizes whether EDGE is supported or not.</comment>
    <case cond="(CHIP_EDGE_SUPPORTED == 1)" file="spc_define_edge.xmd"/>
    <default file="spc_define_std.xmd"/>
</include>

<include file="../../../../base/common/include/baseband_defs.xmd"/>
<include file="../../include/spc_mailbox.xmd"/>
<include file="../../spp/include/spp_gsm.xmd"/>

<var name='SCH_BUF_OFFSET' value='(BB_BURST_TOTAL_SIZE*4)'>
    <comment>SCH symbol buffer offset (aVOID overwriting during late SCH windows)</comment>
</var>

<var name='SPC_ITLV_BUFF_TX_FACCH' value='(8*4)'>
    <comment>Interleaver Buffer sizes</comment>
</var>

<var name='SPC_ITLV_BUFF_TX_CTRL' value='(4*4)'><comment>4burst*4word*4bytes</comment></var>

<var name='SPC_ITLV_BUFF_RX_CTRL' value='(4*32)'></var>

<var name='SPC_ITLV_BUFF_SIZE' value='SPC_ITLV_BUFF_TX_FACCH + SPC_ITLV_BUFF_TX_CTRL + SPC_ITLV_BUFF_TX_DEDICATED + SPC_ITLV_BUFF_RX_CTRL + SPC_ITLV_BUFF_RX_DEDICATED'></var>

<var name='SPC_STATIC_BUF_SIZE' value='4*BB_BURST_TOTAL_SIZE + 6*MBOX_MON_WIN_SIZE'></var>

<typedef name='SPC_ITLV_BUFFERS'>
    <comment>Interleaver Buffer Structure</comment>

    <uint32 name='RxCtrl' count='SPC_ITLV_BUFF_RX_CTRL'></uint32>
    <uint32 name='RxDedicated' count='SPC_ITLV_BUFF_RX_DEDICATED'></uint32>
    <uint32 name='TxCtrl' count='SPC_ITLV_BUFF_TX_CTRL'></uint32>
    <uint32 name='TxDedicated' count='SPC_ITLV_BUFF_TX_DEDICATED'></uint32>
    <uint32 name='TxFacch' count='SPC_ITLV_BUFF_TX_FACCH'></uint32>
</typedef>

<typedef name='SPC_STATIC_BUFFERS'>
    <comment>Overall structure : Rx (Ifc)Buffer + Vitac Buffers</comment>

    <uint32 name='RxIfcBuffer' count='4*(BB_BURST_ACTIVE_SIZE+2*BB_RX_NBURST_MARGIN)'></uint32>
    <uint32 name='MonIfcBuffer' count='6*MBOX_MON_WIN_SIZE'></uint32>
</typedef>

<alias name='SPC_DATA_BLOCK'>
    <uint32 name='unused' count='14'>
        <comment>Global Context Structure</comment>
    </uint32>
</alias>

<typedef name='SPC_TX_SPEECH'>
    <ptr name='InputBuffer' type='uint32'></ptr>
    <uint16 name='CodecModeInd'></uint16>
    <uint8 name='TxFrameType'></uint8>
</typedef>

<typedef name='SPC_RX_LOCALS'>
    <comment>structure for local rx variables</comment>

    <ptr name='ItlvBuffInput' type='uint32'></ptr>
    <ptr name='BlockDecodedAdd' type='uint32'></ptr>
    <uint16 name='Copy_ChMode'></uint16>
    <uint8 name='burstIdx'></uint8>
    <uint8 name='buffIdx'></uint8>
    <uint8 name='slotIdx'></uint8>
    <uint8 name='RxBuffOffset'></uint8>
    <uint8 name='itlv_mode'></uint8>
    <uint8 name='StealingResult'></uint8>
    <uint8 name='voc_bfi'></uint8>
    <uint8 name='voc_sid'></uint8>
    <uint8 name='voc_taf'></uint8>
    <uint8 name='voc_ufi'></uint8>
    <uint8 name='RxFrameType'></uint8>
    <uint8 name='RX_decode'></uint8>
</typedef>

<alias name='SPC_8UINT8'>
    <uint8 name='unused' count='8'>
        <comment>type used to avoid bugs in the matrix</comment>
    </uint8>
</alias>

<typedef name='SPC_CONTEXT'>
    <comment>Global structure of Context statically placed in BB_SRAM  Should be referenced by a pointer placed in a reserved register  to ease address calculation and reduce code size.</comment>

    <instance name='FCCH_Result' type='SPP_FCCH_RESULT'></instance>
    <instance name='SCH_Result' type='SPP_SCH_RESULT'></instance>
    <instance name='NBurst_result' type='SPP_N_BURST_RESULT'></instance>
    <instance name='NBlock_result' type='SPP_N_BLOCK_RESULT'></instance>
    <instance name='Header_result' type='SPP_HEADER_RESULT'></instance>
    <instance name='AMR_Cfg_Tx' type='SPP_AMR_CFG'></instance>
    <instance name='AMR_Cfg_Rx' type='SPP_AMR_CFG'></instance>
    <uint32 name='Rx_Hu_TCH_N_1'></uint32>
    <uint32 name='Rx_Hu_TCH_N'></uint32>
    <uint32 name='Rx_Hl_TCH_N'></uint32>
    <uint32 name='ABurstBuffer' count='5'>
        <comment>Tx buffers</comment>
    </uint32>
    <instance name='CSD_NBlockDataIn' type='SPC_DATA_BLOCK'></instance>
    <instance name='CCH_NBlockDataIn' type='SPC_DATA_BLOCK'></instance>
    <instance name='DCH_NBlockDataIn' type='SPC_PDCH_DATA_BLOCK' count='MBOX_MAX_BUF_IDX_QTY-1'></instance>
    <ptr name='NBlockDataIn' type='uint32' count='MBOX_MAX_BUF_IDX_QTY+1'></ptr>
    <instance name='speechEncOut' type='SPC_MBOX_SPEECH_ENC_OUT'>
        <comment>Rx buffers</comment>
    </instance>
    <instance name='CSD_NBlockDataOut' type='SPC_DATA_BLOCK'></instance>
    <instance name='CCH_NBlockDataOut' type='SPC_DATA_BLOCK'></instance>
    <instance name='DCH_NBlockDataOut' type='SPC_PDCH_DATA_BLOCK' count='MBOX_MAX_BUF_IDX_QTY-1'></instance>
    <ptr name='NBlockDataOut' type='uint32' count='MBOX_MAX_BUF_IDX_QTY+1'></ptr>
    <ptr name='ItlvBufRxCtrl' type='uint32'>
        <comment>interleaver input buffer pointers</comment>
    </ptr>
    <ptr name='ItlvBufRxDedicated' type='uint32'></ptr>
    <ptr name='ItlvBufTxCtrl' type='uint32'></ptr>
    <ptr name='ItlvBufTxDedicated' type='uint32'></ptr>
    <ptr name='ItlvBufTxFacch' type='uint32'></ptr>
    <ptr name='Malloc' type='uint32' ckeywords='VOLATILE'>
        <comment>interleaver output buffer</comment>
    </ptr>
    <ptr name='ItlvBufRxFacch' type='uint32'>
        <comment>next address must be aligned on 128 bytes</comment>
    </ptr>
    <ptr name='loopC_buffer' type='uint8'></ptr>
    <ptr name='CIest' type='int8'></ptr>
    <uint32 name='BaseAddress'></uint32>
    <uint16 name='FCCH_Offset'></uint16>
    <uint16 name='ChMode'></uint16>
    <uint16 name='PrevChMode'></uint16>
    <bool name='DedicatedActive'></bool>
    <instance name='statWinRxCfg' type='SPC_MBOX_STATWIN_RX_CFG' count='MBOX_MAX_BUF_IDX_QTY'></instance>
    <bool name='Tx_off'></bool>
    <bool name='Init_FCCH'></bool>
    <int16 name='BlockSnR'></int16>
    <int16 name='LastBlockSnR'></int16>
    <instance name='Rx_q_CCH' type='SPC_8UINT8' count='4'></instance>
    <uint8 name='Rx_CS' count='4'>
        <comment>Was UINT8 Rx_q_CCH[4][8];, but coolXml has its own ...</comment>
    </uint8>
    <uint8 name='BurstNb'></uint8>
    <uint8 name='currentSnap'></uint8>
    <uint8 name='TxBlockOffset'></uint8>
    <uint8 name='RxBlockOffset'></uint8>
    <uint8 name='cs_identifier' count='4'></uint8>
    <uint8 name='Tx_Hu'></uint8>
    <uint8 name='Tx_Hl'></uint8>
    <uint8 name='FacchEncoded'></uint8>
    <uint8 name='DTX_on'></uint8>
    <uint32 name='RfIfCtrl'></uint32>
    <bool name='DCOC_on'></bool>
    <uint8 name='FcchFound'></uint8>
    <uint8 name='txQty'></uint8>
    <uint8 name='rxQty'></uint8>
    <uint8 name='Taf_Flag'></uint8>
    <uint8 name='DTX_dwnlk_flag'></uint8>
    <uint8 name='DTX_dwnlk_count'></uint8>
    <uint8 name='BFI_count'></uint8>
    <uint8 name='sendEqItr'></uint8>
    <uint8 name='resIdx'></uint8>
    <uint8 name='frame_over'></uint8>
    <uint8 name='loop_bufIdx'></uint8>
    <uint8 name='CodecModeRequest'></uint8>
    <uint8 name='ratscch_to_encode'></uint8>
    <uint8 name='ACK_Activation'></uint8>
    <uint8 name='REQ_Activation'></uint8>
    <uint8 name='RATSCCH_REQ'></uint8>
    <uint8 name='ratscch_detected'></uint8>
    <uint8 name='sidupdate_ctr'></uint8>
    <uint8 name='AFNmod104'></uint8>
    <int16 name='FacchThreshold'>
        <comment>old defines moved to variables for romming purpose</comment>
    </int16>
    <uint8 name='FR_BfiThreshold'></uint8>
    <uint8 name='EFR_BfiThreshold'></uint8>
    <uint8 name='HR_BfiThreshold'></uint8>
    <uint8 name='UfiThreshold'></uint8>
    <uint8 name='FsBfiBerThresh'></uint8>
    <uint8 name='FsBfiBer2Thresh'></uint8>
    <int8 name='FsBfiSnrThresh'></int8>
    <uint8 name='HsBfiBerThresh'></uint8>
    <uint8 name='HsBfiBer2Thresh'></uint8>
    <int8 name='HsBfiSnrThresh'></int8>
    <uint8 name='AFS_ber1_threshold' count='8'></uint8>
    <uint8 name='AHS_ber1_threshold' count='6'></uint8>
    <uint8 name='AFS_ber2_threshold' count='8'></uint8>
    <uint8 name='AHS_ber2_threshold' count='6'></uint8>

    <bool name='equ_hburst_mode' ckeywords='VOLATILE'></bool>
    <bool name='ifc2_burst_mode_fcch' ckeywords='VOLATILE'></bool>
    <bool name='ifc2_burst_mode_sbnb' ckeywords='VOLATILE'></bool>

    <uint32 name='bcpuIrqCause' ckeywords='VOLATILE'>
        <comment>extern volatile UINT32 bb_irq_cause;</comment>
    </uint32>
    <uint8 name='MonWinSize' ckeywords='VOLATILE'></uint8>
    <uint8 name='FcchWinSize' ckeywords='VOLATILE'></uint8>
    <uint8 name='FcchPreOpening' ckeywords='VOLATILE'></uint8>
    <uint8 name='FcchInit' ckeywords='VOLATILE'></uint8>
    <uint8 name='FcchActive' ckeywords='VOLATILE'></uint8>
    <uint8 name='FcchSet' ckeywords='VOLATILE'></uint8>
    <uint8 name='rx_count' ckeywords='VOLATILE'></uint8>
    <uint8 name='sched_rx_count' ckeywords='VOLATILE'></uint8>
    <uint8 name='slot_count' ckeywords='VOLATILE'></uint8>
    <uint8 name='sched_slot_count' ckeywords='VOLATILE'></uint8>
    <uint8 name='ifc2_pending' ckeywords='VOLATILE'></uint8>
    <uint8 name='rxslotNb' ckeywords='VOLATILE'></uint8>
    <uint8 name='tx_left' ckeywords='VOLATILE'></uint8>
    <uint32 name='burst_to_send' ckeywords='VOLATILE' count='10'></uint32>
    <ptr name='SilentFrame' type='uint32' ckeywords='VOLATILE'></ptr>
    <uint32 name='voc_dtx_en' ckeywords='VOLATILE'>
        <comment>enable for DTX uplink</comment>
    </uint32>
    <uint32 name='TxCodecMode' ckeywords='VOLATILE'>
        <comment>AMR codec variables</comment>
    </uint32>
    <uint32 name='RxCodecMode' ckeywords='VOLATILE'></uint32>

    <instance name='tx_modulation' type='SPP_MODULATION_TYPE'>
        <comment>used for EGPRS only</comment>
    </instance>
    <instance name='rx_modulation' type='SPP_MODULATION_TYPE'></instance>
    <instance name='tx_headertype' type='SPP_HEADER_TYPE' count='4'></instance>
    <instance name='rx_headertype' type='SPP_HEADER_TYPE' count='4'></instance>
    <instance name='curr_rx_headertype' type='SPP_HEADER_TYPE' count='4'></instance>
    <instance name='prev_rx_headertype' type='SPP_HEADER_TYPE' count='4'></instance>
    <uint8 name='egprs_rx_buffer_bmp'></uint8>

    <ptr name='schedulerHook' type='void' ckeywords='VOLATILE'>
        <comment>
            Pointer to a function called during the idle time of
            the BCPU scheduler.
        </comment>
    </ptr>
    <ptr name='irqHook' type='void' ckeywords='VOLATILE'>
        <comment>
            Pointer to a function called by the BCPU IRQ handler.
        </comment>
    </ptr>

    <uint32 name='dumpMask' ckeywords='VOLATILE'>
        <comment>
            Mask used to enable dump.
        </comment>
    </uint32>
    <ptr name='dumpPtr' type='void' ckeywords='VOLATILE'>
        <comment>
            Pointer to a dump function.
        </comment>
    </ptr>
    <ptr name='egprsIrBuffer' type='SPP_EGPRS_IR_BUF_T'>
        <comment>
            Pointer to the EGPRS IR buffer.
        </comment>
    </ptr>

</typedef>

<typedef name='SPC_CONTEXT_EXT_T'>
    <uint8 name='rxQty'></uint8>
    <uint8 name='frame_over'> </uint8>
    <uint8 name='rx_count' ckeywords='VOLATILE'></uint8>
    <uint8 name='sched_rx_count' ckeywords='VOLATILE'></uint8>
    <uint8 name='sched_slot_count' ckeywords='VOLATILE'></uint8>
    <uint8 name='rx_count_flag' ckeywords='VOLATILE'></uint8>
</typedef>

<cjoker>


register SPC_CONTEXT_T* g_spcCtx asm("$16");
EXPORT PROTECTED SPC_ITLV_BUFFERS_T g_spcItlvBufTab;
EXPORT PROTECTED SPC_STATIC_BUFFERS_T g_spcStaticBufTab;

</cjoker>
</archive>

<archive relative='../../../platform/chip/bcpu/spc/include/spc_ctx.xmd'  asm="no">


<comment>
@file spc.h<br/>
This File contains SPC context structures and enums.<br/>
<br/>
@author RDA Microelectronics.<br/>
@version 1.1<br/>
@date April 2014<br/>
<br/>
</comment>

<include>
    <comment> spc contex definition depending on
              the SPC interface version
    </comment>
    <case cond="(SPC_IF_VER == 0)" file="spc_ctx_v0.xmd"/>
    <case cond="(SPC_IF_VER == 1)" file="spc_ctx_v1.xmd"/>
    <case cond="(SPC_IF_VER == 2)" file="spc_ctx_v2.xmd"/>
    <case cond="(SPC_IF_VER == 3)" file="spc_ctx_v3.xmd"/>
    <case cond="(SPC_IF_VER == 4)" file="spc_ctx_v4.xmd"/>
    <case cond="(SPC_IF_VER == 5)" file="spc_ctx_v5.xmd"/>
    <case cond="(SPC_IF_VER == 6)" file="spc_ctx_v6.xmd"/>
    <default file="spc_ctx_std.xmd"/>
</include>

</archive>

<archive relative='../../../platform/chip/bcpu/spc/include/spc_map.xmd'  asm="no">

    <comment>
        This file contains the portion of SPC's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool).
    </comment>

    <include file="../../include/spc_mailbox.xmd"/>
    <include file="spc_ctx.xmd"/>

    
    <typedef name="SPC_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of SPC.
        </comment>
        <ptr type="SPC_MAILBOX" name="mailbox"/>
        <ptr type="SPC_CONTEXT" name="context"/>
    </typedef>

</archive>

<archive relative='../../../platform/edrv/rfd/include/rfd_map.xmd'  asm="no">


    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    


    


    
   <typedef name="RFD_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        
   </typedef>

<cjoker>

// =============================================================================
// rfd_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID rfd_RegisterYourself(VOID);

</cjoker>

</archive>

<archive relative='../../../platform/edrv/memd/include/memd_map.xmd'  asm="no">

    
    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    

    
    

    
    
   <typedef name="MEMD_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        
   </typedef>
   
   <cjoker>

// =============================================================================
// memd_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID memd_RegisterYourself(VOID);

    </cjoker>

</archive>

<archive relative='../../../platform/edrv/pmd/include/pmd_map.xmd'  asm="no">


    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    

    

    
    <var name="PMD_MAP_POWER_ID_QTY" value="14" />
    
    <var name="PMD_MAP_LEVEL_ID_QTY" value="10" />

    
    <typedef name="PMD_MAP_CHARGER_STATE_T">
        <uint32 name="status" />
        <uint32 name="current" />
        <ptr type="void" name="handler" />
        <uint16 name="batteryLevel" />
        <uint16 name="pulsedOnCount" />
        <uint16 name="pulsedOffCount" />
        <uint16 name="pulsedCycleCount" />
        <uint16 name="pulsedOnMeanCount" />
        <uint16 name="pulsedOffMeanCount" />
        <uint32 name="startTime" />
        <uint32 name="lastWTime" />
        <bool name="highActivityState" />
    </typedef>


    
    <typedef name="PMD_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        
        <uint32 name="powerInfo" count="PMD_MAP_POWER_ID_QTY" display="hex">
            <bits name="Power_Shared_Link_Flag" pos="31" access="r"/>
            <bits name="Power_Value" pos="30:0" access="r" display="hex">
                <comment>If Shared_Link_Flag = 0, Value bits represent resource used
                    <br/>If Shared_Link_Flag = 1, Value is the ID of the main resource
                </comment>
            </bits>
        </uint32>
        <uint32 name="levelInfo" count="PMD_MAP_LEVEL_ID_QTY">
            <comment>Current level value.
            </comment>
        </uint32>
        <ptr type="PMD_MAP_CHARGER_STATE_T" name="chargerState" />
    </typedef>

<cjoker>

// =============================================================================
// pmd_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID pmd_RegisterYourself(VOID);

</cjoker>

</archive>

<archive relative='../../../platform/edrv/lcdd/include/lcdd_map.xmd'  asm="no">

    
    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    

    
    

    
    
   <typedef name="LCDD_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        
   </typedef>
   
   <cjoker>

// =============================================================================
// lcdd_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID lcdd_RegisterYourself(VOID);

    </cjoker>

</archive>

<archive relative='../../../platform/stack/include/stack_map.xmd'  asm="no">

    
    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>

    

    

    <typedef name="stack_map_globals" rubyconstants="yes"></typedef>

    <var name='STACK_AUTO_CALL_VALID' value='0xadf1900d'>
        <comment>Validity pattern</comment>
    </var>
    
    <typedef name='STACK_AUTO_CALL_T'>
    	<uint32 name='validity'>
    	  <comment>valid if it equals STACK_AUTO_CALL_VALID</comment>
    	</uint32>
    	<uint32 name='flag'>
    	  <comment>auto call instruction bitset</comment>
    	</uint32>
    </typedef>
    
    <typedef  name="STACK_PROFILE_ON_BUFFER_T">
        <comment>This is used only when the code is compiled with STACK_PROFILE_ON_BUFFER_T in debug.
        </comment>
        <uint32     name="buffer_start" display="hex">
            <comment>
                pxts buffer start address
            </comment>
        </uint32>
        
        <uint32     name="buffer_pos" display="hex">
            <comment>
                pxts buffer current position
            </comment>
        </uint32>
        
        <uint32     name="buffer_size" display="hex">
            <comment>
                pxts buffer size
            </comment>
        </uint32>                
    </typedef>   
           
    
    <typedef name="STACK_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        
   		<ptr type="STACK_AUTO_CALL_T" name="autoCallStructPtr">
   		</ptr>
        <instance type="STACK_PROFILE_ON_BUFFER_T" name="ProfileOnBuffer"/>       		
    </typedef>
   
    <cjoker>

// =============================================================================
// stack_GetAutoCallStruct
// -----------------------------------------------------------------------------
/// This function get the auto call structure pointer from the map accessor.
// =============================================================================
PUBLIC STACK_AUTO_CALL_T* stack_GetAutoCallStruct(VOID);


// =============================================================================
// stack_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID stack_RegisterYourself(VOID);

    </cjoker>

</archive><archive relative='../../../platform/chip/boot/include/boot_map.xmd'  asm="no">


    <enum name="BOOT_MAIN_TAG">
        <comment>
            Magic tags used by the boot loader to switch between boot modes.
        </comment>
        <entry name="BOOT_MAIN_TAG_NORMAL"/>
        <entry name="BOOT_MAIN_TAG_BREAKBOOT" value="0xB4EAB007"/>
        <entry name="BOOT_MAIN_TAG_CALIB" value="0xCA1BCA1B"/>
    </enum>

    <enum name="BOOT_SECTOR_CMD_T">
        <comment>List of Boot Sector commands.</comment>
        <entry name="BOOT_SECTOR_CMD_ENTER_BOOT_MONITOR" value="0x4E6A821C">
            <comment>The Boot Sector must jump into the ROMed Boot Monitor.</comment>
        </entry>
    </enum>

    <var name="BOOT_SECTOR_EBC_VALID_TAG" value="0xB0075EC7">
        <comment>
            Value written in the Boot Sector structure to say that the EBC
            configuration present in this structure is valid and can be programmed.
            Used for the field ebcConfigValidTag.
        </comment>
    </var>

    <var name="BOOT_SECTOR_EBC_EXT_VALID_TAG" value="0xEBC00E28">
        <comment>
            Value written in the Boot Sector structure to say that the EBC extension
            configuration present in this structure is valid and can be programmed.
            Used for the field ebcConfigValidTag.
        </comment>
    </var>

    <typedef name="BOOT_SECTOR_STRUCT_T">
        <comment>
            Structure type used by the Boot Sector to determine in which mode it must
            boot and how the EBC RAM must be configured (this is useful in case of
            burst mode RAM).
            This structure contains information written by HAL during the normal
            execution of the code and used by the Boot Sector when the phone boots.
        </comment>
        <instance name="command" type="BOOT_SECTOR_CMD_T"/>
        <uint32 name="ebcConfigValidTag" />
        <uint32 name="ebcConfigRamTimings" />
        <uint32 name="ebcConfigRamMode" />
        <uint32 name="ebcExtConfigValidTag" />
        <uint32 name="ebcFreq" />
        <uint8 name="ramId" />
        <uint8 name="reserved" count="2" />
        <uint8 name="ebcConfigVersion" />
    </typedef>

    <typedef name="boot_map_globals" rubyconstants="yes">
    </typedef>

</archive>

<archive relative='../../../platform/base/sx/include/sx_task.xmd'  asm="no">


    

</archive>

<archive relative='../../../platform/base/sx/include/sx_map.xmd'  asm="no">


    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    
    <include file='sx_task.xmd'/>


    

    

    
   <typedef name="SX_MAP_ACCESS_T">
        <comment>
            This global variable is the shared structure of SX.
        </comment>
        
        <ptr name='sxExternalTraceEnablePtr' type='uint32'></ptr>
        <ptr name='sxsDebugIdleHookEnablePtr' type='uint32'></ptr>
   </typedef>

<cjoker>

// =============================================================================
// sx_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID sx_RegisterYourself(VOID);

</cjoker>

</archive>

<archive relative='../../../platform/base/std/include/std_map.xmd'  asm="no">


    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    


    


    
   <typedef name="STD_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        
   </typedef>

<cjoker>

// =============================================================================
// std_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID std_RegisterYourself(VOID);

</cjoker>

</archive>

<archive relative='../../../platform/svc/ars/include/ars_map.xmd'  asm="no">

    
    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    

    
    

    
    
   <typedef name="ARS_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        
   </typedef>
   
   <cjoker>

// =============================================================================
// ars_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID ars_RegisterYourself(VOID);

    </cjoker>

</archive>

<archive relative='../../../platform/svc/aps/include/aps_map.xmd'  asm="no">

    
    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    

    
    

    
    
   <typedef name="APS_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        
   </typedef>
   
   <cjoker>

// =============================================================================
// aps_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID aps_RegisterYourself(VOID);

    </cjoker>

</archive>

<archive relative='../../../platform/svc/vois/include/vois_map.xmd'  asm="no">

    
    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    

    
    
    <typedef name='VOIS_MAP_AUDIO_CFG'>
        <comment>
            Configuration structure.
            A configuration structure allows to record a stream with the proper
            configuration  set as far as the audio interface and the decoding
            are concerned.
        </comment>

        <uint32 name='spkSel'>
            <comment>Type of speaker</comment>
        </uint32>
        <uint32 name='micSel'>
            <comment>Type of speaker</comment>
        </uint32>
        <uint32 name='spkLevel'>
            <comment>Speaker level.</comment>
        </uint32>
        <uint32 name='micLevel'>
            <comment>Mic level</comment>
        </uint32>
        <uint32 name='sideLevel'>
            <comment>Side tone</comment>
        </uint32>
        <uint32 name='toneLevel'>
            <comment>Tone level</comment>
        </uint32>
        <int16 name='encMute'>
            <comment>encoder gain</comment>
        </int16>
        <int16 name='decMute'>
            <comment>decoder gain</comment>
        </int16>
    </typedef>


    <typedef name='AUD_MAP_LEVEL'>
        <comment>
            Configuration structure. A configuration structure allows to start an AUD
            operation (start stream, start  record, or start tone) with the desired
            parameters.
        </comment>

        <uint32 name='spkLevel'>
            <comment>Speaker level,</comment>
        </uint32>
        <uint32 name='micLevel'>
            <comment>Microphone level: muted or enabled</comment>
        </uint32>
        <uint32 name='sideLevel'>
            <comment>Sidetone</comment>
        </uint32>
        <uint32 name='toneLevel'></uint32>
    </typedef>



    <typedef name='VPP_MAP_SPEECH_AUDIO_CFG'>
        <comment>
            VPP Speech audio configuration for echo cancellation, encoder gain and
            anti-distorsion filter, decoder gain and anti-distorsion filter.
        </comment>
        <int16 name='echoEsOn'>
            <comment>enable the echo suppresor</comment>
        </int16>
        <int16 name='echoEsVad'>
            <comment>echo suppresor voice activity detection threshold</comment>
        </int16>
        <int16 name='echoEsDtd'>
            <comment>echo suppresor double-talk detection threshold</comment>
        </int16>   
        <int16 name='echoExpRel'>
            <comment>echo canceller relative threshold</comment>
        </int16>
        <int16 name='echoExpMu'>
            <comment>echo canceller mu paramater (NULL to disable the echo canceller)</comment>
        </int16>
        <int16 name='echoExpMin'>
            <comment>echo canceller minimum threshold</comment>
        </int16>   
        <int16 name='encMute'>
            <comment>encoder gain</comment>
        </int16>
        <int16 name='decMute'>
            <comment>decoder gain</comment>
        </int16>
        <ptr name='sdf' type='int32'>
            <comment>pointer to the speaker anti-distorsion filter (SDF) coefficients</comment>
        </ptr>
        <ptr name='mdf' type='int32'>
            <comment>pointer to the mic anti-distorsion filter (MDF) coefficients</comment>
        </ptr>
        <int16 name='if1'>
            <comment>push-to-talk enable flag</comment>
        </int16>

    </typedef>



    <typedef name='VOIS_CONTEXT'>
        <bool name='voisStarted'>
            <comment>
                Hold the 'started' or 'not started' state of VOIS
            </comment>
        </bool>

        <ptr name='voisEncOutput'   type="void">
            <comment>
                Pointer to the output (encoded) buffer of VPP
                This field is to be used casted as a HAL_SPEECH_ENC_OUT_T.
            </comment>
        </ptr>

        <ptr name='voisDecInput'   type="void">
            <comment>
                Pointer to the input (decoded) buffer of VPP
                This field is to be used casted as a HAL_SPEECH_DEC_IN_T.
            </comment>
        </ptr>

        <uint32 name='voisTramePlayedNb'>
            <comment>
                Number of played trames
            </comment>
        </uint32>

        <instance name='voisAudioCfg' type='AUD_MAP_LEVEL'>
            <comment>
                Audio configuration used to play the stream in normal state.
                (ie not when started or stopped.
                This field is to be used casted as a AUD_LEVEL_T.
            </comment>
        </instance>

        <instance name="voisVppCfg" type="VPP_MAP_SPEECH_AUDIO_CFG">
            <comment>
                VPP configuration used to play the stream in normal state.
                (ie not when started or stopped.)
                This field should be used casted as a VPP_SPEECH_AUDIO_CFG_T.
            </comment>
        </instance>

        <uint32 name='voisItf'>
            <comment>
                Interface used by vois to get and tell the words
                To be used casted as a AUD_ITF_ID_T.
            </comment>
        </uint32>

        <instance name='voisLatestCfg' type='VOIS_MAP_AUDIO_CFG'>
            <comment>
                Latest config applied to Vois.
            </comment>
        </instance>

        <uint32 name='mode'/>
        <uint32 name='bufferSize'/>
    </typedef>

    
    <alias name='VOIS_MAP_ACCESS_T'>

        <instance name='unused' type='VOIS_CONTEXT'></instance>
    </alias>
   
   <cjoker>

// =============================================================================
// vois_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID vois_RegisterYourself(VOID);

    </cjoker>

</archive>

<archive relative='../../../platform/stack/l1/include/l1_map.xmd'  asm='no'>

<var name='L1_NB_MEAS_SERVING' value='16'>
	<comment>Must be a power of 2. Max (5s, 5 Pch) = 5 / (2*235ms) = 10   (BsPaMfrms = 2, T = 5 s, 1 measure / Pch)</comment>
</var>

<var name='L1_NB_MAX_NEAR_CELLS' value='6'></var>
<var name='L1_NB_MAX_OLD_CELLS'  value='0'></var>
<var name='L1_NB_MAX_PLMN_CELLS' value='12'></var>
<var name='L1_NB_MAX_CELLS'  value='(L1_NB_MAX_NEAR_CELLS + L1_NB_MAX_OLD_CELLS + L1_NB_MAX_PLMN_CELLS + 1)'></var>


<enum name='JOB_ENUM_H_ENUM_0'>
	<entry name='L1_POWER_JOB'></entry>
	<entry name='L1_MONITORING_JOB'></entry>
	<entry name='L1_NEAR_JOB'></entry>
	<entry name='L1_CCH_JOB'></entry>
	<entry name='L1_PCCH_JOB'></entry>
	<entry name='L1_BCCH_JOB'></entry>
	<entry name='L1_PBCCH_JOB'></entry>
	<entry name='L1_RACH_JOB'></entry>
	<entry name='L1_CONNECT_JOB'></entry>
	<entry name='L1_HO_JOB'></entry>
	<entry name='L1_HO_ACCESS_JOB'></entry>
	<entry name='L1_UL_TBF_SETUP_JOB'></entry>
	<entry name='L1_DL_TBF_SETUP_JOB'></entry>
	<entry name='L1_PDCH_JOB'></entry>
	<entry name='L1_TBF_RELEASE_JOB'></entry>
	<entry name='L1_PTCCH_JOB'></entry>
	<entry name='L1_CBCH_JOB'></entry>
	<entry name='L1_JOB_LAST'></entry>
</enum>



<typedef name='l1_Cell'>
	<uint16 name='Arfcn'></uint16>
	<uint16 name='Agc'></uint16>
	<uint16 name='PAgc'></uint16>
	<uint8 name='Bsic'></uint8>
	<uint8 name='Rla'></uint8>
	<int8 name='RTOf'></int8>
	<uint16 name='PFct'></uint16>
	<int32 name='TOf'></int32>
	<int32 name='FOf'></int32>
	<int16 name='QbOf'></int16>
	<int32 name='FnOf'></int32>
	<uint8 name='RLChn'></uint8>
	<uint8 name='RLInit'></uint8>
	<uint8 name='RLCnt'></uint8>
	<uint8 name='RLUp'></uint8>
	<uint8 name='RLDwn'></uint8>
	<uint8 name='EvtCnt'></uint8>
	<uint8 name='Status'></uint8>
	<uint8 name='Update'></uint8>
	<uint8 name='Idx'></uint8>
	<uint8 name='Next'></uint8>
	<uint8 name='SpyIdx'></uint8>
</typedef>

<typedef name='l1_Serving'>
	<ptr name='Cell' type='l1_Cell'></ptr>
	<uint8 name='BcchSdcchComb'></uint8>
</typedef>

<typedef name='l1_GPwrCtrl'>
	<uint8 name='Alpha'></uint8>
	<uint8 name='TAvgW'></uint8>
	<uint8 name='TAvgT'></uint8>
	<uint8 name='Pb'></uint8>
	<uint8 name='PCMeasChan'></uint8>
	<uint8 name='NAvgI'></uint8>
	<uint8 name='TxPwrMax'></uint8>
</typedef>

<alias name='l1_PMeasCtrlReq'>
	<instance name='unused' type='l1_GPwrCtrl'></instance>
</alias>

<typedef name='l1_CchReq'>
	<uint16 name='Arfcn'></uint16>
	<uint8 name='BcchSdcchComb'></uint8>
	<uint8 name='BsAgBlkRes'></uint8>
	<uint8 name='BsPaMfrms'></uint8>
	<uint8 name='Group'></uint8>
	<uint8 name='Tn'></uint8>
	<uint8 name='Mode'></uint8>
</typedef>

<var name='L1_MA_SIZE' value='64'>
	<comment>Maximum number of valid Arfcn in the Mobile Allocation</comment>
</var>

<typedef name='l1_FreqParam'>
	<uint8 name='NbArfcn'></uint8>
	<uint8 name='Maio'></uint8>
	<uint8 name='Hsn'></uint8>
	<uint8 name='Pad'></uint8>
	<uint16 name='MA' count='L1_MA_SIZE'></uint16>
</typedef>

<typedef name='l1_PCchReq'>
	<uint16 name='Arfcn'></uint16>
	<instance name='FreqParam' type='l1_FreqParam'></instance>
	<uint8 name='MultiframeType'></uint8>
	<uint8 name='Tn'></uint8>
	<uint8 name='Tsc'></uint8>
	<uint8 name='AgBlkRes'></uint8>
	<uint8 name='PBcchBlks'></uint8>
	<uint8 name='BcchSdcchComb'></uint8>
	<uint8 name='SplitPagingCycle'></uint8>
	<uint8 name='Mode'></uint8>
	<uint16 name='Group'></uint16>
	<uint8 name='Pb'></uint8>
</typedef>

<typedef name='l1_RachOnReq'>
	<uint16 name='RachInfo'></uint16>
	<uint8 name='Type'></uint8>
	<uint8 name='IdleType'></uint8>
	<uint8 name='RandSize'></uint8>
	<uint8 name='TxPower'></uint8>
	<uint8 name='S'></uint8>
	<uint8 name='T'></uint8>
	<uint8 name='NbMaxRetrans'>
		<comment>10.5.2.29, 4.60 12.14</comment>
	</uint8>
	<uint8 name='PersistenceLevel'></uint8>
	<uint8 name='RadioPrio'></uint8>
	<uint8 name='Pad'></uint8>
</typedef>

<typedef name='l1_CiphParam'>
	<uint8 name='Kc' count='8'></uint8>
	<uint8 name='Algo'></uint8>
	<bool  name='Start'></bool>
	<uint8 name='Pad' count='2'></uint8>
</typedef>

<typedef name='l1_CellOpt'>
	<bool name='Pwrc'></bool>
	<uint8 name='Rlt'></uint8>
	<uint8 name='Dtx'></uint8>
	<uint8 name='Pad'></uint8>
</typedef>

<var name='L1_NO_ICM' value='0xFF'></var>

<typedef name='l1_AMRCfg'>
	<bool name='AMRCfgValid'></bool>
	<uint8 name='Version'></uint8>
	<uint8 name='NoiseSuppression'></uint8>
	<uint8 name='StartModeIdx'></uint8>
	<uint8 name='ACS'>
		<comment>be used. When value is L1_NO_ICM initial codec selection  is done according to 05.09 requirement.</comment>
	</uint8>
	<uint8 name='Threshold' count='3'></uint8>
	<uint8 name='Hysteresis' count='3'></uint8>
</typedef>

<typedef name='l1_ConnectReq'>
	<ptr name='FreqParam' type='l1_FreqParam' count='2'></ptr>
	<instance name='CipherParam' type='l1_CiphParam'>
		<comment>- immediate action only ([0]) or  - later action only ([0]) or  - both ([0] and [1])</comment>
	</instance>
	<instance name='CellOptions' type='l1_CellOpt'></instance>
	<instance name='AMRCfg' type='l1_AMRCfg'></instance>
	<uint16 name='ST'></uint16>
	<uint16 name='Arfcn'>
		<comment>L1_NO_ST = non significant</comment>
	</uint16>
	<uint8 name='ChanType'></uint8>
	<uint8 name='TdmaOffset'>
		<comment>champs (ChanType et TdmaOffset)</comment>
	</uint8>
	<uint8 name='TN'></uint8>
	<uint8 name='Tsc'></uint8>
	<uint8 name='PowerLevel'></uint8>
	<uint8 name='ChanMode'></uint8>
	<uint8 name='TA'></uint8>
	<uint8 name='HoType'>
		<comment>Assignment command and Handover command specific fields</comment>
	</uint8>
	<bool name='Ctrl'>
	</bool>
	<uint8 name='HORef'>
		<comment>Handover command specific fields</comment>
	</uint8>
	<bool name='Nci'></bool>
	<bool name='ATC'></bool>
	<uint8 name='RTD'>
		<comment>mandatory; 3GPP TS 4.18: if new cell  supports extended TA and TA &amp;gt; 63 and  ATC == TRUE, MS must not send HO access</comment>
	</uint8>
</typedef>

<typedef name='l1s_TACtx'>
	<uint8 name='Previous'></uint8>
	<uint8 name='Current'></uint8>
	<uint8 name='Next'></uint8>
</typedef>

<typedef name='pal_AMRCfg'>
	<comment>AMR Configuration structure</comment>

	<uint8 name='Version'></uint8>
	<uint8 name='NoiseSuppression'></uint8>
	<uint8 name='StartModeIdx'></uint8>
	<uint8 name='NbActiveCodecSet'></uint8>
	<uint8 name='ActiveCodecSet' count='4'></uint8>
	<uint8 name='Hysteresis' count='3'></uint8>
	<uint8 name='Threshold' count='3'></uint8>
	<uint8 name='CMIPhase'></uint8>
</typedef>

<typedef name='l1_MeasCfg'>
	<uint16 name='NbMeasTgt'></uint16>
	<uint16 name='NbMeasMax'></uint16>
	<uint16 name='ReadIdx'></uint16>
	<uint16 name='RunningAverageThres'></uint16>
	<uint8 name='NbCells'></uint8>
	<uint8 name='NbMonPerFr'></uint8>
	<uint8 name='PacketMeas'></uint8>
	<uint8 name='NbExtraMon'></uint8>
	<uint8 name='ServingIdx'>
		<comment>u8 PcMeasBcch;  Power control measurement on Bcch (PcMeasChan = false).</comment>
	</uint8>
	<bool name='Tag'></bool>
	<bool name='ExtendedMeas'></bool>
	<uint8 name='NcMeasState'></uint8>
	<uint8 name='NcRPIdle'></uint8>
	<uint8 name='NcRPTransfer'></uint8>
	<uint8 name='NcCurrentRp'></uint8>
	<uint8 name='LastNcInTransfer'></uint8>
	<uint32 name='FrmSchd'></uint32>
	<ptr name='ArfcnL' type='uint16'></ptr>
	<ptr name='WriteIdx' type='uint16'></ptr>
	<ptr name='NcMeasCumul' type='uint32'></ptr>
	<ptr name='NbNcMeas' type='uint16'></ptr>
	<ptr name='Meas' type='uint8'></ptr>
</typedef>

<typedef name='l1_ServMeasCfg'>
	<uint8 name='PwrC'></uint8>
	<uint8 name='NbMeas'></uint8>
	<uint8 name='NbMeasSub'></uint8>
	<uint8 name='MeasMax'></uint8>
	<uint8 name='MeasMin'></uint8>
	<uint8 name='MeasSubMax'></uint8>
	<uint8 name='MeasSubMin'></uint8>
	<uint16 name='MeasCumul'></uint16>
	<uint16 name='MeasCumulSub'></uint16>
	<uint16 name='TotalBit'></uint16>
	<uint16 name='TotalBitSub'></uint16>
	<uint16 name='WrongBitCumul'></uint16>
	<uint16 name='WrongBitCumulSub'></uint16>
	<uint8 name='NbMeasTgt'></uint8>
	<uint8 name='ReadIdx'></uint8>
	<uint8 name='WriteIdx'></uint8>
	<uint8 name='Meas' count='L1_NB_MEAS_SERVING'></uint8>
	<uint16 name='BlkMeasCumul'></uint16>
	<uint8 name='NbBstMeas'></uint8>
	<uint8 name='NbBstBcch'></uint8>
	<uint8 name='BfiBitMap'></uint8>
	<uint8 name='PcMeasBcch'></uint8>
	<uint16 name='n'></uint16>
	<uint16 name='F'></uint16>
	<uint16 name='vF'></uint16>
	<uint32 name='C'></uint32>
	<uint8 name='TxPower' count='8'></uint8>
	<uint8 name='BstMeas' count='4'></uint8>
	<uint16 name='BlVarCumul'></uint16>
	<uint8 name='NbBlVar'></uint8>
	<uint16 name='Int' count='8'></uint16>
	<uint8 name='Intn' count='8'></uint8>
	<uint16 name='IntF'></uint16>
	<uint8 name='IntvF'></uint8>
	<bool name='ExtIntRequest'></bool>
	<bool name='NextExtInt'></bool>
	<uint16 name='ExtIntArfcn'></uint16>
	<uint16 name='ExtInt' count='8'></uint16>
	<uint8 name='ExtIntn' count='8'></uint8>
	<uint8 name='IntMeas' count='2*4'></uint8>
	<uint16 name='IntArfcn' count='2'></uint16>
</typedef>

<typedef name='l1_CbchReq'>
	<uint8 name='BitMap'></uint8>
	<uint8 name='Tn'>
		<comment>extended to be listened.</comment>
	</uint8>
	<uint8 name='Tsc'></uint8>
	<uint8 name='Pad'></uint8>
	<instance name='FreqParam' type='l1_FreqParam'></instance>
</typedef>

<var name='PAL_NB_MAX_WIN_PER_FRAME' value='3'>
	<comment>This parameter indicates the number of windows that can be handle  in a frame. The minimum value is three (1 Rx, 1 Tx and 1 Mx or  1 Rx and 2 Mx or 3 Mx).\n  For performance purpose, one additional monitoring window would be  a plus especially in GPRS and in a multi-band context to speed up  the initial power measurement.</comment>
</var>

<typedef name='WinAlloc'>
	<uint8 name='Win' count='PAL_NB_MAX_WIN_PER_FRAME'></uint8>
	<uint8 name='Idx'></uint8>
	<uint8 name='NbWin'></uint8>
</typedef>

<alias name='s16Pair'>
	<int16 name='unused' count='2'></int16>
</alias>

<typedef name='l1_EquRes'>
	<uint8 name='WrIdx'></uint8>
	<uint8 name='Pad' count='3'>
		<comment>u8 RdIdx;</comment>
	</uint8>
	<uint32 name='Pwr' count='2'></uint32>
	<uint32 name='Snr' count='2'></uint32>
	<uint32 name='TOf' count='2'></uint32>
	<uint32 name='Agc' count='2'></uint32>
	<instance name='FOf' type='s16Pair' count='4'></instance>
	<instance name='Arfcn' type='s16Pair' count='4'></instance>
</typedef>

<typedef name='l1_Ctx'>
	<uint8 name='State'></uint8>
	<uint8 name='AMR'></uint8>
	<uint16 name='SubState'></uint16>
	<uint32 name='FrameLoadBitMap'></uint32>
	<instance name='Cell' type='l1_Cell' count='L1_NB_MAX_CELLS'></instance>
	<instance name='Serving' type='l1_Serving'></instance>
	<ptr name='MonitorReq' type='Msg'></ptr>
	<ptr name='MemMonitorReq' type='Msg'></ptr>
	<ptr name='ExtdMonitorReq' type='Msg'></ptr>
	<ptr name='TxDiscardReq' type='Msg'></ptr>
	<ptr name='NextTxDiscardReq' type='Msg'></ptr>
	<ptr name='PMeasCtrlReq' type='l1_PMeasCtrlReq'></ptr>
	<ptr name='CchReq' type='l1_CchReq'></ptr>
	<ptr name='PCchReq' type='l1_PCchReq'></ptr>
	<ptr name='PBcchReq' type='Msg' count='2'></ptr>
	<ptr name='RachOnReq' type='l1_RachOnReq'>
		<comment>Msg_t *NcMonitorReq;  To be taken into account at the beginning of the next RP.</comment>
	</ptr>
	<ptr name='ConnectReq' type='l1_ConnectReq'></ptr>
	<ptr name='TACtx' type='l1s_TACtx'></ptr>
	<ptr name='TBFCtx' type='l1_TBFCtx'></ptr>
	<ptr name='AMRCfg' type='pal_AMRCfg'></ptr>
	<instance name='MeasCfg' type='l1_MeasCfg'></instance>
	<instance name='ServMeasCfg' type='l1_ServMeasCfg'></instance>
	<ptr name='CbchReq' type='l1_CbchReq'></ptr>
	<uint8 name='CbchSkipCnt' count='2'></uint8>
	<uint8 name='CbchSkipBitMap'></uint8>
	<uint8 name='OldTA'></uint8>
	<uint8 name='PSTxBitMap'></uint8>
	<uint8 name='NbPSJob'></uint8>
	<uint8 name='PDataPurgeReq'></uint8>
	<uint16 name='NbGPMeaSkip'></uint16>
	<uint8 name='FreeCell'></uint8>
	<uint8 name='ActiveCell'></uint8>
	<uint8 name='AfcIdx'></uint8>
	<uint8 name='AfcLocked'></uint8>
	<uint8 name='GainOffset'></uint8>
	<uint8 name='Job' count='L1_JOB_LAST'></uint8>
	<uint8 name='CellList' count='3'></uint8>
	<uint32 name='Fn' ckeywords='VOLATILE'></uint32>
	<uint16 name='RFn' ckeywords='VOLATILE'></uint16>
	<uint8 name='T1R' ckeywords='VOLATILE'></uint8>
	<uint8 name='T2' ckeywords='VOLATILE'></uint8>
	<uint8 name='T3' ckeywords='VOLATILE'></uint8>
	<uint8 name='C52' ckeywords='VOLATILE'></uint8>
	<uint8 name='C102' ckeywords='VOLATILE'></uint8>
	<uint8 name='C104' ckeywords='VOLATILE'></uint8>
	<instance name='WinAlloc' type='WinAlloc'></instance>
	<uint8 name='Tn'></uint8>
	<uint8 name='Sleep'></uint8>
	<uint8 name='SleepEnable'></uint8>
	<uint8 name='NearMode'></uint8>
	<uint8 name='DataBlockSize'></uint8>
	<uint8 name='BandMap'></uint8>
	<uint8 name='SpyServingId'></uint8>
	<uint8 name='SpyNearId'></uint8>
	<instance name='EquRes' type='l1_EquRes' count='5'></instance>
</typedef>



</archive>
<archive relative='../../../toolpool/flash_programmer/flash_prog_map.xmd'  asm='no'>


<typedef name="flash_programmer_globals" rubyconstants="yes"></typedef>

<enum name='FPC_COMMAND_TYPE_T'>
	<entry name='FPC_NONE' value='0'></entry>
	<entry name='FPC_PROGRAM'></entry>
	<entry name='FPC_ERASE_SECTOR'></entry>
	<entry name='FPC_ERASE_CHIP'></entry>
	<entry name='FPC_END'></entry>
	<entry name='FPC_CHECK_FCS'></entry>
	<entry name='FPC_GET_FINALIZE_INFO'></entry>
	<entry name='FPC_RESTART'></entry>
	<entry name='FPC_CHECK_CALIBRFPART_CRC'></entry>
	<entry name='FPC_DONE' value='-100'></entry>
	<entry name='FPC_ERROR'></entry>
	<entry name='FPC_FCS_ERROR'></entry>
	<entry name='FPC_FLASH_NOT_AT_FF'></entry>
</enum>

<typedef name='FPC_COMMAND_DATA_T'>
	<instance name='cmd' type='FPC_COMMAND_TYPE_T'></instance>
	<ptr name='flashAddr' type='uint8'></ptr>
	<ptr name='ramAddr' type='uint8'></ptr>
	<uint32 name='size'></uint32>
	<uint32 name='fcs'>Used by FPC_PROGRAM. Contains the FCS of the written data.</uint32>
</typedef>

<var name='EVENT_FLASH_PROG_READY' value='0xf0'></var>

<var name='EVENT_FLASH_PROG_ERROR' value='0xe0'></var>

<var name='EVENT_FLASH_PROG_UNKNOWN' value='0xd0'></var>

<var name='EVENT_FLASH_PROG_MEM_RESET' value='0xc0'></var>

<var name='EVENT_FLASH_PROG_MEM_ERROR' value='0xce'></var>

<var name='EVENT_CALIB_RFCRC_ERROR' value='0xb0'></var>

<var name='FPC_BUFFER_SIZE' value='32*1024'>

    <comment> Size of one of the three available data buffers
    </comment>
</var>

<var name='FPC_PROTOCOL_MAJOR' value='0xFA01'/>
<var name='FPC_PROTOCOL_MINOR' value='0xFB04'/>

<typedef name='FPC_PROTOCOL_VERSION_T'>
    <uint16 name='major'/>
    <uint16 name='minor'/>
</typedef>

<typedef name='FLASH_PROG_MAP_ACCESS_T'>
    <instance name='protocolVersion' type='FPC_PROTOCOL_VERSION_T'/>
    <instance name='commandDescr' type='FPC_COMMAND_DATA_T' count='2'/>
    <ptr name='dataBufferA' type='UINT8'/>
    <ptr name='dataBufferB' type='UINT8'/>
    <ptr name='dataBufferC' type='UINT8'/>
	<uint32 name='fpcSize'/>
</typedef>

<cjoker>
</cjoker>
</archive>



<archive relative='../../../platform/csw/include/csw_map.xmd'  asm="no">

    
    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    

    
    

    
    
   <typedef name="CSW_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        
   </typedef>
   
   <cjoker>

// =============================================================================
// csw_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID csw_RegisterYourself(VOID);

    </cjoker>

</archive>

<archive relative='../../../platform/edrv/aud/include/aud_map.xmd'  asm="no">


    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    


    


    
    <typedef name="AUD_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        
    </typedef>

<cjoker>

// =============================================================================
// aud_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID aud_RegisterYourself(VOID);

</cjoker>

</archive>


<archive relative='../../../platform/mdi/include/mdi_map.xmd'  asm="no">

    
    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    

    
    

    
    
	<typedef name="MDI_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        
	</typedef>
	
	<cjoker>

// =============================================================================
// mdi_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID mdi_RegisterYourself(VOID);

    </cjoker>

</archive>


<archive relative='../../../platform/edrv/btd/include/btd_map.xmd'  asm="no">

    
    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    

    
    

    
    
   <typedef name="BTD_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        
   </typedef>
   
   <cjoker>

// =============================================================================
// btd_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID btd_RegisterYourself(VOID);

    </cjoker>

</archive>


<archive relative='../../../platform/chip/hal/include/hal_uart.xmd'  asm="no">

    <comment>
        @defgroup uart HAL Uart Driver
        <br/>
        This document describes the characteristics of the UART module and
        how to use them via its Hardware Abstraction Layer API.
        The UART supports the following functions:
        <br/>- Supports Automatic Flow Control
        <br/>- Programmable receive and transmit FIFOs (16 bytes deep)
        <br/>- Supports low speed IrDA 1.0 SIR mode
        <br/>- DMA halabilities to allow fully automated data transfer
        <br/>- Wide selection of programmable interrupts to allow interrupt driven data
        transfer management
        <br/>- Up to 1.843 Mbits/s transfer rate.
        <br/>
        @par I/O Signals
        <br/>
        @image latex uart_io_sig.png "UART I/O Signals"
        @image html uart_io_sig.png "UART I/O Signals"
        <br/>
        <br/>
        @par
        A configuration structure hal_UartCfg allows to define the Uart behavior.
        The configurable items are:
        <br/>
        <br/>- \b Data \b Format \n
        The Uarts'driver supports either 7 bits data or 8 bits data with 1 or 2
        stopbits. If enabled, a parity check can be performed. The check can
        be configured to be even, odd, always 0 (space) or always one (mark).
        Those parameters apply for both the reception and transmission data.
        <br/>
        <br/>- \b FIFO \b Controls \n
        It can be configured to generate an interrupt when the
        reception FIFO is above a configurable threshold (Rx FIFO trigger) or
        when the emission FIFO is below a configurable threshold (Tx FIFO
        trigger).\n
        The available triggers for the reception FIFO are as follow :
        <br/>- #HAL_UART_RX_TRIG_1 -- One Data received in the
        Rx FIFO
        <br/>- #HAL_UART_RX_TRIG_QUARTER -- 1/4 of the Rx FIFO full
        <br/>- #HAL_UART_RX_TRIG_HALF -- 1/2 of the Rx FIFO full
        <br/>- #HAL_UART_RX_TRIG_NEARFULL -- Rx FIFO almost full
        .
        \n
        The available triggers for the transmission FIFO are as follow :
        <br/>- #HAL_UART_TX_TRIG_EMPTY -- Tx FIFO is empty
        <br/>- #HAL_UART_TX_TRIG_QUARTER -- Less than 1/4 of the Tx
        FIFO left to send
        <br/>- #HAL_UART_TX_TRIG_HALF -- Less than 1/2 of the Tx
        FIFO left to send
        <br/>- #HAL_UART_TX_TRIG_3QUARTER -- Less than 3/4 of the Tx
        FIFO left to send
        .
        \n
        <br/>- \b Hardware \b Flow \b Control \n
        The hardware flow control modes make it possible to avoid FIFO
        overrun or underrun and are the only way to guarantee a reliable
        transfer, without any loss of bytes.\n
        When the hardware flow control is enabled:
        <br/>- The emission will stop as soon as the CTS_L line is held high
        by the receiving device
        <br/>- When the Rx FIFO level reaches the selected level (parametrable
        as a number of byts) the RTS_L line is held high by the Uart hardware to
        tell the emitting device that it should stop emitting.
        .
        \n
        It is /b MANDATORY to use the AFC. \n
        <br/>
        <br/>- @b IrDA @b Mode \n
        IrDA 1.0 SIR mode is available and can be activated when the user
        opens a Uart. When SIR mode is enabled, serial data is transmitted and
        received on the Uart_Tx and Uart_Rx ports, respectively. IrDA 1.0 SIR
        mode supports bi-directional data communications with remote devices
        using infrared radiation as a transmission medium. IrDA 1.0 SIR mode
        specifies a maximum baud rate of 115.2 KBaud.\n\n
        Each data character is sent serially, beginning with a start bit,
        followed by 8 data bits, and ending with at least one stop bit.
        Transmitting a single infrared pulse signals a logic zero, while a
        logic one is represented by not sending a pulse. The width of each
        pulse is 3/16ths of a normal serial bit time.\n\n
        Thus, each new character begins with an infrared pulse for the start
        bit. However, received data is inverted from transmitted data due to
        the fact that the infrared pulses energizing the photo transistor
        (base of the IrDA receiver) pull its output low. This inverted
        transistor output is then fed to the Uart_Rx port, which then has a
        correct UART polarity. See the following figure for more details.
        @image html uart_irda_sir_data_format.png "IrDA SIR Data Format"
        @image latex uart_irda_sir_data_format.png "IrDA SIR Data Format"
        \n
        The UART module operation when in IrDA SIR mode is similar to
        what it is when the mode is disabled, with one exception: data
        transfers can only occur in half-duplex fashion. This is due to the
        IrDA SIR physical layer which specifies a minimum delay of 10ms
        between transmission and reception. This 10ms delay must be generated
        by software.
        <br/>
        <br/>- @b Baud @b Rate @b Selection \n
        UARTs are able to run at a wide selection of baud rates. This
        must be configured at the UART opening. The available baud rates are:\n
        <br/>- 2.4 KBaud (Serial and IrDA)
        <br/>- 4.8 KBaud (Serial and IrDA)
        <br/>- 9.6 KBaud (Serial and IrDA)
        <br/>- 14.4 KBaud (Serial and IrDA)
        <br/>- 19.2 KBaud (Serial and IrDA)
        <br/>- 28.8 KBaud (Serial and IrDA)
        <br/>- 33.6 KBaud (Serial and IrDA)
        <br/>- 38.4 KBaud (Serial and IrDA)
        <br/>- 57.6 KBaud (Serial and IrDA)
        <br/>- 115.2 KBaud (Serial and IrDA)
        <br/>- 230.4 KBaud (Available only in serial mode)
        <br/>- 460.8 KBaud (Available only in serial mode)
        <br/>- 921.6 KBaud (Available only in serial mode)
        <br/>- 1300.0 KBaud (Available only in serial mode)
        <br/>- 1625.0 KBaud (Available only in serial mode)
        <br/>- 2166.7 KBaud (Available only in serial mode)
        <br/>- 3250.0 KBaud (Available only in serial mode)
        .
        \n
        Note that the highest baudrates will require the system to run at a
        high enough frequency to allow for a precise enough sampling clock
        generation.
        <br/>
        <br/>- @b Transfer @b Mode \n
        To allow for an easy use of the Uart module, a non blocking
        Hardware Abstraction Layer interface is provided. Each transfer
        direction (Send/Receive) can be configured as :
        <br/>- @b Direct @b polling: \n
        The application sends/receives the data directly to/from the
        hardware module. The number of bytes actually sent/received is
        returned. No Irqs is generated.
        \n
        <br/>- @b Direct @b IRQ: \n
        The application sends/receives the data directly to/from the
        hardware module. The number of bytes actually sent/received is
        returned. An irq can be generated when the Tx/Rx FIFO reaches the
        pre-programmed level.
        \n
        <br/>- @b DMA @b polling: \n
        The application sends/receives the data through a DMA to the
        hardware module.
        \n
        When no DMA channel is available, the function returns 0. No
        byte is sent.
        \n
        When a DMA resource is available, the function returns the number
        of bytes to send. They will all be sent.
        \n
        A function allows to check if the previous DMA transfer is
        finished. No new DMA transfer for the same Uart and in the same
        direction is allowed until the previous transfer is finished.
        \n
        <br/>- @b DMA @b IRQ: \n
        The application sends/receives the data through a DMA to the
        hardware module.
        \n
        When no DMA channel is available, the function returns 0. No byte
        is sent.
        \n
        When a DMA resource is available, the function returns the number
        of bytes to send. They will all be sent. An Irq is generated when
        the current transfer is finished. No new DMA transfer for the same
        Uart and in the same direction is allowed until the previous
        transfer is finished.
        .
        \n
        If you use the Rx Uart (to get some data from the Uart) in DMA mode,
        you will have to call the #hal_SysInvalidateCache function to
        invalidate the cache on your reception buffer. Please refer to the
        Application Note 0019 "Cache and DMA Modules"for more details.
        <br/>
        @par Interrupt Masks
        The UART can generate interruptions for several reasons.
        Cf the specific functions of the driver for details.
        <br/>
        @par
        When the user interrupt service function is called, in case of a line
        error interrupt (\c rxLineErr), the status passed to this
        function will contain the status of the interrupt (as usual) and
        the status of the error in a structure of type #HAL_UART_ERROR_STATUS_T.
        <br/>
        @par Configuration Structure
        #HAL_UART_CFG_T is used to open the UART port with the desired parameters.
        <br/>
        @{
        <br/>
        <br/>

    </comment>


  <include load="no" file="cs_types.h"  />
  <include load="no" file="hal_error.h" />

  <enum name='HAL_UART_DATA_BITS'>
    <comment>UART data length</comment>

    <entry name='HAL_UART_7_DATA_BITS'>
      <comment>Data is 7 bits</comment>
    </entry>
    <entry name='HAL_UART_8_DATA_BITS'>
      <comment>Data is 8 bits</comment>
    </entry>
    <entry name='HAL_UART_DATA_BITS_QTY'></entry>
  </enum>

  <enum name='HAL_UART_STOP_BITS_QTY'>
    <comment>Number of stop bits</comment>

    <entry name='HAL_UART_1_STOP_BIT'>
      <comment>There is 1 stop bit</comment>
    </entry>
    <entry name='HAL_UART_2_STOP_BITS'>
      <comment>There are 2 stop bits</comment>
    </entry>
    <entry name='HAL_UART_STOP_BITS_QTY'></entry>
  </enum>

  <enum name='HAL_UART_PARITY_CFG'>
    <comment>Data parity control selection  If enabled, a parity check can be performed</comment>

    <entry name='HAL_UART_NO_PARITY'>
      <comment>No parity check</comment>
    </entry>
    <entry name='HAL_UART_ODD_PARITY'>
      <comment>Parity check is odd</comment>
    </entry>
    <entry name='HAL_UART_EVEN_PARITY'>
      <comment>Parity check is even</comment>
    </entry>
    <entry name='HAL_UART_SPACE_PARITY'>
      <comment>Parity check is always 0 (space)</comment>
    </entry>
    <entry name='HAL_UART_MARK_PARITY'>
      <comment>Parity check is always 1 (mark)</comment>
    </entry>
    <entry name='HAL_UART_PARITY_QTY'></entry>
  </enum>

  <enum name='HAL_UART_RX_TRIGGER_CFG'>
    <comment>Reception FIFO trigger (or treshold) level  The Uarts can be configured to generate an interrupt when the  reception FIFO is above a configurable threshold (Rx FIFO trigger</comment>

    <entry name='HAL_UART_RX_TRIG_1' value='0'>
      <comment>One data received in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_RX_TRIG_QUARTER' value='7'>
      <comment>1/4 of the Rx FIFO is full</comment>
    </entry>
    <entry name='HAL_UART_RX_TRIG_HALF' value='15'>
      <comment>1/2 of the Rx FIFO is full</comment>
    </entry>
    <entry name='HAL_UART_RX_TRIG_3QUARTER' value='23'>
      <comment>3/4 of the Rx FIFO is full</comment>
    </entry>
    <entry name='HAL_UART_RX_TRIG_NEARFULL' value='30'>
      <comment>Rx FIFO is almost full</comment>
    </entry>
  </enum>

  <enum name='HAL_UART_TX_TRIGGER_CFG'>
    <comment>Tranmission FIFO trigger (or treshold) level.  The Uarts can be configured to generate an interrupt when the  emission FIFO is below a configurable threshold (Tx FIFO trigger</comment>

    <entry name='HAL_UART_TX_TRIG_EMPTY' value='0'>
      <comment>Tx FIFO empty</comment>
    </entry>
    <entry name='HAL_UART_TX_TRIG_QUARTER' value='3'>
      <comment>Less than 1/4 of the Tx FIFO left to send</comment>
    </entry>
    <entry name='HAL_UART_TX_TRIG_HALF' value='7'>
      <comment>Less than 1/2 of the Tx FIFO left to send</comment>
    </entry>
    <entry name='HAL_UART_TX_TRIG_3QUARTER' value='11'>
      <comment>Less than 3/4 of the Tx FIFO left to send</comment>
    </entry>
  </enum>

  <enum name='HAL_UART_AFC_MODE'>
    <comment>Auto Flow Control.  Controls the Rx Fifo level at which the Uart_RTS Auto Flow Control will be  set inactive high (see UART Operation for more details on AFC). The  Uart_RTS Auto Flow Control will be set inactive high when quantity of  data in Rx Fifo &amp;gt; AFC Level</comment>

    <entry name='HAL_UART_AFC_MODE_RX_TRIG_1' value='0'>
      <comment>RTS inactive with 1 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_2' value='1'>
      <comment>RTS inactive with 2 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_3' value='2'>
      <comment>RTS inactive with 3 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_4' value='3'>
      <comment>RTS inactive with 4 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_5' value='4'>
      <comment>RTS inactive with 5 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_6' value='5'>
      <comment>RTS inactive with 6 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_7' value='6'>
      <comment>RTS inactive with 7 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_8' value='7'>
      <comment>RTS inactive with 8 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_9' value='8'>
      <comment>RTS inactive with 9 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_10' value='9'>
      <comment>RTS inactive with 10 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_11' value='10'>
      <comment>RTS inactive with 11 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_12' value='11'>
      <comment>RTS inactive with 12 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_13' value='12'>
      <comment>RTS inactive with 13 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_14' value='13'>
      <comment>RTS inactive with 14 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_15' value='14'>
      <comment>RTS inactive with 15 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_16' value='15'>
      <comment>RTS inactive with 16 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_DISABLE' value='16'>
      <comment>Hardware flow control is disabled. \n  &amp;lt;B&amp;gt; NEVER USE THIS MODE &amp;lt;/B&amp;gt;</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_QTY'></entry>
    <entry name='HAL_UART_AFC_LOOP_BACK' value='32'>
      <comment>AFC mode is loopback \n  When set, data on the Uart_Tx line is held high, while the serial output  is looped back to the serial input line, internally.</comment>
    </entry>
  </enum>

  <enum name='HAL_UART_IRDA_MODE'>
    <comment>IrDA protocole enabling  IrDA SIR mode is available, and can be activated when the user open the Uart</comment>

    <entry name='HAL_UART_IRDA_MODE_DISABLE'>
      <comment>IrDA mode disabled</comment>
    </entry>
    <entry name='HAL_UART_IRDA_MODE_ENABLE'>
      <comment>IrDA mode enabled</comment>
    </entry>
    <entry name='HAL_UART_IRDA_MODE_QTY'></entry>
  </enum>

  <enum name='HAL_UART_BAUD_RATE'>
    <comment>Baudrate available with the modifiable system clock  UARTs are able to run at a wide selection of baud rates. This must  be configured at the UART opening</comment>

    <entry name='HAL_UART_BAUD_RATE_2400' value='2400'>
      <comment>2.4 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_4800' value='4800'>
      <comment>4.8 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_9600' value='9600'>
      <comment>9.6 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_14400' value='14400'>
      <comment>14.4 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_19200' value='19200'>
      <comment>19.2 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_28800' value='28800'>
      <comment>28.8 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_33600' value='33600'>
      <comment>33.6 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_38400' value='38400'>
      <comment>38.4 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_57600' value='57600'>
      <comment>57.6 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_115200' value='115200'>
      <comment>115.2 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_230400' value='230400'>
      <comment>230.4 KBaud (Available only in serial mode)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_460800' value='460800'>
      <comment>460.8 KBaud (Available only in serial mode)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_921600' value='921600'>
      <comment>921.6 KBaud (Available only in serial mode)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_1300000' value='1300000'>
      <comment>1300.0 KBaud (Available only in serial mode)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_1625000' value='1625000'>
      <comment>1625.0 KBaud (Available only in serial mode)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_2166700' value='2166700'>
      <comment>2166.7 KBaud (Available only in serial mode)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_3250000' value='3250000'>
      <comment>3250.0 KBaud (Available only in serial mode)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_QTY'></entry>
  </enum>

  <enum name='HAL_UART_TRANSFERT_MODE'>
    <comment>Data transfert mode: via DMA or direct.  To allow for an easy use of the Uart modules, a non blocking hardware  abstraction layer interface is provided</comment>

    <entry name='HAL_UART_TRANSFERT_MODE_DIRECT_POLLING' value='0'>
      <comment>Direct polling: The application sends/receives the data directly to/from  the hardware module. The number of bytes actually sent/received is  returned. No IRQ is generated.</comment>
    </entry>
    <entry name='HAL_UART_TRANSFERT_MODE_DIRECT_IRQ' value='1'>
      <comment>Direct Irq: The application sends/receives the data directly to/from  the hardware module. The number of bytes actually sent/received is  returned.An irq can be generated when the Tx/Rx FIFO reaches the  pre-programmed level.</comment>
    </entry>
    <entry name='HAL_UART_TRANSFERT_MODE_DMA_POLLING' value='2'>
      <comment>DMA polling: The application sends/receives the data through a DMA to  the hardware module. When no DMA channel is available, the function  returns 0. No byte is sent. When a DMA resource is available, the  function returns the number of bytes to send. They will all be sent. A  function allows to check if the previous DMA transfer is finished. No  new DMA transfer for the same Uart and in the same direction is  allowed until the previous transfer is finished.</comment>
    </entry>
    <entry name='HAL_UART_TRANSFERT_MODE_DMA_IRQ' value='3'>
      <comment>The application sends/receives the data through a DMA to the hardware  module. When no DMA channel is available, the function returns 0. No  byte is sent. When a DMA resource is available, the function returns  the number of bytes to send. They will all be sent. An Irq is generated  when the current transfer is finished. No new DMA transfer for the  same Uart and in the same direction is allowed until the previous  transfer is finished.</comment>
    </entry>
    <entry name='HAL_UART_TRANSFERT_MODE_OFF' value='4'>
      <comment>The transfert is off.</comment>
    </entry>
    <entry name='HAL_UART_TRANSFERT_MODE_QTY'></entry>
  </enum>

  <typedef name='HAL_UART_CFG'>
    <comment>UART Configuration Structure  This structure defines the Uart behavior</comment>

    <instance name='data' type='HAL_UART_DATA_BITS'>
      <comment>Data format</comment>
    </instance>
    <instance name='stop' type='HAL_UART_STOP_BITS_QTY'>
      <comment>Number of stop bits</comment>
    </instance>
    <instance name='parity' type='HAL_UART_PARITY_CFG'>
      <comment>Parity check</comment>
    </instance>
    <instance name='rx_trigger' type='HAL_UART_RX_TRIGGER_CFG'>
      <comment>Trigger for the Rx FIFO</comment>
    </instance>
    <instance name='tx_trigger' type='HAL_UART_TX_TRIGGER_CFG'>
      <comment>Trigger for the Tx FIFO</comment>
    </instance>
    <instance name='afc' type='HAL_UART_AFC_MODE'>
      <comment>Hardware Flow control</comment>
    </instance>
    <instance name='irda' type='HAL_UART_IRDA_MODE'>
      <comment>IrDA mode</comment>
    </instance>
    <instance name='rate' type='HAL_UART_BAUD_RATE'>
      <comment>Baud Rate</comment>
    </instance>
    <instance name='rx_mode' type='HAL_UART_TRANSFERT_MODE'>
      <comment>Reception transfer mode</comment>
    </instance>
    <instance name='tx_mode' type='HAL_UART_TRANSFERT_MODE'>
      <comment>Transmission transfer mode</comment>
    </instance>
  </typedef>

  <alias name='HAL_UART_IRQ_STATUS'>

    <uint32 name='unused'>
      <comment>Uart Irq cause structure. This structure is used to set the masks and get the  IRQ status of the uarts.</comment>

      <bits name='txModemStatus' pos='0'>
        <comment>Clear to send signal detected.</comment>
      </bits>
      <bits name='rxDataAvailable' pos='1'>
        <comment>Rx FIFO at or upper a threshold level (current level &amp;gt;= Rx FIFO trigger  level) trigs an interrupt. This level is programmed when the UART is opened.</comment>
      </bits>
      <bits name='txDataNeeded' pos='2'>
        <comment>Tx FIFO at or below a threshold level (current level &amp;lt;= Tx FIFO trigger  level) trigs an interrupt. This level is programmed when the UART is opened.</comment>
      </bits>
      <bits name='rxTimeout' pos='3'>
        <comment>It there is no character in or out of the Rx FIFO during the last 4  character times and if there is at least 1 character in this FIFO during  this time, the an interrupt is trigged.</comment>
      </bits>
      <bits name='rxLineErr' pos='4'>
        <comment>This interrupt is generated when a Tx Overflow, Rx Overflow, Parity Error,  Framing Error or Break Interrupt occurs.</comment>
      </bits>
      <bits name='txDmaDone' pos='5'>
        <comment>This interrupt is generated when the DMA transmission is finished. The  transmission mode is set at the UART opening.</comment>
      </bits>
      <bits name='rxDmaDone' pos='6'>
        <comment>This interrupt is generated when the DMA reception is finished. The  reception mode is set at the UART opening.</comment>
      </bits>
      <bits name='rxDmaTimeout' pos='7'>
        <comment>This interrupt is generated when a DMA reception time-out.</comment>
      </bits>
      <bits name='DTR_Rise' pos='8'>
        <comment>This interrupt is generated when a rising edge is detected on the UART_DTR signal.</comment>
      </bits>
      <bits name='DTR_Fall' pos='9'>
        <comment>This interrupt is generated when a falling edge is detected on the UART_DTR signal.</comment>
      </bits>
    </uint32>
  </alias>

  <alias name='HAL_UART_ERROR_STATUS'>

    <uint32 name='unused'>
      <comment>This structures reflects the detailed status of the "LINE  ERROR" IRQ, ie: the error status.</comment>

      <bits name=' ' pos='0:15'>
        <comment>These bits are not error stuff</comment>
      </bits>
      <bits name='rxOvflErr' pos='16'>
        <comment>This bit indicates that the UART  received a new character when the Rx FIFO was already full. The new  character is discarded.</comment>
      </bits>
      <bits name='txOvflErr' pos='17'>
        <comment>This bit indicates that the user tried to write a character on the  Tx FIFO while it was already full. The written data will not be kept.</comment>
      </bits>
      <bits name='rxParityErr' pos='18'>
        <comment>This bit is set if the parity is enabled and a parity error occurred  in the received data.</comment>
      </bits>
      <bits name='rxFramingErr' pos='19'>
        <comment>This bit is set whenever a framing error occurred. A framing error  occurs when the receiver does not detect a valid STOP bit in the  received data.</comment>
      </bits>
      <bits name='rxBreakInt' pos='20'>
        <comment>Set whenever the serial input is held in a logic 0 state for longer  than the length of x bits, where x is programmable.  A null word will be write in the Rx Fifo.</comment>
      </bits>
    </uint32>
  </alias>

<cjoker>
// ============================================================================
// TYPES
// ============================================================================

typedef VOID (*HAL_UART_IRQ_HANDLER_T)(HAL_UART_IRQ_STATUS_T, HAL_UART_ERROR_STATUS_T);

/// Uart 0 is the trace uart and is unavailable for this driver
/// The numbering starts at 1 for consistency.
/// The HAL_UART_QTY value is defined as the number of UARTS
/// avalaible for the chip on which the driver is running, and
/// can therefore be used for consistency checks
typedef enum {
    HAL_UART_1                                  = 0x00000001,
    HAL_UART_2                                  = 0x00000002,
    HAL_UART_QTY                                = CHIP_STD_UART_QTY+1
} HAL_UART_ID_T;


// ============================================================================
// FUNCTIONS
// ============================================================================

// ============================================================================
// hal_UartBreakIntWakeup
// ----------------------------------------------------------------------------
/// This function configures whether the system can be waked up 
/// by Uart break interrupt.
/// It must be configured before calling hal_UartOpen and hal_UartClose
/// to take effect.
///
/// @param id Identifier of the UART for which the function is called.
/// @param on TRUE to enable breakIntWakeup mode, FALSE otherwise.
// ============================================================================
PUBLIC VOID hal_UartBreakIntWakeup(HAL_UART_ID_T id, BOOL on);


// ============================================================================
// hal_UartIrqEnableBreakInt
// ----------------------------------------------------------------------------
/// This function enables or disables UART break IRQ.
///
/// @param id Identifier of the UART for which the function is called.
/// @param enable TRUE to enable break IRQ, FALSE otherwise.
// ============================================================================
PUBLIC VOID hal_UartIrqEnableBreakInt(HAL_UART_ID_T id, BOOL enable);


// ============================================================================
// hal_UartOpen
// ----------------------------------------------------------------------------
/// This function enables the Uart in the mode defined by \c uartCfg
///
/// This function requests a resource of #HAL_SYS_FREQ_26M only for a pll to be on.
///
/// @param id Identifier of the UART for which the function is called.
/// @param uartCfg Uart configuration structure
// ============================================================================
PUBLIC VOID hal_UartOpen(HAL_UART_ID_T id, CONST HAL_UART_CFG_T* uartCfg);


// ============================================================================
// hal_UartClose
// ----------------------------------------------------------------------------
/// This function closes the selected UART
///
/// This function release the resource to #HAL_SYS_FREQ_32K.
///
/// @param id Identifier of the UART for which the function is called.
// ============================================================================
PUBLIC VOID hal_UartClose(HAL_UART_ID_T id);


// ============================================================================
// hal_UartAllowSleep
// ----------------------------------------------------------------------------
/// That function is called to signify that the uart needs allow or not
/// the system to go into lowpower.
/// @param id Identifier of the UART for which the function is called.
/// @param allow If \c TRUE, the system is allowed to go into lowpower mode. \n
/// If \c FALSE, this prevents the system from entering in
/// lowpower mode.
// ============================================================================
PUBLIC VOID hal_UartAllowSleep(HAL_UART_ID_T id, BOOL allow);


// ============================================================================
// hal_UartSendData
// ----------------------------------------------------------------------------
/// This functions sends \c length bytes of data starting from the address
/// \c data. The number returned is the number of bytes actually sent. In
/// DMA mode, this function returns 0 when no DMA channel is available.
/// Otherwise, it returns \c length.
///
/// @param id Identifier of the UART for which the function is called.
/// @param data Pointer on the buffer of data to send.
/// @param length Number of bytes to send.
/// @return Number of sent bytes or 0 if no DMA channel is available in case of
/// a DMA transfer.
// ============================================================================
PUBLIC UINT32 hal_UartSendData(HAL_UART_ID_T id, CONST UINT8 *data, UINT32 length);


// ============================================================================
// hal_UartTxDmaDone
// ----------------------------------------------------------------------------
/// This function checks if the DMA transmission is finished.
/// Before sending new data in DMA mode, the previous DMA transfer must be
/// finished, hence the use of this function for polling.
///
/// Note that the DMA transfer can be finished with an unempty Tx FIFO. Before
/// shutting down the Uart, one must check that the uart FIFO is empty and that
/// the last byte has been completely sent by using #hal_UartTxFinished. It
/// is not necessary to check the emptiness of the Tx FIFO to start a new DMA
/// transfer. A new DMA transfer is possible once the previous DMA transfer
/// is over (And even is the Tx FIFO is not empty).
///
/// @param id Identifier of the UART for which the function is called.
/// @return \c TRUE if the last DMA transfer is finished. \c NO otherwise.
// ============================================================================
PUBLIC BOOL hal_UartTxDmaDone(HAL_UART_ID_T id);


// ============================================================================
// hal_UartTxFinished
// ----------------------------------------------------------------------------
/// This functions checks if the data transfer is completely finished before
/// closing.
/// This function returns \c TRUE when the transmit FIFO is empty and when the
/// last byte is completely sent. It should be called before closing the Uart
/// if the last bytes of the transfer are important.
///
/// This function should not be called between transfers, in direct or DMA mode.
/// The \link #hal_UartTxFifoAvailable FIFO available \endlink for direct
/// mode and the \link #hal_UartTxDmaDone DMA done indication \endlink for
/// DMA allow for a more optimized transmission.
///
/// @param id Identifier of the UART for which the function is called.
/// @return \c TRUE if the Tx FIFO is empty. \c NO otherwise
// ============================================================================
PUBLIC BOOL hal_UartTxFinished(HAL_UART_ID_T id);


// ============================================================================
// hal_UartGetData
// ----------------------------------------------------------------------------
/// This function gets \c length bytes from the Uart and stores them starting
/// from the address \c dest_address. The number returned is the number of bytes
/// actually received.
/// In DMA mode, this function returns 0 when no DMA channel is available. It
/// returns length otherwise.
/// If you use the Rx Uart (to get some data from the Uart) in DMA mode, you
/// will have to call the #hal_SysInvalidateCache function to invalidate the
/// cache on your reception buffer.
///
/// @param id Identifier of the UART for which the function is called.
/// @param destAddress Pointer to a buffer to store the received data
/// @param length Number of byte to receive
/// @return The number of actually received bytes, or 0 when no DMA channel is
/// available in case of a DMA transfer.
// ============================================================================
PUBLIC UINT32 hal_UartGetData(HAL_UART_ID_T id, UINT8* destAddress, UINT32 length);


// ============================================================================
// hal_UartRxFifoLevel
// ----------------------------------------------------------------------------
/// This function returns the number of bytes in the Rx FIFO
///
/// @param id Identifier of the UART for which the function is called.
/// @returns The number of bytes in the Rx FIFO
// ============================================================================
PUBLIC UINT8 hal_UartRxFifoLevel(HAL_UART_ID_T id);


// ============================================================================
// hal_UartRxDmaDone
// ----------------------------------------------------------------------------
/// Check if the reception is finished.
///
/// Before being able to receive new data in DMA mode, the previous transfer
/// must be finished, hence the use of this function for polling.
///
/// @param id Identifier of the UART for which the function is called.
/// @returns \c TRUE if the last DMA transfer is finished. \c NO otherwise
// ============================================================================
PUBLIC BOOL hal_UartRxDmaDone(HAL_UART_ID_T id);


// ============================================================================
// hal_UartRxDmaStop
// ----------------------------------------------------------------------------
/// This functions terminates the current Rx transfer and releases the
/// current Rx IFC DMA channel used by identified UART.
/// If the IFC channel fifo is not empty the transfer is not terminated.
/// This is useful when the DMA Rx Timeout rises.
///
/// @param id Identifier of the UART for which the function is called.
/// @return \c TRUE if the transfer has been released or if the current
/// UART doesn't have an IFC DMA channel attributed. \c FALSE if the
/// transfer cannot be released, i.e. the IFC DMA channel fifo is not empty.  
// ============================================================================
PUBLIC BOOL hal_UartRxDmaStop(HAL_UART_ID_T id);


// ============================================================================
// hal_UartRxDmaLevel
// ----------------------------------------------------------------------------
/// This function returns the number of free room remaining in the IFC DMA Rx
/// buffer. It can be useful to know when you can get data from the buffer. 
/// 
/// @param id Identifier of the UART for which the function is called.
/// @return Number of data (in bytes) remaining in the DMA buffer.
// ============================================================================
PUBLIC UINT32 hal_UartRxDmaLevel(HAL_UART_ID_T id);


// ============================================================================
// hal_UartRxDmaFifoEmpty
// ----------------------------------------------------------------------------
/// This function returns \c TRUE when the fifo of the DMA is empty.
///
/// @param id Identifier of the UART for which the function is called.
/// @returns \c TRUE when the fifo of the DMA is empty.
// ============================================================================
PUBLIC BOOL hal_UartRxDmaFifoEmpty(HAL_UART_ID_T id);


// ============================================================================
// hal_UartRxDmaPurgeFifo
// ----------------------------------------------------------------------------
/// Sends all the remaining data in the IFC fifo to the RAM buffer.
/// 
/// After the IFC DMA channel has been purged, it is NOT released.
/// After calling this function, the software should wait for the
/// actual end of the purging the fifo, by calling the function
/// hal_UartRxDmaFifoEmpty().
/// After the IFC DMA channel has been purged (or is being purged),
/// the data from the UART will not be read by the IFC DMA channel
/// anymore. This means that after calling this function, the user must
/// stop the current transfer and restart a new transfer.
///
/// @param id Identifier of the UART for which the function is called.
// ============================================================================
PUBLIC VOID hal_UartRxDmaPurgeFifo(HAL_UART_ID_T id);


// ============================================================================
// hal_UartSetRi
// ----------------------------------------------------------------------------
/// Sets the RI bit to the value given as a parameter
///
/// @param id Identifier of the UART for which the function is called.
/// @param value If \c TRUE, the RI bit is set.
/// If \c FALSE, the RI bit is cleared.
// ============================================================================
PUBLIC VOID hal_UartSetRi(HAL_UART_ID_T id, BOOL value);


// ============================================================================
// hal_UartSetDsr
// ----------------------------------------------------------------------------
/// Sets the DSR bit to the value given as a parameter
///
/// @param id Identifier of the UART for which the function is called.
/// @param value If \c TRUE, the DSR bit is set.
/// If \c FALSE, the DSR bit is cleared.
// ============================================================================
PUBLIC VOID hal_UartSetDsr(HAL_UART_ID_T id, BOOL value);


// ============================================================================
// hal_UartSetDcd
// ----------------------------------------------------------------------------
/// Sets the DCD bit to the value given as a parameter
///
/// @param id Identifier of the UART for which the function is called.
/// @param value If \c TRUE, the DCD bit is set.
/// If \c FALSE, the DCD bit is cleared.
// ============================================================================
PUBLIC VOID hal_UartSetDcd(HAL_UART_ID_T id, BOOL value);


// ============================================================================
// hal_UartGetDtr
// ----------------------------------------------------------------------------
/// Read the current value of the DTR line
/// @param id Identifier of the UART for which the function is called.
/// @return The current value of the DTR line. (\c TRUE or \c FALSE)
// ============================================================================
PUBLIC BOOL hal_UartGetDtr(HAL_UART_ID_T id);


// ============================================================================
// hal_UartSetBreak
// ----------------------------------------------------------------------------
/// Enable or disable the break (hold the Tx line low).
///
/// With this function, it is possible to generate a break: when the booLean
/// parameter \c enable is set to \c TRUE, the Uart_Tx line is held low, thus
/// generating a break on the line. It is held low until this function is
/// called again with the parameter \c enable set to \c FALSE.
///
/// @param id Identifier of the UART for which the function is called.
/// @param enable When set to \c TRUE, enables a break. When set to \c FALSE,
/// disables a break.
// ============================================================================
PUBLIC VOID hal_UartSetBreak(HAL_UART_ID_T id, BOOL enable);


// ============================================================================
// hal_UartTxFifoAvailable
// ----------------------------------------------------------------------------
/// This function returns the number of bytes available in the TX FIFO
///
/// @param id Identifier of the UART for which the function is called.
/// @return The number of available bytes in the TX FIFO.
// ============================================================================
PUBLIC UINT8 hal_UartTxFifoAvailable(HAL_UART_ID_T id);


// ============================================================================
// hal_UartGetErrorStatus
// ----------------------------------------------------------------------------
/// Gives the status of the UART.
/// This function returns the line error status. The \c UINT16 value returned
/// is a bitfield containing the errors detected during the transfer. The
/// errors can be: #HAL_ERR_UART_RX_OVERFLOW, #HAL_ERR_UART_TX_OVERFLOW,
/// #HAL_ERR_UART_PARITY, #HAL_ERR_UART_FRAMING, or #HAL_ERR_UART_BREAK_INT.
///
/// @param id Identifier of the UART for which the function is called.
/// @return The line error status
// ============================================================================
PUBLIC HAL_ERR_T hal_UartGetErrorStatus(HAL_UART_ID_T id);


// ============================================================================
// hal_UartClearErrorStatus
// ----------------------------------------------------------------------------
/// This function clears all the line error status. The error status is cleared
/// automatically by the interrupt dispatcher code, but if you do not use the
/// interrupt, the error status is not cleared. This means that if you check
/// the error status manually (by polling it with the #hal_UartGetErrorStatus
/// function), you'll need to call the #hal_UartClearErrorStatus function to
/// clear it, manually.
///
/// @param id Identifier of the UART for which the function is called.
// ============================================================================
PUBLIC VOID hal_UartClearErrorStatus(HAL_UART_ID_T id);


// ============================================================================
// hal_UartFifoFlush
// ----------------------------------------------------------------------------
/// This function resets the reception and the transmission FIFOs. All bytes
/// that are waiting to be sent in the Tx FIFO and that have been received,
/// waiting to be read in the Rx FIFO, will be removed.
///
/// @param id Identifier of the UART for which the function is called.
// ============================================================================
PUBLIC VOID hal_UartFifoFlush(HAL_UART_ID_T id);


// ============================================================================
// hal_UartSetRts
// ----------------------------------------------------------------------------
/// This function controls the RTS line of the UART. When the function is
/// called with a \c ready parameter set to \c FALSE, that means that the CPU
/// is not ready to handle the data of the UART. The remote device will stop
/// sending data to the UART.
///
/// To resume the data transfer (i.e. to let the remote device send data to the
/// UART again), call this function with a \c ready parameter set to \c TRUE.
///
/// If the hardware flow control is enabled, the RTS line will be controlled as
/// follows: RTS Line Ready = CPU Ready AND UART Hardware Flow Control Ready.
/// It means that if the UART or the CPU is not ready, the RTS line will ask
/// the remote device to stop sending data.
///
/// When the flow control is handled by the #hal_UartSetRts function, it is
/// called software flow control. The software flow control can be used in
/// parallel to the hardware flow control. Please refer to previous chapters for
/// details about @link #HAL_UART_AFC_MODE_T hardware flow control @endlink.
///
/// @param id Identifier of the UART for which the function is called.
/// @param ready Ready to receive data from the remote
/// device (&amp;amp;lt;CODE&amp;amp;gt; ready = TRUE &amp;amp;lt;/CODE&amp;amp;gt;) or not (&amp;amp;lt;CODE&amp;amp;gt; ready = FALSE &amp;amp;lt;/CODE&amp;amp;gt;)
// ============================================================================
PUBLIC VOID hal_UartSetRts(HAL_UART_ID_T id, BOOL ready);


// ============================================================================
// hal_UartGetCts
// ----------------------------------------------------------------------------
/// This function returns the value of the CTS line of the UART. When the
/// function returns \c TRUE, that means that the remote peripheral is
/// ready to receive data on its serial interface. The UART should stop sending
/// data.
///
/// If the hardware flow control is enabled and the CTS line says that the
/// remote device is not ready to receive data, the UART hardware will
/// automatically stop sending data.
///
/// When the flow control is handled by the #hal_UartGetCts, it is called
/// software flow control. The software flow control can be used in parallel to
/// the hardware flow control. Please refer to previous chapters for details
/// about @link #HAL_UART_AFC_MODE_T hardware flow control @endlink.
///
/// @param id Identifier of the UART for which the function is called.
/// @returns Value of the CTS line : \c TRUE if the remote device is ready to
/// receive data, \c FALSE otherwise.
// ============================================================================
PUBLIC BOOL hal_UartGetCts(HAL_UART_ID_T id);


// ============================================================================
// hal_UartIrqSetHandler
// ----------------------------------------------------------------------------
/// Set the user handler called when an Irq is triggered for the
/// defined UART.
/// @param id Identifier of the UART for which the function is called.
/// @param handler User function called in case of an interrupt on this UART
/// occurs.
// ============================================================================
PUBLIC VOID hal_UartIrqSetHandler(HAL_UART_ID_T id, HAL_UART_IRQ_HANDLER_T handler);


// ============================================================================
// hal_UartIrqSetMask
// ----------------------------------------------------------------------------
/// Set the IRQ mask for the specified uart
/// @param id Identifier of the UART for which the function is called.
/// @param mask The mask to apply
// ============================================================================
PUBLIC VOID hal_UartIrqSetMask(HAL_UART_ID_T id, HAL_UART_IRQ_STATUS_T mask);


// ============================================================================
// hal_UartIrqGetMask
// ----------------------------------------------------------------------------
/// Get the IRQ mask set for an UART
/// @param id Identifier of the UART for which the function is called.
/// @return The Irq mask of this uart
// ============================================================================
PUBLIC HAL_UART_IRQ_STATUS_T hal_UartIrqGetMask(HAL_UART_ID_T id);


// ============================================================================
// hal_UartForcePinsLow
// ----------------------------------------------------------------------------
/// This function force all output pins of the UART to low. This can be
/// called for any UART it will only change the state of the pins actually
/// configured in UART mode (IO config).
///
/// This function must only be called when the UART is closed.
///
/// @param id Identifier of the UART for which the function is called.
// ============================================================================
PUBLIC VOID hal_UartForcePinsLow(HAL_UART_ID_T id);

/// @} --> End of uart group

</cjoker>
</archive>
<archive relative='../../../platform/chip/hal/include/hal_usb_descriptor_types.xmd'  asm="no">


  <external name="HAL_USB_CALLBACK"       size="4" />
  <external name="HAL_USB_CS_CONSTRUCTOR" size="4" />

  <enum name="HAL_USB_CONFIG_ATTRIB">
    <comment>All attributes of config descriptor</comment>

    <entry name="HAL_USB_CONFIG_ATTRIB_SELF_POWER" value="0x00000040">
      <comment>Device use is self power</comment>
    </entry>
  </enum>

  <enum name="HAL_USB_EP_TYPE">
    <comment>EndPoint type</comment>

    <entry name="HAL_USB_EP_TYPE_CONTROL"   value="0"></entry>
    <entry name="HAL_USB_EP_TYPE_ISO"       value="1"></entry>
    <entry name="HAL_USB_EP_TYPE_BULK"      value="2"></entry>
    <entry name="HAL_USB_EP_TYPE_INTERRUPT" value="3"></entry>
  </enum>

  <typedef name="HAL_USB_EP_DESCRIPTOR">
    <comment>This struct use to define an EndPoint descriptor</comment>

    <uint8 name="ep">
      <comment>EndPoint index</comment>
    </uint8>
    <instance name="type" type="HAL_USB_EP_TYPE">
      <comment>Define the transfert type (ISO, Bulk, Cmd, Int)</comment>
    </instance>
    <uint16 name="interval">
      <comment>Polling interval for interrupt</comment>
    </uint16>
    <instance name="callback" type="HAL_USB_CALLBACK">
      <comment>EndPoint callback. See #HAL_USB_CALLBACK_T</comment>
    </instance>
  </typedef>

  <alias name="HAL_USB_EP_LIST_DESCRIPTOR">
    <ptr name="unused" type="HAL_USB_EP_DESCRIPTOR">
      <comment>List of EP</comment>
    </ptr>
  </alias>

  <typedef name="HAL_USB_INTERFACE_DESCRIPTOR">
    <comment>This struct use to define an Interface descriptor</comment>

    <uint8 name="usbClass">
      <comment>USB class defined by usb.org</comment>
    </uint8>
    <uint8 name="usbSubClass">
      <comment>USB subclass defined by usb.org</comment>
    </uint8>
    <uint8 name="usbProto">
      <comment>USB protocol</comment>
    </uint8>
    <ptr name="epList" type="HAL_USB_EP_LIST_DESCRIPTOR">
      <comment>List of endpoints linked with the interface</comment>
    </ptr>
    <ptr name="description" type="uint8">
      <comment>Description of interface</comment>
    </ptr>
    <instance name="callback" type="HAL_USB_CALLBACK">
      <comment>Interface callback. See #HAL_USB_CALLBACK_INTERFACE_CMD_T</comment>
    </instance>
    <uint8 name="interfaceIdx">
      <comment>Interface index. If 0 the interface index is generate</comment>
    </uint8>
  </typedef>

  <typedef name="HAL_USB_CS_INTERFACE_DESCRIPTOR">
    <comment>This struct use to define an class specific Interface descriptor</comment>
    <uint32 name="reserved" count="2" />
    <instance name="constructor" type="HAL_USB_CS_CONSTRUCTOR">
      <comment>Call this function for write the constructor</comment>
    </instance>
    <instance name="callback"   type="HAL_USB_CALLBACK">
      <comment>Interface callback. See #HAL_USB_CALLBACK_INTERFACE_CMD_T</comment>
    </instance>
    <uint8 name="interfaceIdx">
      <comment>Interface index. Must be 0xFF for CS_INTERFACE</comment>
    </uint8>
  </typedef>

  <typedef name="HAL_USB_INTERFACE_ASSOCIATION_DESCRIPTOR_REAL_T">
    <uint8 name="bLength">
    </uint8>
    <uint8 name="bDescriptorType">
    </uint8>
    <uint8 name="bFirstInterface">
    </uint8>
    <uint8 name="bInterfaceCount">
    </uint8>
    <uint8 name="bFunctionClass">
    </uint8>
    <uint8 name="bFunctionSubClass">
    </uint8>
    <uint8 name="bFunctionProtocol">
    </uint8>
    <uint8 name="iFunction">
    </uint8>
  </typedef>

  <alias name="HAL_USB_INTERFACE_LIST_DESCRIPTOR">
    <ptr name="unused" type="HAL_USB_INTERFACE_DESCRIPTOR">
      <comment>List of interfaces</comment>
    </ptr>
  </alias>

  <typedef name="HAL_USB_CONFIG_DESCRIPTOR">
    <comment>This struct use to define a Configuration descriptor</comment>

    <uint8 name="attrib">
      <comment>Config attribues. Describe on #HAL_USB_CONFIG_ATTRIB_T</comment>
    </uint8>
    <uint8 name="maxPower">
      <comment>Power use in this configuration 1 unit = 2mA</comment>
    </uint8>
    <ptr name="iad" type="HAL_USB_INTERFACE_ASSOCIATION_DESCRIPTOR_REAL_T" ckeywords="CONST">
      <comment>Interface association descriptor</comment>
    </ptr>
    <ptr name="interfaceList" type="HAL_USB_INTERFACE_LIST_DESCRIPTOR">
      <comment>All interface including in this configuration</comment>
    </ptr>
    <ptr name="description" type="uint8">
      <comment>Description of configuration</comment>
    </ptr>
    <uint8 name="configIdx">
      <comment>Config index</comment>
    </uint8>
  </typedef>

  <alias name="HAL_USB_CONFIG_LIST_DESCRIPTOR">
    <ptr name="unused" type="HAL_USB_CONFIG_DESCRIPTOR">
      <comment>List of configs</comment>
    </ptr>
  </alias>

  <typedef name="HAL_USB_DEVICE_DESCRIPTOR">
    <comment>This struct use to define a Device descriptor</comment>

    <uint8 name="usbClass">
      <comment>Device class defined by usb.org</comment>
    </uint8>
    <uint8 name="usbSubClass">
      <comment>Device subclass defined by usb.org</comment>
    </uint8>
    <uint8 name="usbProto">
      <comment>Protocol</comment>
    </uint8>
    <uint16 name="vendor">
      <comment>Vendor id defined by usb.org</comment>
    </uint16>
    <uint16 name="product">
      <comment>Product id</comment>
    </uint16>
    <uint16 name="version">
      <comment>Version (format BCD)</comment>
    </uint16>
    <ptr name="configList" type="HAL_USB_CONFIG_LIST_DESCRIPTOR">
      <comment>List of all configuration</comment>
    </ptr>
    <ptr name="description" type="uint8">
      <comment>Description of device</comment>
    </ptr>
    <ptr name="serialNumber" type="uint8">
      <comment>Serial Number</comment>
    </ptr>
    <uint8 name="usbMode">
      <comment>Usb mode use to generate product id</comment>
    </uint8>
  </typedef>
</archive>

<archive relative='../../../platform/include/gfx_types.xmd'  asm="no">


    <comment>
        This file contains the types used for graphical operations.
    </comment>

    <enum name="GFX_WIDESCREEN_ASPECT">
      <comment>
        Describe the display aspect
      </comment>
      <entry name="GFX_WIDESCREEN_ASPECT_FULLSCREEN"></entry>
      <entry name="GFX_WIDESCREEN_ASPECT_LETTERBOX"></entry>
      <entry name="GFX_WIDESCREEN_ASPECT_PANSCAN"></entry>
    </enum>

    <enum name="GFX_COLOR_FORMAT">
        <comment>
            This type describes how the color are encoded within a frame buffer.
        </comment>
        <entry name="GFX_COLOR_FORMAT_INVALID"><comment>to track not initialized structures.</comment></entry>
        <entry name="GFX_COLOR_FORMAT_RGB_565"><comment>Regular RGB 565 format.</comment></entry>
        <entry name="GFX_COLOR_FORMAT_RGB_565_PIXELSWAP"><comment>RGB565 format with swapped pixels (for Greenstone Camera module).</comment></entry>
        <entry name="GFX_COLOR_FORMAT_RGBA"><comment>RVG Alpha 888 8 format.</comment></entry>
        <entry name="GFX_COLOR_FORMAT_UYVY"><comment>YUV 4:2:2 pixel packed (UYVY).</comment></entry>
        <entry name="GFX_COLOR_FORMAT_YUYV"><comment>YUV 4:2:2 pixel packed (YUYV).</comment></entry>
        <entry name="GFX_COLOR_FORMAT_IYUV"><comment>YUV 4:2:0 planar (IYUV).</comment></entry>

        <entry name="GFX_COLOR_FORMAT_QTY"/>
    </enum>

    <enum name="GFX_ROTATION">
        <comment>
            This type describes the rotations.
        </comment>
        <entry name="GFX_ROTATION_NONE" value="0"  ><comment>No Rotation.</comment></entry>
        <entry name="GFX_ROTATION_90"   value="90" ><comment>Rotation of 90 degrees Counter Clockwise.</comment></entry>
        <entry name="GFX_ROTATION_180"  value="180"><comment>Rotation of 180 degrees Counter Clockwise.</comment></entry>
        <entry name="GFX_ROTATION_270"  value="270"><comment>Rotation of 270 degrees Counter Clockwise.</comment></entry>
    </enum>

    <typedef name="GFX_POINT">
        <comment>
            This type describes a graphical point.
        </comment>
        <int16 name="x"><comment>x coordinate of the point.</comment></int16>
        <int16 name="y"><comment>y coordinate of the point.</comment></int16>
    </typedef>

    <typedef name="GFX_RECT">
        <comment>
            This type describes a graphical rectangular region described by its corner points.
        </comment>
        <int16 name="left"><comment>x coordinate of the top left corner of the region.</comment></int16>
        <int16 name="top"><comment>y coordinate of the top left corner of the region.</comment></int16>
        <int16 name="right"><comment>x coordinate of the bottom right corner of the region.</comment></int16>
        <int16 name="bottom"><comment>y coordinate of the bottom right corner of the region.</comment></int16>
    </typedef>

    <typedef name="GFX_ROI">
        <comment>
            Region Of Interest: This type describes a graphical rectangular region described by its start point and size.
        </comment>
        <instance name="start" type="GFX_POINT"><comment>starting point of the region.</comment></instance>

        <uint16 name="width"><comment>width of the region.</comment></uint16>
        <uint16 name="height"><comment>height of the region.</comment></uint16>
    </typedef>

    <typedef name="GFX_FB">
        <comment>
            Frame Buffer: This type describes a frame buffer through its dimensions and a
            pointer to the data of the buffer. It is mandatory for the buffer to
            be able to hold the data describing all the pixels at the color format
            chosen. <br/>
            (ie sizeof(buffer) = width*height*NbOfBytesPerPixelAtTheFormat(format))
        </comment>
        <ptr type="uint16" name="buffer"/>

        <uint16 name="width"><comment>width of the buffer.</comment></uint16>
        <uint16 name="height"><comment>height of the buffer.</comment></uint16>
        <instance name="colorFormat" type="GFX_COLOR_FORMAT"><comment>Color encoding of the buffer.</comment></instance>
    </typedef>

    <typedef name="GFX_FBW">
        <comment>
            Frame Buffer Window: This type describes a window in a frame buffer as
            a region of interest within this frame buffer. When the region of
            interest starts at (0,0) and has the same dimensions as the frame
            buffer, the window is in fact the whole frame buffer.
        </comment>
        <instance name="fb" type="GFX_FB"><comment>Frame buffer.</comment></instance>
        <instance name="roi" type="GFX_ROI"><comment>Region of interest.</comment></instance>
    </typedef>

<cjoker>
// ============================================================================
// GFX_FB_T IYUV buffer accessors
// -----------------------------------------------------------------------------
// The macros are assuming that the width is a multiple of 4.
// ============================================================================
/// Access macros for IYUV format to access the Y buffer
#define GFX_FB_IYUV_Y(fb) ((UINT8)((fb).buffer))
/// Access macros for IYUV format to access the U buffer
#define GFX_FB_IYUV_U(fb) ((UINT8)((fb).buffer)+((fb).width*(fb).height))
/// Access macros for IYUV format to access the V buffer
#define GFX_FB_IYUV_V(fb) ((UINT8)((fb).buffer)+(((fb).width*(fb).height*5)>>2))
</cjoker>

</archive>
<archive relative='../../../platform/include/snd_types.xmd'  asm="no">


<include file="cs_types.h" load="no"/>


<enum name='SND_SPK_LEVEL'>
    <comment> This type describes the possible level value for the speaker volume.  </comment>

    <entry name='SND_SPK_MUTE' value='0'></entry>
    <entry name='SND_SPK_VOL_1'></entry>
    <entry name='SND_SPK_VOL_2'></entry>
    <entry name='SND_SPK_VOL_3'></entry>
    <entry name='SND_SPK_VOL_4'></entry>
    <entry name='SND_SPK_VOL_5'></entry>
    <entry name='SND_SPK_VOL_6'></entry>
    <entry name='SND_SPK_VOL_7'></entry>
    <entry name='SND_SPK_VOL_QTY'></entry>
</enum>

<enum name='SND_MIC_LEVEL'>
    <comment> This type describes the possible level value for the mic: mute or enabled, volume in call, volume in recording.  </comment>

    <entry name='SND_MIC_MUTE' value='0'></entry>
    <entry name='SND_MIC_ENABLE'></entry>
    <entry name='SND_MIC_VOL_CALL' value='SND_MIC_ENABLE'></entry>
    <entry name='SND_MIC_VOL_RECORD'></entry>
    <entry name='SND_MIC_VOL_QTY'></entry>
</enum>

<enum name='SND_SIDE_LEVEL'>
    <comment> This type describes the possible level value for the side tone volume.  The value SND_SIDE_VOL_TEST is used for mic to spk simple loop back test.  </comment>

    <entry name='SND_SIDE_MUTE' value='0'></entry>
    <entry name='SND_SIDE_VOL_1'></entry>
    <entry name='SND_SIDE_VOL_2'></entry>
    <entry name='SND_SIDE_VOL_3'></entry>
    <entry name='SND_SIDE_VOL_4'></entry>
    <entry name='SND_SIDE_VOL_5'></entry>
    <entry name='SND_SIDE_VOL_6'></entry>
    <entry name='SND_SIDE_VOL_7'></entry>
    <entry name='SND_SIDE_VOL_TEST'></entry>
    <entry name='SND_SIDE_VOL_QTY'></entry>
</enum>

<enum name='SND_TONE_ATTENUATION'>
    <comment> Attenuation of the tone.   The attenuation can be set to 0 dB, -3 dB, -9 dB and -15dB.  </comment>

    <entry name='SND_TONE_0dB'>
        <comment>No attenuation</comment>
    </entry>
    <entry name='SND_TONE_m3dB'>
        <comment>-3dB</comment>
    </entry>
    <entry name='SND_TONE_m9dB'>
        <comment>-9db</comment>
    </entry>
    <entry name='SND_TONE_m15dB'>
        <comment>-15dB</comment>
    </entry>
    <entry name='SND_TONE_VOL_QTY'></entry>
</enum>

<enum name='SND_TONE_TYPE'>
    <comment> Tone types.  The DTMF Tones are used to inform the user that the number is being  composed. All the standard DTMF are available: 0 to 9, A to D,  pound and star. \n  The Comfort Tones are used to inform the user on the current state of  the call: Ringing, Busy, Unavailable... All frequencies needed to do  the standard Comfort Tones are available: 425 Hz, 950 Hz, 1400 Hz and  1800 Hz. \n  </comment>

    <entry name='SND_DTMF_0'>
        <comment>Tone when the '0' key</comment>
    </entry>
    <entry name='SND_DTMF_1'>
        <comment>Tone when the '1' key</comment>
    </entry>
    <entry name='SND_DTMF_2'>
        <comment>Tone when the '2' key</comment>
    </entry>
    <entry name='SND_DTMF_3'>
        <comment>Tone when the '3' key</comment>
    </entry>
    <entry name='SND_DTMF_4'>
        <comment>Tone when the '4' key</comment>
    </entry>
    <entry name='SND_DTMF_5'>
        <comment>Tone when the '5' key</comment>
    </entry>
    <entry name='SND_DTMF_6'>
        <comment>Tone when the '6' key</comment>
    </entry>
    <entry name='SND_DTMF_7'>
        <comment>Tone when the '7' key</comment>
    </entry>
    <entry name='SND_DTMF_8'>
        <comment>Tone when the '8' key</comment>
    </entry>
    <entry name='SND_DTMF_9'>
        <comment>Tone when the '9' key</comment>
    </entry>
    <entry name='SND_DTMF_A'></entry>
    <entry name='SND_DTMF_B'></entry>
    <entry name='SND_DTMF_C'></entry>
    <entry name='SND_DTMF_D'></entry>
    <entry name='SND_DTMF_S'>
        <comment>Tone when the * key</comment>
    </entry>
    <entry name='SND_DTMF_P'>
        <comment>Tone when the # key</comment>
    </entry>
    <entry name='SND_COMFORT_425'>
        <comment>Comfort tone at 425 Hz</comment>
    </entry>
    <entry name='SND_COMFORT_950'>
        <comment>Comfort tone at 950 Hz</comment>
    </entry>
    <entry name='SND_COMFORT_1400'>
        <comment>Comfort tone at 1400 Hz</comment>
    </entry>
    <entry name='SND_COMFORT_1800'>
        <comment>Confort tone at 1800 Hz</comment>
    </entry>
    <entry name='SND_NO_TONE'>
        <comment>No tone is emitted</comment>
    </entry>
</enum>

<enum name='SND_ITF'>
    <comment> That type provide a way to identify the different audio interface.  </comment>

    <entry name='SND_ITF_RECEIVER' value='0'></entry>
    <entry name='SND_ITF_EAR_PIECE'></entry>
    <entry name='SND_ITF_LOUD_SPEAKER'></entry>
    <entry name='SND_ITF_BLUETOOTH'></entry>
    <entry name='SND_ITF_FM'></entry>
    <entry name='SND_ITF_TV'></entry>
    <entry name='SND_ITF_QTY'>
        <comment>Number (max) of available interface to the SND driver</comment>
    </entry>
    <entry name='SND_ITF_NONE' value='0xFF'></entry>
</enum>


<enum name='SND_EQUALIZER_MODE'>
    <comment> SND equalizer modes enumerator </comment>
    <entry name="SND_EQUALIZER_OFF"        value="-1"></entry>
    <entry name="SND_EQUALIZER_NORMAL"     value="0"> </entry>
    <entry name="SND_EQUALIZER_BASS"       value="1"> </entry>
    <entry name="SND_EQUALIZER_DANCE"      value="2"> </entry>
    <entry name="SND_EQUALIZER_CLASSICAL"  value="3"> </entry>
    <entry name="SND_EQUALIZER_TREBLE"     value="4"> </entry>
    <entry name="SND_EQUALIZER_PARTY"      value="5"> </entry>
    <entry name="SND_EQUALIZER_POP"        value="6"> </entry>
    <entry name="SND_EQUALIZER_ROCK"       value="7"> </entry>
    <entry name="SND_EQUALIZER_CUSTOM"     value="8"> </entry>
    <entry name="SND_EQUALIZER_QTY">                  </entry>
</enum>

<alias name="SND_FREQUENCY_BARS">
    <comment> Audio track frequency bars </comment>
    <uint8 name="unused"   count="10"> </uint8>
</alias>


<cjoker>
</cjoker>
</archive>


<archive relative='../../../platform/vpp/include/vpp_map.xmd'  asm="no">

    
    <comment>
        This file contains the portion of the module's memory map that will be
        accessible through CoolWatcher (or any CoolXml tool). It is also used
        for the get version mechanism.
    </comment>


    

    
    

    
    
   <typedef name="VPP_MAP_ACCESS_T">
        <comment>
            Type used to define the accessible structures of the module.
        </comment>
        
   </typedef>
   
   <cjoker>

// =============================================================================
// vpp_RegisterYourself
// -----------------------------------------------------------------------------
/// This function registers the module itself to HAL so that the version and
/// the map accessor are filled. Then, the CSW get version function and the
/// CoolWatcher get version command will work.
// =============================================================================
PUBLIC VOID vpp_RegisterYourself(VOID);

    </cjoker>

</archive>

<archive relative='../../../platform/chip/boot/include/boot_usb_monitor.xmd'  asm="no">


  <include load="no" file="cs_types.h" />
  <include load="no" file="boot_usb.h" />
  <include load="no" file="chip_id.h" />
  <include load="no" file="boot.h" />

  <var name="BOOT_HOST_USB_FIFO_READ_SIZE"  value="32"/>

  <var name="BOOT_HOST_USB_BUFFER_OUT_SIZE" value="2048"/>

  <var name="BOOT_HOST_USB_BUFFER_IN_SIZE"  value="1032"/>

  <enum name="BOOT_HOST_USB_STATE_T">
    <comment>Out Ep state</comment>
    <entry name="BOOT_HOST_USB_STATE_IDLE"         />
    <entry name="BOOT_HOST_USB_STATE_HEADER"       />
    <entry name="BOOT_HOST_USB_STATE_DATA"         />
    <entry name="BOOT_HOST_USB_STATE_SXS_CMD"      />
    <entry name="BOOT_HOST_USB_STATE_SXS_ADDR"     />
    <entry name="BOOT_HOST_USB_STATE_SXS_DATA"     />
    <entry name="BOOT_HOST_USB_STATE_SXS_RID"      />
    <entry name="BOOT_HOST_USB_STATE_SXS_READ_SIZE"/>
  </enum>

  <enum name="BOOT_HOST_USB_CMD_ACCESS_T">
    <comment>Enum access value</comment>
    <entry name="BOOT_HOST_USB_CMD_ACCESS_BYTE"      value="0x00"/>
    <entry name="BOOT_HOST_USB_CMD_ACCESS_HALF_WORD" value="0x01"/>
    <entry name="BOOT_HOST_USB_CMD_ACCESS_WORD"      value="0x02"/>
    <entry name="BOOT_HOST_USB_CMD_ACCESS_BLOCK"     value="0x03"/>
  </enum>

  <enum name="BOOT_HOST_USB_RECV_STATE_T">
    <comment>Recv Task state</comment>
    <entry name="BOOT_HOST_USB_RECV_STATE_RUN" />
    <entry name="BOOT_HOST_USB_RECV_STATE_WAIT"/>
  </enum>

  <enum name="BOOT_HOST_USB_MODE_T">
    <entry name="BOOT_HOST_USB_MODE_BOOT" value="0x01"/>
    <entry name="BOOT_HOST_USB_MODE_SX"   value="0x02"/>
  </enum>

  <alias name="BOOT_HOST_USB_CMD_T">
    <uint8 name="noname">
      <bits pos="1:0" name="access"  />
      <bits pos="2"   name="internal"/>
      <bits pos="6:3" name="reserved"/>
      <bits pos="7"   name="rw"      />
    </uint8>
  </alias>

  <typedef name="BOOT_HOST_USB_MONITOR_FIFO_ELEM_T">
    <uint32 name="Addr"/>
    <uint8  name="Rid" />
    <uint16 name="Size"/>
  </typedef>

  <typedef name="BOOT_HOST_USB_MONITOR_BUFFER_IN_T">
    <uint8    name="Buffer"    count="BOOT_HOST_USB_BUFFER_IN_SIZE"/>
  </typedef>

  <typedef name="BOOT_HOST_USB_MONITOR_CTX_T">
    <instance name="MonitorMode" type="BOOT_HOST_USB_MODE_T"        />
    <uint8    name="BufferOut"   count="BOOT_HOST_USB_BUFFER_OUT_SIZE"/>
    <instance name="BufferIn"    type="BOOT_HOST_USB_MONITOR_BUFFER_IN_T"
              count="2"                                             />
    <instance name="Fifo"        type="BOOT_HOST_USB_MONITOR_FIFO_ELEM_T"
              count="BOOT_HOST_USB_FIFO_READ_SIZE"                  />
  </typedef>

  <typedef name="BOOT_HOST_USB_MONITOR_VAR_T">
    <comment>Global variable of usb monitor</comment>
    <instance name="RecvState" type="BOOT_HOST_USB_RECV_STATE_T"  />
    <instance name="State"     type="BOOT_HOST_USB_STATE_T"       />
    <uint16   name="DataSize"                                     />
    <uint16   name="Residue">
        <comment>
            Remaining from a being received USB packet.
        </comment>
    </uint16>
    <uint32   name="Addr"                                         />
    <instance name="Cmd"       type="BOOT_HOST_USB_CMD_T"         />

    <uint8  name="ReadPt"                                         />
    <uint8  name="WritePt"                                        />

    <uint8  name="CurrentBufferIn">
        <comment>
            Index in the swap buffer for data to send to the PC.
        </comment>
    </uint8>

    <uint16 name="PositionBufferIn">
        <comment>
            Position in on the buffer of data to send to the PC.
        </comment>
    </uint16>

    <ptr    name="Context"     type="BOOT_HOST_USB_MONITOR_CTX_T" />
  </typedef>

  <typedef name="boot_usb_monitor_globals" rubyconstants="yes">
  </typedef>

<cjoker>

// =============================================================================
// GLOBAL VARIABLES                                                             
// =============================================================================

EXPORT PUBLIC CONST HAL_USB_INTERFACE_DESCRIPTOR_T boot_HostUsbInterface;

// =============================================================================
// TYPES                                                                        
// =============================================================================

// =============================================================================
// BOOT_HOST_USB_CALLBACK_T
// -----------------------------------------------------------------------------
/// Callback for decoding trame
// =============================================================================
typedef VOID (*BOOT_HOST_USB_CALLBACK_T)(VOID *buffer, UINT16 size);

// =============================================================================
// BOOT_HOST_USB_CALLBACK_T
// -----------------------------------------------------------------------------
/// Callback call when a command is write in internal H2PSTATUS register
// =============================================================================
typedef VOID (*BOOT_HOST_USB_CALLBACK_H2PSTATUS_T)(UINT32 value);

// =============================================================================
// FUNCTIONS                                                                    
// =============================================================================

// =============================================================================
// boot_HostUsbOpen
// -----------------------------------------------------------------------------
/// Configure USB host
/// @param context Define the context use. The context containt read request
/// fifo and buffer for read and write on USB
/// @param callback This callback is use to change the parsing process of host
/// protocol
// =============================================================================
PUBLIC VOID boot_HostUsbOpen (BOOT_HOST_USB_MONITOR_CTX_T*       context,
                              BOOT_HOST_USB_CALLBACK_T           callback,
                              BOOT_HOST_USB_CALLBACK_H2PSTATUS_T callbackH2pstatus);

// =============================================================================
// boot_HostUsbClose
// -----------------------------------------------------------------------------
/// Close host usb (disable USB interrupt)
// =============================================================================
PUBLIC VOID  boot_HostUsbClose(VOID);

// =============================================================================
// boot_HostUsbSend
// -----------------------------------------------------------------------------
/// Generate packet must be send and send it
/// Execute the read commands.
// =============================================================================
PUBLIC UINT8 boot_HostUsbSend (VOID);

// =============================================================================
// boot_HostUsbRecv
// -----------------------------------------------------------------------------
/// Receive USB packet and parse it
///  - write command executed here.
///  - execute command are executed here.
///  - read command are put in a fifo for boot_HostUsbSend usage.
// =============================================================================
PUBLIC BOOT_MONITOR_OP_STATUS_T boot_HostUsbRecv (VOID);

// =============================================================================
// boot_HostUsbClockEnable
// -----------------------------------------------------------------------------
/// Enable usb clock
// =============================================================================
PUBLIC VOID  boot_HostUsbClockEnable(VOID);

// =============================================================================
// boot_HostUsbInit
// -----------------------------------------------------------------------------
/// Init global variables of host usb
// =============================================================================
PUBLIC VOID boot_HostUsbInit(VOID);

// =============================================================================
// boot_HostUsbDeviceCallback
// -----------------------------------------------------------------------------
/// Callback use to define the host usb descriptor. It's call by USB driver
// =============================================================================
PUBLIC HAL_USB_DEVICE_DESCRIPTOR_T* boot_HostUsbDeviceCallback(BOOL speedEnum);

// =============================================================================
// boot_HostUsbEvent
// -----------------------------------------------------------------------------
/// Send USB host event with a timeout
// =============================================================================
PUBLIC VOID boot_HostUsbEvent(UINT32 event);
</cjoker>
</archive>

<archive relative='../ChipStd/usb_structures.xmd'  h="no" asm="no">


    <include file="../../../platform/chip/boot/include/boot_usb_monitor.xmd"/> 

    <alias name="BOOT_HOST_USB_MONITOR_VAR_PTR_T">
      <ptr name="unused" type="BOOT_HOST_USB_MONITOR_VAR_T">
        <comment>
          Type of the USB Variables fixed pointer.
        </comment>
      </ptr>
    </alias>

    <instance address="BOOT_HOST_USB_MONITOR_VAR_PTR_ADDRESS" name="boot_usb_monitor"
              type="BOOT_HOST_USB_MONITOR_VAR_PTR_T" category="Memory map"/>

</archive>

<archive relative='../ChipStd/chipstd_soft_root.xmd'  h="no" asm="no">


    

    
    <typedef name="chipstd_globals" rubyconstants="yes"></typedef>
    <var name="ChipHasAp" value="CHIP_HAS_AP"/>

    
    <include file="../../../platform/chip/hal/include/hal_map_engine.xmd"/>
    <include file="cpu_error.xmd"/>
    <include file="host_monitor.xmd"/>

    
    <include file="../../../platform/chip/hal/include/hal_map.xmd"/>
    <include file="../../../platform/calib/include/calib_map.xmd"/>
    <include file="../../../platform_test/hal/gtes/include/gtes_map.xmd"/>
    <include file="../../../platform/chip/pal/include/pal_map.xmd"/>
    <include file="../../../platform/chip/bcpu/spal/include/spal_map.xmd"/>
    <include file="../../../platform/chip/bcpu/spp/include/spp_map.xmd"/>
    <include file="../../../platform/chip/bcpu/spc/include/spc_map.xmd"/>
    <include file="../../../platform/edrv/rfd/include/rfd_map.xmd"/>   
    <include file="../../../platform/edrv/memd/include/memd_map.xmd"/> 
    <include file="../../../platform/edrv/pmd/include/pmd_map.xmd"/>   
    <include file="../../../platform/edrv/lcdd/include/lcdd_map.xmd"/> 
    <include file="../../../platform/stack/include/stack_map.xmd"/>
    <include file="../../../platform/chip/boot/include/boot_map.xmd"/>

    <include file="../../../platform/base/sx/include/sx_map.xmd"/>     
    <include file="../../../platform/base/std/include/std_map.xmd"/>   
    <include file="../../../platform/svc/ars/include/ars_map.xmd"/>   
    
    <include file="../../../platform/svc/aps/include/aps_map.xmd"/> 
    <include file="../../../platform/svc/vois/include/vois_map.xmd"/> 
    <include file="../../../platform/stack/l1/include/l1_map.xmd"/> 
    <include file="../../../toolpool/flash_programmer/flash_prog_map.xmd"/> 
    <include file="../../../platform/csw/include/csw_map.xmd"/> 
    <include file="../../../application/coolmmi/include/mmi_map.xmd" optional="yes"/> 
    <include file="../../../platform/edrv/aud/include/aud_map.xmd"/> 
    <include file="../../../platform/mdi/include/mdi_map.xmd" optional="yes"/> 
    <include file="../../../platform/edrv/btd/include/btd_map.xmd" optional="yes"/> 

    <include file="../../../at/include/at_map.xmd" optional="yes"/> 

    
    <include file="../../../platform/base/common/include/baseband_defs.xmd"/> 
    <include file="../../../platform/base/sx/include/sx_task.xmd"/> 
    <include file="../../../platform/chip/bcpu/spp/include/spp_gsm.xmd"/> 
    <include file="../../../platform/chip/hal/include/hal_speech.xmd"/> 
    <include file="../../../platform/chip/hal/include/hal_uart.xmd"/> 
    <include file="../../../platform/chip/hal/include/hal_usb_descriptor_types.xmd"/> 
    <include file="../../../platform/include/gfx_types.xmd"/> 
    <include file="../../../platform/include/snd_types.xmd"/> 
    <include file="../../../platform/vpp/include/vpp_map.xmd"/> 

    
    <include>
        <comment>This conditionnal include triggers the use of VOC or not. The main purpose is too have a lighter XML, especially when loaded in CoolWatcher and all related tools.</comment>
        <case cond="(USE_VOC_XMD == 1)" file="../../../platform/vpp/include/vpp_map.xcw"/>
        <default                        file="no_voc.dummy" optional="yes"/>
    </include>

    <include>
        <comment>
            USB Structures and instants.
            Driver variables and boot monitor context.
        </comment>
        <case cond="(CHIP_HAS_USB == 1)" file="usb_structures.xmd"/>
        <default                         file="no_usb.dummy" optional="yes"/>
    </include>

    <include>
        <comment>Modem-AP mailbox structures and instants</comment>
        <case cond="(CHIP_HAS_AP == 1)" file="ap_mailbox.xmd"/>
        <default                        file="no_ap.dummy" optional="yes"/>
    </include>

    <include>
        <comment>XCPU-WCPU mailbox structures and instants</comment>
        <case cond="(CHIP_HAS_WCPU == 1)" file="wd_mailbox.xmd"/>
        <default                          file="no_wd.dummy" optional="yes"/>
    </include>

    
    
    <typedef name="MAP_TABLE_T">
        <comment>
            Type used to access the version and the memory map of a soft module.
            Must be compatible with the type HAL_MAP_ID_T of "hal_map_engine.xmd".
        </comment>
        <ptr name="hal_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="hal_access"     type="HAL_MAP_ACCESS_T"/>
        <ptr name="pal_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="pal_access"     type="PAL_MAP_ACCESS_T"/>
        <ptr name="spal_version"   type="HAL_MAP_VERSION_T"/>
        <ptr name="spal_access"    type="SPAL_MAP_ACCESS_T"/>
        <ptr name="spp_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="spp_access"     type="SPP_MAP_ACCESS_T"/>
        <ptr name="spc_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="spc_access"     type="SPC_MAP_ACCESS_T"/>
        <ptr name="rfd_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="rfd_access"     type="RFD_MAP_ACCESS_T"/>
        <ptr name="free1_version"  type="HAL_MAP_VERSION_T"/>
        <ptr name="free1_access"   type="FREE1_MAP_ACCESS_T"/>
        <ptr name="at_version"     type="HAL_MAP_VERSION_T"/>
        <ptr name="at_access"      type="AT_MAP_ACCESS_T"/>
        <ptr name="memd_version"   type="HAL_MAP_VERSION_T"/>
        <ptr name="memd_access"    type="MEMD_MAP_ACCESS_T"/>
        <ptr name="pmd_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="pmd_access"     type="PMD_MAP_ACCESS_T"/>
        <ptr name="stack_version"  type="HAL_MAP_VERSION_T"/>
        <ptr name="stack_access"   type="STACK_MAP_ACCESS_T"/>
        <ptr name="vpp_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="vpp_access"     type="VPP_MAP_ACCESS_T"/>
        <ptr name="sx_version"     type="HAL_MAP_VERSION_T"/>
        <ptr name="sx_access"      type="SX_MAP_ACCESS_T"/>
        <ptr name="std_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="std_access"     type="STD_MAP_ACCESS_T"/>
        <ptr name="lcdd_version"   type="HAL_MAP_VERSION_T"/>
        <ptr name="lcdd_access"    type="LCDD_MAP_ACCESS_T"/>
        <ptr name="ars_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="ars_access"     type="ARS_MAP_ACCESS_T"/>
	
        <ptr name="aps_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="aps_access"     type="APS_MAP_ACCESS_T"/>
        <ptr name="vois_version"   type="HAL_MAP_VERSION_T"/>
        <ptr name="vois_access"    type="VOIS_MAP_ACCESS_T"/>
        <ptr name="calib_version"  type="HAL_MAP_VERSION_T"/>
        <ptr name="calib_access"   type="CALIB_MAP_ACCESS_T"/>
        <ptr name="gtes_version"   type="HAL_MAP_VERSION_T"/>
        <ptr name="gtes_access"    type="GTES_MAP_ACCESS_T"/>
        <ptr name="flash_prog_version"   type="HAL_MAP_VERSION_T"/>
        <ptr name="flash_prog_access"    type="FLASH_PROG_MAP_ACCESS_T"/>
        <ptr name="csw_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="csw_access"     type="CSW_MAP_ACCESS_T"/>
        <ptr name="mmi_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="mmi_access"     type="MMI_MAP_ACCESS_T"/>
        <ptr name="aud_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="aud_access"     type="AUD_MAP_ACCESS_T"/>
        <ptr name="mdi_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="mdi_access"     type="VOID"/>
        <ptr name="btd_version"    type="HAL_MAP_VERSION_T"/>
        <ptr name="btd_access"     type="BTD_MAP_ACCESS_T"/>
	
    </typedef>

    
    <alias name="MAP_TABLE_PTR_T">
        <ptr name="unused" type="MAP_TABLE_T">
          <comment>
            Type of the fixed pointer for the map table.
          </comment>
        </ptr>
    </alias>

    
    <instance address="MAP_TABLE_PTR_ADDRESS" name="map_table" type="MAP_TABLE_PTR_T"
              category="Memory map">
      <comment>
        Fixed pointer to access the software memory map.
      </comment>
    </instance>

    
    <instance address="HOST_MONITOR_CONTROL_ADDRESS" name="host_monitor_control" type="HOST_MONITOR_CONTROL_T"
        category="Memory map">
        <comment>
            Structure to access the host monitor executor control context.
        </comment>
    </instance>

    
    <alias name="BOOT_SECTOR_STRUCT_PTR_T">
        <ptr name="unused" type="BOOT_SECTOR_STRUCT_T">
          <comment>
            Type of the fixed pointer for the boot sector struct.
          </comment>
        </ptr>
    </alias>

    
    <instance address="BOOT_SECTOR_STRUCT_PTR_ADDRESS" name="boot_sector_struct_ptr" type="BOOT_SECTOR_STRUCT_PTR_T"
        category="Memory map">
        <comment>
            Structure to access the boot sector EBC RAM context.
        </comment>
    </instance>

    
    <instance address="XCPU_ERROR_INFO_ADDRESS" name="xcpu_error_info" type="CPU_ERROR_INFO_T"
        category="Debug info">
        <comment>
            Structure to access the XCPU context, in case of crash only.
        </comment>
    </instance>

    
    <instance address="BCPU_ERROR_INFO_ADDRESS" name="bcpu_error_info" type="CPU_ERROR_INFO_T"
        category="Debug info">
        <comment>
            Structure to access the BCPU context, in case of crash only.
        </comment>
    </instance>

    
    <alias name='BOOT_SECTOR_CODE_T'>
        <uint32 name='unused'>
            <comment>Type of the boot sector code.</comment>
        </uint32>
    </alias>
    <instance address="BOOT_SECTOR_CODE_ADDRESS" name="boot_sector_code" type="BOOT_SECTOR_CODE_T"
        category="Memory map">
        <comment>
            First word of the boot sector code.
            This does not take the magic tag into account.
        </comment>
    </instance>

    
    <alias name='ROM_VERSION_T'>
        <uint32 name='unused'>
            <comment>Type of the ROMed code version.</comment>
        </uint32>
    </alias>
    <instance address="ROM_VERSION_ADDRESS" name="rom_version" type="ROM_VERSION_T"
        category="Memory map">
        <comment>
            Version of the ROMed code.
        </comment>
    </instance>

</archive>

<archive relative='gallite_soft_root.xmd'  h="no" asm="no">


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    <include file="../ChipStd/chipstd_soft_root.xmd"/>

</archive>


</bigarchive>
