<bigarchive>

<archive relative="****phantomglobalvars****">

</archive>
<archive relative='globals.xml'  vhdlpkg="chip_cfg_pkg">


  
  <var name="NB_BITS_ADDR" value="26" ><comment>AHB Address bus size</comment></var>

  




  <var name="SYS_NB_BITS_MASTER" value="4" ><comment>System Ahb Bus Configuration</comment></var>
  
  <enum name="Sys_Master_Id">
    <entry name="SYS_MID_DUMMY"/>
    <entry name="SYS_MID_BIST"/>
    <bound name="SYS_MID_RR_Start"><comment>After this starts the Round Robib Pool</comment></bound>
    <entry name="SYS_MID_DMA"/>
    <entry name="SYS_MID_XCPU"/>
    <entry name="SYS_MID_AHB2AHB"/>
    <entry name="SYS_MID_IFC"/>
    <entry name="SYS_MID_AXI2AHB"/>
    <bound name="SYS_MID_RR_End"/>
  </enum>
  <var name="SYS_NB_STATIC_MASTER" value="SYS_MID_RR_Start-1"/>
  <var name="SYS_NB_MASTERS" value="SYS_MID_RR_End-1"/>

  <var name="SYS_NB_BITS_SLAVE" value="4"/>
  
  <enum name="Sys_slave_Id">
    <entry name="SYS_SID_DUMMY"/>
    <entry name="SYS_SID_MEM_BRIDGE"/>
    <entry name="SYS_SID_AHB2AHB"/>
    <entry name="SYS_SID_IFC"/>
    <entry name="SYS_SID_DP_AP"/>
    <entry name="SYS_SID_AHB2AXI"/>
    <entry name="SYS_SID_EXT_AHB"/>
    <bound name="SYS_SID_End"/>
  </enum>
  <var name="SYS_NB_SLAVES" value="SYS_SID_End-1" />

  <var name="SYS_NB_BITS_PSEL" value="5" ><comment>System Apb Bus Configuration</comment></var>
  <var name="SYS_NB_BITS_PADDR" value="12"></var>

  <var name="SYS_APB_STEP" value="exp2(SYS_NB_BITS_PADDR)"/>

  
  <enum name="Sys_Module_Id">
    <entry name="SYS_ID_SYS_CTRL"/>
    <entry name="SYS_ID_IRQ"/>
    <entry name="SYS_ID_TIMER"/>
    <entry name="SYS_ID_EBC"/>
    <entry name="SYS_ID_DMA"/>
    <entry name="SYS_ID_IFC"/>
    <entry name="SYS_ID_CALENDAR"/>
    <entry name="SYS_ID_COMREGS"/>
    <entry name="SYS_ID_GPIO"/>
    <entry name="SYS_ID_CFG"/>
    <entry name="SYS_ID_COMREGS_AP"/>
    <entry name="SYS_ID_PAGE_SPY"/>
    <bound name="FIRST_SYS_ID_DATA"/>
    <entry name="SYS_ID_RF_SPI"/>
    <entry name="SYS_ID_TCU"/>
    <entry name="SYS_ID_SYS_AHBC_MON"/>
    <entry name="SYS_ID_BB_AHBC_MON"/>
    
    <entry name="SYS_ID_SCI1"><comment>MUST be at PSEL16. The following modules are linked to ifc dma req with 2 requests per module</comment></entry>
    <entry name="SYS_ID_SCI2"/>
    <entry name="SYS_ID_SCI3"/>
    <entry name="SYS_ID_SPI1"/>
    <entry name="SYS_ID_SPI2"/>
    <entry name="SYS_ID_DEBUG_UART"/>
    <bound name="LAST_SYS_ID_DATA"><comment>The above modules are linked to ifc dma req with 2 requests per module</comment></bound>
    <entry name="SYS_ID_XCPU_REG"/>
    <entry name="SYS_ID_XCPU_TAG"/>
    <entry name="SYS_ID_XCPU_IDATA"/>
    <entry name="SYS_ID_XCPU_DDATA"/>
    <entry name="SYS_ID_BIST"/>
    <bound name="SYS_NB_PSEL"></bound>
  </enum>
    <var name="SYS_ID_DEBUG_HOST" value="exp2(SYS_NB_BITS_PSEL)-1"><comment>The debug host is placed at last PSEL31 in the IFC</comment></var>

  
  <enum name="Sys_Ifc_Request_IDs">
    <entry name="SYS_ID_TX_SCI1"/>      
    <entry name="SYS_ID_RX_SCI1"/>      
    <entry name="SYS_ID_TX_SCI2"/>      
    <entry name="SYS_ID_RX_SCI2"/>      
    <entry name="SYS_ID_TX_SCI3"/>      
    <entry name="SYS_ID_RX_SCI3"/>      
    <entry name="SYS_ID_TX_SPI1"/>      
    <entry name="SYS_ID_RX_SPI1"/>      
    <entry name="SYS_ID_TX_SPI2"/>      
    <entry name="SYS_ID_RX_SPI2"/>      
    <entry name="SYS_ID_TX_DEBUG_UART"/>
    <entry name="SYS_ID_RX_DEBUG_UART"/>
  
    <bound name="SYS_NB_DMA_REQ"></bound>
  </enum>
  <var name="SYS_NB_DMA_REQ_WIDTH" value="4"></var>

    
    <enum name="Sys_Irq_Id">
        <entry name="SYS_IRQ_TCU0"><comment>System IRQ IDs<br/>Pulse IRQ</comment></entry>
        <entry name="SYS_IRQ_TCU1"/>
        <entry name="SYS_IRQ_FRAME"/>
        <bound name="SYS_NB_IRQ_PULSE"><comment>Number of Pulse IRQ</comment></bound>
        <entry name="SYS_IRQ_COM0"><comment>Level IRQ</comment></entry>
        <entry name="SYS_IRQ_COM1"/>
        <entry name="SYS_IRQ_COM0_AP"/>
        <entry name="SYS_IRQ_COM1_AP"/>
        <entry name="SYS_IRQ_DMA"/>
        <entry name="SYS_IRQ_TIMERS"/>
        <entry name="SYS_IRQ_OS_TIMER"/>
        <entry name="SYS_IRQ_CALENDAR"/>
        <entry name="SYS_IRQ_SPI1"/>
        <entry name="SYS_IRQ_SPI2"/>
        <entry name="SYS_IRQ_DEBUG_UART"/>
        <entry name="SYS_IRQ_SCI1"/>
        <entry name="SYS_IRQ_SCI2"/>
        <entry name="SYS_IRQ_SCI3"/>
        <entry name="SYS_IRQ_RF_SPI"/>
        <entry name="SYS_IRQ_LPS"/>
        <entry name="SYS_IRQ_PMU"/>
        <entry name="SYS_IRQ_GPIO"/>
        <entry name="SYS_IRQ_VOC"/>
        <entry name="SYS_IRQ_AUIFC0"/>
        <entry name="SYS_IRQ_AUIFC1"/>
        <entry name="SYS_IRQ_AP"/>
        <bound name="SYS_IRQ_QTY"><comment>Number of IRQ handled by the production driver</comment></bound>
        <bound name="SYS_NB_IRQ"><comment>Number of IRQ</comment></bound>
    </enum>
    <var name="SYS_NB_IRQ_LEVEL" value="SYS_NB_IRQ - SYS_NB_IRQ_PULSE"><comment>Number of Level IRQ</comment></var>
    
    <range name="SYS_IRQ_TCU" left="SYS_IRQ_TCU1" right="SYS_IRQ_TCU0" />
    <range name="SYS_IRQ_COMREG" left="SYS_IRQ_COM1" right="SYS_IRQ_COM0" />
    <range name="SYS_IRQ_COMREG_AP" left="SYS_IRQ_COM1_AP" right="SYS_IRQ_COM0_AP" />

  

  <var name="BB_SRAM_ADDR_WIDTH" value="13" ><comment>The Baseband SRam size</comment></var>
  <var name="BB_SRAM_SIZE" value="32*1024" />

  <var name="BB_NB_BITS_MASTER" value="3" ><comment>Baseband Ahb Bus Configuration</comment></var>
  
  <enum name="BB_Master_Id">
    <entry name="BB_MID_DUMMY"/>
    <entry name="BB_MID_BIST"/>
    <entry name="BB_MID_IFC"/>
    <bound name="BB_MID_RR_Start"><comment>After this starts the Round Robib Pool</comment></bound>
    <entry name="BB_MID_BCPU"/>
    <entry name="BB_MID_AHB2AHB"/>
    <bound name="BB_MID_RR_End"/>
  </enum>
  <var name="BB_NB_STATIC_MASTER" value="BB_MID_RR_Start-1"/>
  <var name="BB_NB_MASTERS" value="BB_MID_RR_End-1"/>
  <var name="BB_MAX_BURST_SIZE" value="4"/>
  <var name="BB_MAX_BURST_BITS" value="2"/>
  <var name="BB_NB_BITS_SLAVE" value="3"/>
  
  <enum name="BB_slave_Id">
    <entry name="BB_SID_DUMMY"/>
    <entry name="BB_SID_MEM_BRIDGE"/>
    <entry name="BB_SID_AHB2AHB"/>
    <entry name="BB_SID_IFC"/>
    <entry name="BB_SID_SRAM"/>
    <bound name="BB_SID_End"/>
  </enum>
  <var name="BB_NB_SLAVES" value="BB_SID_End-1" />

  <var name="BB_NB_BITS_PSEL" value="5"><comment>BaseBand Apb Bus Configuration</comment></var>
  <var name="BB_NB_BITS_PADDR" value="12"></var>

  <var name="BB_APB_STEP" value="exp2(BB_NB_BITS_PADDR)"/>

  
  <enum name="BB_Module_Id">
    <entry name="BB_ID_XCOR"/>
    <entry name="BB_ID_IFC"/>
    <entry name="BB_ID_IRQ"/>
    <entry name="BB_ID_ITLV"/>
    <entry name="BB_ID_VITERBI"/>
    <entry name="BB_ID_A5"/>
    <entry name="BB_ID_RF"/>
    <entry name="BB_ID_CP2"/>
    <entry name="BB_ID_BIST"/>
    <entry name="BB_ID_BCPU_REG"/>
    <entry name="BB_ID_BCPU_TAG"/>
    <entry name="BB_ID_BCPU_IDATA"/>
    <entry name="BB_ID_BCPU_DDATA"/>
    <entry name="BB_ID_COMREGS"/>
    <entry name="BB_ID_EXCOR"/>
    <entry name="BB_ID_EVITAC"/>
    <entry name="BB_ID_CORDIC"/>
    <bound name="BB_NB_PSEL"><comment>The maximum number of slaves is currently exp2(BB_NB_BITS_PSEL).</comment></bound>
  </enum>

    
    <enum name="BB_Irq_Id">
        <entry name="BB_IRQ_TCU0"><comment>Baseband IRQ IDs<br/>Pulse IRQ</comment></entry>
        <entry name="BB_IRQ_TCU1"/>
        <entry name="BB_IRQ_FRAME"/>
        <bound name="BB_NB_IRQ_PULSE"><comment>Number of Pulse IRQ</comment></bound>
        <entry name="BB_IRQ_COM0"><comment>Level IRQ</comment></entry>
        <entry name="BB_IRQ_COM1"/>
        <entry name="BB_IRQ_IFC0"/>
        <entry name="BB_IRQ_IFC1"/>
        <entry name="BB_IRQ_IFC2"/>
        <entry name="BB_IRQ_IFC3"/>
        <entry name="BB_IRQ_RF_IF"/>
        <entry name="BB_IRQ_ITLV"/>
        <entry name="BB_IRQ_VITAC"/>
        <entry name="BB_IRQ_XCOR"/>
        <bound name="BB_NB_IRQ"><comment>Number of IRQ</comment></bound>
    </enum>
    <var name="BB_NB_IRQ_LEVEL" value="BB_NB_IRQ - BB_NB_IRQ_PULSE"><comment>Number of Level IRQ</comment></var>

    
    <range name="BB_IRQ_TCU" left="BB_IRQ_TCU1" right="BB_IRQ_TCU0" />
    <range name="BB_IRQ_COMREG" left="BB_IRQ_COM1" right="BB_IRQ_COM0" />
    <range name="BB_IRQ_IFC" left="BB_IRQ_IFC3" right="BB_IRQ_IFC0" />


  
  <var name="BB_SYMBOL_SIZE" value="13"><comment>RF Input samples size (signed)</comment></var>
  <var name="VITAC_MULT_SIZE" value="14"><comment>Vitac Multipliers size</comment></var>
  <var name="NB_DBG_SYS_SPY" value="11"><comment>Total bits numbers of signals to spy on the SYS side</comment></var>
  <var name="NB_DBG_BB_SPY" value="28"><comment>Total bits numbers of signals to spy on the BB side</comment></var>


  

  <var name="AP_NB_BITS_ADDR" value="32"><comment>AP AHB and APB Address bus size</comment></var>



  
  <var name="AP_AHB0_NB_BITS_MASTER" value="1" ><comment>AP Ahb0 Bus Configuration</comment></var>
  
  <enum name="AP_AHB0_Master_Id">
    <entry name="AP_AHB0_MID_DUMMY"/>
    <entry name="AP_AHB0_MID_AHB0"/>
    <bound name="AP_AHB0_MID_RR_Start"><comment>After this starts the Round Robib Pool</comment></bound>
    <bound name="AP_AHB0_MID_RR_End"/>
  </enum>
  <var name="AP_AHB0_NB_STATIC_MASTER" value="AP_AHB0_MID_RR_Start-1"/>
  <var name="AP_AHB0_NB_MASTERS" value="AP_AHB0_MID_RR_End-1"/>
  <var name="AP_AHB0_NB_BITS_SLAVE" value="3"/>
  
  <enum name="AP_AHB0_slave_Id">
    <entry name="AP_AHB0_SID_DUMMY"/>
    <entry name="AP_AHB0_SID_SLAVE1"/>
    <entry name="AP_AHB0_SID_SLAVE2"/>
    <entry name="AP_AHB0_SID_SLAVE3"/>
    <entry name="AP_AHB0_SID_SLAVE4"/>
    <entry name="AP_AHB0_SID_SLAVE5"/>
    <bound name="AP_AHB0_SID_END"/>
  </enum>
  <var name="AP_AHB0_NB_SLAVES" value="AP_AHB0_SID_END-1" />

  
  <var name="AP_AHB1_NB_BITS_MASTER" value="1" ><comment>AP Ahb1 Bus Configuration</comment></var>
  
  <enum name="AP_AHB1_Master_Id">
    <entry name="AP_AHB1_MID_DUMMY"/>
    <entry name="AP_AHB1_MID_AHB1"/>
    <bound name="AP_AHB1_MID_RR_Start"><comment>After this starts the Round Robib Pool</comment></bound>
    <bound name="AP_AHB1_MID_RR_End"/>
  </enum>
  <var name="AP_AHB1_NB_STATIC_MASTER" value="AP_AHB1_MID_RR_Start-1"/>
  <var name="AP_AHB1_NB_MASTERS" value="AP_AHB1_MID_RR_End-1"/>
  <var name="AP_AHB1_NB_BITS_SLAVE" value="3"/>
  
  <enum name="AP_AHB1_slave_Id">
    <entry name="AP_AHB1_SID_DUMMY"/>
    <entry name="AP_AHB1_SID_SLAVE1"/>
    <entry name="AP_AHB1_SID_SLAVE2"/>
    <entry name="AP_AHB1_SID_SLAVE3"/>
    <entry name="AP_AHB1_SID_SLAVE4"/>
    <entry name="AP_AHB1_SID_SLAVE5"/>
    <bound name="AP_AHB1_SID_END"/>
  </enum>
  <var name="AP_AHB1_NB_SLAVES" value="AP_AHB1_SID_END-1" />

  
  <var name="AP_APB0_NB_BITS_PSEL" value="3"><comment>BaseBand Apb Bus Configuration</comment></var>
  <var name="AP_APB0_NB_BITS_PADDR" value="16"></var>
  <var name="AP_APB0_STEP" value="exp2(AP_APB0_NB_BITS_PADDR)"/>

  
  <enum name="AP_APB0_Module_Id">
    <entry name="AP_APB0_ID_IRQ"/>
    <entry name="AP_APB0_ID_IMEM"/>
    <entry name="AP_APB0_ID_DMA"/>
    <entry name="AP_APB0_ID_VPU"/>
    <entry name="AP_APB0_ID_GOUDA"/>
    <entry name="AP_APB0_ID_CAMERA"/>
    <bound name="AP_APB0_FIRST_ID_DATA"/>
    <bound name="AP_APB0_LAST_ID_DATA"/>
    <bound name="AP_APB0_NB_PSEL"><comment>The maximum number of slaves is currently exp2(AP_APB0_NB_BITS_PSEL).</comment></bound>
  </enum>

  
  <var name="AP_APB1_NB_BITS_PSEL" value="4"><comment>BaseBand Apb Bus Configuration</comment></var>
  <var name="AP_APB1_NB_BITS_PADDR" value="16"></var>
  <var name="AP_APB1_STEP" value="exp2(AP_APB1_NB_BITS_PADDR)"/>

  
  <enum name="AP_APB1_Module_Id">
    <entry name="AP_APB1_ID_SYSCTRL"/>
    <entry name="AP_APB1_ID_TIMER"/>
    <entry name="AP_APB1_ID_KEYPAD"/>
    <entry name="AP_APB1_ID_GPIO"/>
    <entry name="AP_APB1_ID_PWM"/>
    <entry name="AP_APB1_ID_I2C1"/>
    <entry name="AP_APB1_ID_I2C2"/>
    <entry name="AP_APB1_ID_I2C3"/>
    <entry name="AP_APB1_ID_COMREGS"/>
    <entry name="AP_APB1_ID_DMC"/>
    <entry name="AP_APB1_ID_DDRPHY"/>
    <entry name="AP_APB1_ID_DEBUG"/>
    <entry name="AP_APB1_ID_RSVD12"/>
    <entry name="AP_APB1_ID_RSVD13"/>
    <entry name="AP_APB1_ID_AIF"/>
    <entry name="AP_APB1_ID_IFC"/>
    <bound name="AP_APB1_FIRST_ID_DATA"/>
    <bound name="AP_APB1_LAST_ID_DATA"/>
    <bound name="AP_APB1_NB_PSEL"><comment>The maximum number of slaves is currently exp2(AP_APB1_NB_BITS_PSEL).</comment></bound>
  </enum>

  
  <var name="AP_APB2_NB_BITS_PSEL" value="4"><comment>BaseBand Apb Bus Configuration</comment></var>
  <var name="AP_APB2_NB_BITS_PADDR" value="16"></var>
  <var name="AP_APB2_STEP" value="exp2(AP_APB2_NB_BITS_PADDR)"/>

  
  <enum name="AP_APB2_Module_Id">
    <bound name="AP_APB2_FIRST_ID_DATA"/>
    
    <entry name="AP_APB2_ID_UART1"><comment>MUST be at PSEL0. The following modules are linked to ifc dma req with 2 requests per module</comment></entry>
    <entry name="AP_APB2_ID_UART2"/>
    <entry name="AP_APB2_ID_SPI1"/>
    <entry name="AP_APB2_ID_SPI2"/>
    <entry name="AP_APB2_ID_SPI3"/>
    <entry name="AP_APB2_ID_SDMMC1"/>
    <entry name="AP_APB2_ID_SDMMC2"/>
    <entry name="AP_APB2_ID_SDMMC3"/>
    <entry name="AP_APB2_ID_NFSC"/>
    <entry name="AP_APB2_ID_UART3"/>
    <bound name="AP_APB2_LAST_ID_DATA"><comment>The above modules are linked to ifc dma req with 2 requests per module</comment></bound>
    <entry name="AP_APB2_ID_RSVD10"/>
    <entry name="AP_APB2_ID_RSVD11"/>
    <entry name="AP_APB2_ID_RSVD12"/>
    <entry name="AP_APB2_ID_RSVD13"/>
    <entry name="AP_APB2_ID_RSVD14"/>
    <entry name="AP_APB2_ID_IFC"/>
    <bound name="AP_APB2_NB_PSEL"><comment>The maximum number of slaves is currently exp2(AP_APB2_NB_BITS_PSEL).</comment></bound>
  </enum>

  
  <enum name="AP_APB2_Ifc_Request_IDs">
    <entry name="AP_APB2_IFC_ID_TX_UART1"/>  
    <entry name="AP_APB2_IFC_ID_RX_UART1"/>  
    <entry name="AP_APB2_IFC_ID_TX_UART2"/>  
    <entry name="AP_APB2_IFC_ID_RX_UART2"/>  
    <entry name="AP_APB2_IFC_ID_TX_SPI1"/>   
    <entry name="AP_APB2_IFC_ID_RX_SPI1"/>   
    <entry name="AP_APB2_IFC_ID_TX_SPI2"/>   
    <entry name="AP_APB2_IFC_ID_RX_SPI2"/>   
    <entry name="AP_APB2_IFC_ID_TX_SPI3"/>   
    <entry name="AP_APB2_IFC_ID_RX_SPI3"/>   
    <entry name="AP_APB2_IFC_ID_TX_SDMMC1"/> 
    <entry name="AP_APB2_IFC_ID_RX_SDMMC1"/> 
    <entry name="AP_APB2_IFC_ID_TX_SDMMC2"/> 
    <entry name="AP_APB2_IFC_ID_RX_SDMMC2"/> 
    <entry name="AP_APB2_IFC_ID_TX_SDMMC3"/> 
    <entry name="AP_APB2_IFC_ID_RX_SDMMC3"/> 
    <entry name="AP_APB2_IFC_ID_TX_NFSC"/>   
    <entry name="AP_APB2_IFC_ID_RX_NFSC"/>   
    <entry name="AP_APB2_IFC_ID_TX_UART3"/>  
    <entry name="AP_APB2_IFC_ID_RX_UART3"/>  
    <bound name="AP_APB2_IFC_END"/>
  </enum>
  
  <var name="AP_APB2_IFC_NB_DMA_REQ" value="AP_APB2_IFC_END"></var>
  <var name="AP_APB2_IFC_NB_DMA_REQ_WIDTH" value="5"></var>

    
    <enum name="AP_Irq_Id">
        <entry name="AP_IRQ_PULSE"><comment>AP IRQ IDs<br/>Pulse IRQ</comment></entry> 
        <bound name="AP_NB_IRQ_PULSE"><comment>Number of Pulse IRQ</comment></bound>
        <entry name="AP_IRQ_I2C"><comment>Level IRQ</comment></entry>
        <entry name="AP_IRQ_NFSC"/>
        <entry name="AP_IRQ_SDMMC1"/>
        <entry name="AP_IRQ_SDMMC2"/>
        <entry name="AP_IRQ_SDMMC3"/>
        <entry name="AP_IRQ_SPI1"/>
        <entry name="AP_IRQ_SPI2"/>
        <entry name="AP_IRQ_SPI3"/>
        <entry name="AP_IRQ_UART1"/>
        <entry name="AP_IRQ_UART2"/>
        <entry name="AP_IRQ_UART3"/>
        <entry name="AP_IRQ_GPIO1"/>
        <entry name="AP_IRQ_GPIO2"/>
        <entry name="AP_IRQ_GPIO3"/>
        <entry name="AP_IRQ_KEYPAD"/>
        <entry name="AP_IRQ_TIMERS"/>
        <entry name="AP_IRQ_OSTIMER"/>
        <entry name="AP_IRQ_COM0"/>
        <entry name="AP_IRQ_COM1"/>
        <entry name="AP_IRQ_USBC"/>
        <entry name="AP_IRQ_DMC"/>
        <entry name="AP_IRQ_DMA"/>
        <entry name="AP_IRQ_CAMERA"/>
        <entry name="AP_IRQ_GOUDA"/>
        <entry name="AP_IRQ_GPU"/>
        <entry name="AP_IRQ_JPG_VPU"/>
        <entry name="AP_IRQ_HOST_VPU"/>
        <entry name="AP_IRQ_VOC"/>
        <entry name="AP_IRQ_AUIFC0"/>
        <entry name="AP_IRQ_AUIFC1"/>
        <entry name="AP_IRQ_L2CC"/>
        <bound name="AP_IRQ_QTY"><comment>Number of IRQ handled by the production driver</comment></bound>
        <bound name="AP_NB_IRQ"><comment>Number of IRQ</comment></bound>
    </enum>
    <var name="AP_NB_IRQ_LEVEL" value="AP_NB_IRQ - AP_NB_IRQ_PULSE"><comment>Number of Level IRQ</comment></var>
    




  <cjoker>
    /// XHALT macro will send the event 0x4a17 to the debug host and
    /// will stall the XCPU.  The XCPU can be released from Coolwatcher
    /// by issuing a xrbp command.
    #define XHALT { \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
        while (hwp_debugHost->event != DEBUG_HOST_EVENT0_SEMA); \
        hwp_debugHost->event = 0x4a17; \
        hwp_sysCtrl->XCpu_Dbg_BKP |= SYS_CTRL_STALLED; \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
    }
  </cjoker>


</archive>

<archive relative='global_macros.xml'  asm="no">


<cjoker>

#define KSEG0(addr)     ( (addr) | 0x80000000 )
#define KSEG1(addr)     ( (addr) | 0xa0000000 )


/* Define access cached or uncached */
#define MEM_ACCESS_CACHED(addr)     ((UINT32*)((UINT32)(addr)&amp;0xdfffffff))
#define MEM_ACCESS_UNCACHED(addr)   ((UINT32*)((UINT32)(addr)|0x20000000))

/* Register access for assembly */
#define BASE_HI(val) (((0xa0000000 | val) &amp; 0xffff8000) + (val &amp; 0x8000))
#define BASE_LO(val) (((val) &amp; 0x7fff) - (val &amp; 0x8000))


/* to extract bitfield from register value */
#define GET_BITFIELD(dword, bitfield) (((dword) &amp; (bitfield ## _MASK)) &gt;&gt; (bitfield ## _SHIFT))

#define EXP2(n) (1&lt;&lt;(n))

</cjoker>

</archive>
<archive relative='bb2g_generic_config.xml' >

  

    <var name="FPGA_OPTION" value="0" >
        <comment>0= chip option; 1= FPGA option
        </comment>
    </var>

    <var name="BB_OPTION" value="1" >
        <comment>0= no baseband; 1= baseband included
        </comment>
    </var>

    <var name="USE_TEST_MASTER" value="0" >
        <comment>0= Nothing; 1= BIST; 2= TEST MASTER
        </comment>
    </var>

    <var name="USE_SYS_AHBC_MON" value="1" >
        <comment>0= no monitor; 1=monitor included
        </comment>
    </var>
    
    <var name="HAVE_DEBUG_HOST_SEL" value="0" >
        <comment>0= no debug host sel register as on test chip; 1=debug host sel register included
        </comment>
    </var>

    <var name="AIF_OPTION" value="0" >
        <comment>0= No aif channels (0,1) ; 1= All 3 channels
        </comment>
    </var>

    <var name="NB_GPIO" value="32" >
        <comment>GPIO/GPO OPTIONS: numbers
        </comment>
    </var>
    <var name="NB_GPIO_INT" value="8" />
    <var name="NB_GPO" value="5" />

    <var name="SYS_IFC_NB_STD_CHANNEL" value="3" >
        <comment>System Ifc Number of generic channel (range 2 to 7)
        </comment>
    </var>

    <var name="DMA_OPTION" value="1" >
        <comment>0= No DMA ; 1= DMA included
        </comment>
    </var>

    <var name="SYS_PERIPH_OPTION" value="1" >
        <comment>0 = no SPI, no GPADC, no UART1; 1 = SPI, GPADC included 
        </comment>
    </var>

    <var name="SPI1_NB_CS" value="2" >
        <comment>number of SPI1 CS
        </comment>
    </var>

    <var name="SPI1_NB_DI" value="2" >
        <comment>number of SPI1 DI
        </comment>
    </var>

    <var name="SPI1_DATA_SIZE" value="16" >
        <comment>size of SPI1 DATA
        </comment>
    </var>

    <var name="SPI2_NB_CS" value="2" >
        <comment>number of SPI2 CS
        </comment>
    </var>

    <var name="SPI2_NB_DI" value="2" >
        <comment>number of SPI DI
        </comment>
    </var>    

    <var name="SPI2_DATA_SIZE" value="32" >
        <comment>size of SPI2 DATA
        </comment>
    </var>
    
    <var name="MEMBRIDGE_OPTION" value="0" >
        <comment>0 = EBC, 1 = AHBM
        </comment>
    </var>
    <var name="MEMBRIDGE_RAM_NB_BLOCK" value="3" >
        <comment>for membridge internal ram: number of 32k blocks
        </comment>
    </var>
    <var name="EBC_NB_BITS_ADDR" value="22" >
        <comment>for EBC option only
        </comment>
    </var>
    <var name="AHBM_NB_BITS_ADDR" value="26" >
        <comment>for AHBM option only: address bus size
        </comment>
    </var>
    <var name="AHBM_INIT_SB_0" value="0" />
    <var name="AHBM_INIT_SB_1" value="0" />
    <var name="AHBM_INIT_SB_2" value="0" />
    <var name="AHBM_INIT_SB_3" value="0" />
    <var name="AHBM_INIT_SB_4" value="0" />


</archive>

<archive relative='aif.xml' >

<module name="aif" category="Ap">

    <enum name="AIF_Sampling_Rate">
        <entry name="AIF_8k"/>
        <entry name="AIF_11k025"/>
        <entry name="AIF_12k"/>
        <entry name="AIF_16k"/>
        <entry name="AIF_22k05"/>
        <entry name="AIF_24k"/>
        <entry name="AIF_32k"/>
        <entry name="AIF_44k1"/>
        <entry name="AIF_48k"/>
    </enum>

    <var name="AIF_RX_FIFO_SIZE"    value="4"  />
    <var name="AIF_TX_FIFO_SIZE"    value="4"  />

    <reg protect="w" name="data">
        <bits access="rw" name="data0" pos="15:0" rst="-">
            <comment> This reg contains data to be read or written by IFC.
                In mono mode, data0 is before data1.
                In stereo mode, data0 is in left channel.
            </comment>
        </bits>
        <bits access="rw" name="data1" pos="31:16" rst="-">
            <comment> This reg contains data to be read or written by IFC.
                In mono mode, data1 is after data0.
                In stereo mode, data1 is in right channel.
            </comment>
        </bits>
    </reg>

    <reg protect="rw" name="ctrl">
        <bits access="rw" name="Enable" pos="0" rst="0">
            <options>
                <default/>
                <option name="ENABLE" value="1"/>
                <option name="DISABLE" value="0"/>
            </options>

            <comment> Audio Interface Enable.
                <br /> 0: if AIF_Tone[0] is also 0, AIF is disabled.
                <br /> 1 = AIF Enabled. If AIF_Tone[0] is also '1', Tx fifo continue to fetch and distribute data
                       from IFC when tone is enable. However, these data are not used.
            </comment>
        </bits>

        <bits access="rw" name="Tx Off" pos="4" rst="0">
            <options>
                <default/>
                <option name="Tx On" value="0"/>
                <option name="Tx Off" value="1"/>
            </options>
            <comment> Disable AIF Tx functions. Important: if you want to do record only, you must set this bit otherwise AIF state machine will not start.
                <br /> 0 = Both Tx Rx enabled.
                <br /> 1 = Rx enabled only, Tx disabled.
            </comment>
        </bits>

        <bits access="rs" name="Parallel Out Set" pos="8" rst="0">
            <options>
                <default/>
                <option name="SERL" value="0"/>
                <option name="PARA" value="1"/>
            </options>

            <comment> Selects parallel audio interface connected to analog front-end.
                <br /> 0 = serial output.
                <br /> 1 = parallel output.
            </comment>
        </bits>

        <bits access="rc" name="Parallel Out Clr" pos="9" rst="0">
            <options>
                <default/>
                <option name="SERL" value="0"/>
                <option name="PARA" value="1"/>
            </options>

            <comment> Selects parallel audio interface connected to analog front-end.
                <br /> 0 = serial output.
                <br /> 1 = parallel output.
            </comment>
        </bits>

        <bits access="rs" name="Parallel In Set" pos="10" rst="0">
            <options>
                <default/>
                <option name="SERL" value="0"/>
                <option name="PARA" value="1"/>
            </options>

            <comment> Selects parallel audio interface connected to analog front-end.
                <br /> 0 = serial input.
                <br /> 1 = parallel input.
            </comment>
        </bits>

        <bits access="rc" name="Parallel In Clr" pos="11" rst="0">
            <options>
                <default/>
                <option name="SERL" value="0"/>
                <option name="PARA" value="1"/>
            </options>

            <comment> Selects parallel audio interface connected to analog front-end.
                <br /> 0 = serial input.
                <br /> 1 = parallel input.
            </comment>
        </bits>

        <bits access="rw" name="Tx Stb Mode" pos="12" rst="0">
            <comment> In parallel mode, select AIF Tx Strobe mode. Reserved in serial mode.
                <br /> 0 = Tx STB edge is in middle of data.
                <br /> 1 = Tx STB edge is aligned to data edge.
            </comment>
        </bits>

        <bits access="rw" name="Parallel In2 En" pos="13" rst="0">
            <comment> In parallel mode, second input channel enable.
                <br /> 0 = Disable.
                <br /> 1 = Enable.
            </comment>
            <options>
                <default/>
                <option name="Disable" value="0"/>
                <option name="Enable" value="1"/>
            </options>
        </bits>

        <bits access="rc" name="out underflow" pos="16" rst="0">
            <comment> This bit indicates if the AIF had needed some data while the Out Fifo was empty.
                In case of data famine, the last available data will be sent again.
                <br /> Write one to clear the out_underflow status bit. This bit is auto clear.
            </comment>
        </bits>

        <bits access="rc" name="in overflow" pos="17" rst="0">
            <comment> This bit indicates if the AIF had received some data while the Input Fifo was full.
                If the Fifo In is full, the newly received data will be lost.
                <br /> Write one to clear the in_overflow status bit. This bit is auto clear.
            </comment>
        </bits>

        <bits access="rw" name="Loop back" pos="31" rst="0">
            <options>
                <default/>
                <option name="NORMAL" value="0"/>
                <option name="LOOPBACK" value="1"/>
            </options>

            <comment> Sets the loop back mode. The feature is for debug only and can not work in DAI mode.
            </comment>
        </bits>
    </reg>

    <reg protect="rw" name="serial_ctrl">

        <bits access="rw" name="SERIAL MODE" pos="1:0" rst="00">
            <options>
                <default/>
                <option name="I2S_PCM" value="0"/>
                <option name="VOICE" value="1"/>
                <option name="DAI" value="2"/>
            </options>

            <comment> Configure serial AIF mode. "11" is reserved.
                <br />
                <br /> When mode is set DAI, the bit Master Mode should be set to '1',
                bit Endian_L set to '0'. Data should be sent out on falling edge, which
                requires either Bclk_Pol = '0' and Half_Cycle_DLY = '1' or Bclk_Pol = '1'
                and Half_Cycle_DLY = '0'. Bits Tx_DLY and BCKOut_Gate must be configured
                to '0' and '1'.
                <br /> The DAI mode must NOT be modified after AIF is enabled.
                <br />
            </comment>

        </bits>
        <bits access="rw" name="I2S IN SEL" pos="3:2" rst="0">
            <options>
                <default/>
                <option name="I2S IN 0" value="0"/>
                <option name="I2S IN 1" value="1"/>
                <option name="I2S IN 2" value="2"/>
            </options>

            <comment> Select AIF I2S input.
            </comment>
        </bits>

        <bits access="rw" name="MASTER MODE" pos="4" rst="1">
            <options>
                <default/>
                <option name="SLAVE" value="0"/>
                <option name="MASTER" value="1"/>
            </options>

            <comment> configure AIF works in master mode (LRCLK and BCK timing signals are generated internally)
                or slave mode (LRCLK and BCK timing signals are generated externally).
            </comment>
        </bits>

        <bits access="rw" name="LSB" pos="5" rst="0">
            <options>
                <default/>
                <option name="MSB" value="0"/>
                <option name="LSB" value="1"/>
            </options>

            <comment> When high, the output data format is with the least significant bit first.
            </comment>
        </bits>

        <bits access="rw" name="LRCK Pol" pos="6" rst="0">
            <options>
                <default/>
                <option name="LEFT_H_RIGHT_L" value="0"/>
                <option name="LEFT_L_RIGHT_H" value="1"/>
            </options>

            <comment> configure LRCK polarity.
                <br /> 0 = high level on LRCK means left channel, low level on LRCK means right channel.
                <br /> 1 = high level on LRCK means right channel, low level on LRCK means left channel.
                <br />
                <br /> Note: this bit should be set to '0' (LEFT_H_RIGHT_L) in voice mode.
            </comment>
        </bits>

        <bits access="rw" name="Rx_DLY" pos="9:8" rst="0">
            <options>
                <default/>
                <option name="ALIGN" value="0"/>
                <option name="DLY_1" value="1"/>
                <option name="DLY_2" value="2"/>
                <option name="DLY_3" value="3"/>
            </options>

            <comment> Indicates the delay between serial data in MSB and LRCK edge.
                <br /> "00" = Digital audio in MSB is aligned with LRCLK edge.
                <br /> "01" = Digital audio in MSB is 1 cycle delayed to LRCLK edge.
                <br /> "10" = Digital audio in MSB is 2 cycle delayed to LRCLK edge.
                <br /> "11" = Digital audio in MSB is 3 cycle delayed to LRCLK edge.
            </comment>
        </bits>

        <bits access="rw" name="Tx_DLY" pos="10" rst="0">
            <options>
                <default/>
                <option name="ALIGN" value="0"/>
                <option name="DLY_1" value="1"/>
            </options>

            <comment> configure the delay between serial data out MSB and LRCK edge.
                <br /> "0" = Digital audio out MSB is aligned with LRCLK edge.
                <br /> "1" = Digital audio out MSB is 1 cycle delayed to LRCLK edge.
            </comment>
        </bits>

        <bits access="rw" name="Tx_DLY_s" pos="11" rst="0">
            <options>
                <default/>
                <option name="NO DLY" value="0"/>
                <option name="DLY" value="1"/>
            </options>

            <comment> ONLY for slave mode: configure 1 cycle supplementary Tx delay.
                <br /> "0" = No supplementary Tx delay.
                <br /> "1" = One Cycle supplementary Tx delay.
            </comment>
        </bits>

        <bits access="rw" name="Tx_Mode" pos="13:12" rst="0">
            <options>
                <default/>
                <option name="STEREO_STEREO" value="0"/>
                <option name="MONO_STEREO_CHAN_L" value="1"/>
                <option name="MONO_STEREO_DUPLI" value="2"/>
                <option name="STEREO_TO_MONO" value="3"/>
            </options>
            <comment> Configure mono or stereo format for Audio data out.
                      This field is used both in serial mode or in parallel EXT mode.
                <br /> "00" = stereo input from IFC, stereo output to pin.
                <br /> "01" = mono input from IFC, stereo output in left channel to pin.
                              This value is reserved in parallel EXT mode.
                <br /> "10" = mono input from IFC, stereo output duplicate in both channels to pin.
                <br /> "11" = stereo input from IFC, mono output to left and right channel. This mode is only used for parallel stereo interface.
                <br />
                <br /> if AIF works in DAI or Voice mode, always select "00" mode STEREO_STEREO.
            </comment>
        </bits>

        <bits access="rw" name="Rx Mode" pos="14" rst="0">
            <options>
                <default/>
                <option name="STEREO_STEREO" value="0"/>
                <option name="STEREO_MONO_FROM_L" value="1"/>
            </options>
            <comment> Configure mono or stereo format for Audio data in.
                <br /> 0 = stereo input from pin, stereo output to IFC.
                <br /> 1 = stereo input from pin, mono input to IFC selected from left channel.
                <br />
                <br /> Users can change LRCK polarity to choose mono input from right channel.
            </comment>
        </bits>

        <bits access="rw" name="BCK LRCK" pos="20:16" rst="0">
            <options>
                <default/>
                <option name="BCK LRCK 16" value="0"/>
                <option name="BCK LRCK 17" value="1"/>
                <option name="BCK LRCK 18" value="2"/>
                <option name="BCK LRCK 19" value="3"/>
                <option name="BCK LRCK 20" value="4"/>
                <option name="BCK LRCK 21" value="5"/>
                <option name="BCK LRCK 22" value="6"/>
                <option name="BCK LRCK 23" value="7"/>
                <option name="BCK LRCK 24" value="8"/>
                <option name="BCK LRCK 25" value="9"/>
                <option name="BCK LRCK 26" value="10"/>
                <option name="BCK LRCK 27" value="11"/>
                <option name="BCK LRCK 28" value="12"/>
                <option name="BCK LRCK 29" value="13"/>
                <option name="BCK LRCK 30" value="14"/>
                <option name="BCK LRCK 31" value="15"/>
                <option name="BCK LRCK 32" value="16"/>
                <option name="BCK LRCK 33" value="17"/>
                <option name="BCK LRCK 34" value="18"/>
                <option name="BCK LRCK 35" value="19"/>
                <option name="BCK LRCK 36" value="20"/>
                <option name="BCK LRCK 37" value="21"/>
                <option name="BCK LRCK 38" value="22"/>
                <option name="BCK LRCK 39" value="23"/>
                <option name="BCK LRCK 40" value="24"/>
                <option name="BCK LRCK 41" value="25"/>
                <option name="BCK LRCK 42" value="26"/>
                <option name="BCK LRCK 43" value="27"/>
                <option name="BCK LRCK 44" value="28"/>
                <option name="BCK LRCK 45" value="29"/>
                <option name="BCK LRCK 46" value="30"/>
                <option name="BCK LRCK 47" value="31"/>

            </options>

            <comment> configure the ratio of BCK and LRCK cycle from 16 to 31.
                <br /> Voice_Mode: "XXXX": each sample takes 16 + "XXXX" BCLK cycle.
                <br /> Audio_Mode: "XXXX": each sample takes 2*(16 + "XXXX) BCLK cycle. 2 times than Voice Mode because in audio mode each sample occupies two channels.
            </comment>
        </bits>

        <bits access="rw" name="Output Half Cycle DLY" pos="25" rst="0">
            <options>
                <default/>
                <option name="NO DLY" value="0"/>
                <option name="DLY" value="1"/>
            </options>

            <comment> delayed Audio output data or LRCK by half cycle.
            </comment>
        </bits>

        <bits access="rw" name="Input Half Cycle DLY" pos="26" rst="0">
            <options>
                <default/>
                <option name="NO DLY" value="0"/>
                <option name="DLY" value="1"/>
            </options>

            <comment> delayed Audio input data by half cycle.
            </comment>
        </bits>

        <bits access="rw" name="BckOut Gate" pos="28" rst="0">
            <options>
                <default/>
                <option name="NO GATE" value="0"/>
                <option name="GATED" value="1"/>
            </options>

            <comment> Sets the BckOut gating. This bit decide if AIF continue to output BCK clock after 16-bit data has been sent.
            </comment>
        </bits>
    </reg>

    <reg protect="rw" name="tone">
        <bits access="rw" name="Enable H" pos="0" rst="0">
            <options>
                <default/>
                <option name="DISABLE" value="0"/>
                <option name="ENABLE" value="1"/>
            </options>

            <comment>When this bit is set, the audio interface is enabled and a comfort tone or DTMF tone is output
                on the audio interface instead of the regular data, even if the AIF_CTRL[0] enable bit is 0.
                <br /> 0 = AIF is disabled if the AIF_CTRL[0] is also 0.
                <br /> 1 = AIF is enabled and generates a tone.
            </comment>
        </bits>

        <bits access="rw" name="Tone Select" pos="1" rst="0">
            <options>
                <default/>
                <option name="DTMF" value="0"/>
                <option name="COMFORT TONE" value="1"/>
            </options>

            <comment>Select whether a DTMF of a comfort tone is generated.
            </comment>
        </bits>

        <bits access="rw" name="DTMF Freq Col" pos="5:4" rst="0">
            <options>
                <default/>
                <option name="1209 Hz" value="0"/>
                <option name="1336 Hz" value="1"/>
                <option name="1477 Hz" value="2"/>
                <option name="1633 Hz" value="3"/>
            </options>

            <comment>Frequency of the first DTMF sine wave.
            </comment>
        </bits>

        <bits access="rw" name="DTMF Freq Row" pos="7:6" rst="0">
            <options>
                <default/>
                <option name="697 Hz" value="0"/>
                <option name="770 Hz" value="1"/>
                <option name="852 Hz" value="2"/>
                <option name="941 Hz" value="3"/>
            </options>

            <comment>Frequency of the second DTMF sine wave.
            </comment>
        </bits>

        <bits access="rw" name="Comfort Freq" pos="9:8" rst="0">
            <options>
                <default/>
                <option name="425 Hz" value="0"/>
                <option name="950 Hz" value="1"/>
                <option name="1400 Hz" value="2"/>
                <option name="1800 Hz" value="3"/>
            </options>

            <comment>Frequency of comfort tone.
            </comment>
        </bits>
        <bits access="rw" name="Tone Gain" pos="13:12" rst="0">
            <comment>Tone attenuation. The Comfort Tone or DTMF is attenuated according to this programmable gain.
            </comment>
                <options>
                    <default/>
                    <option name="0 dB"  value="0"/>
                    <option name="m3 dB"  value="1"/>
                    <option name="m9 dB"  value="2"/>
                    <option name="m15 dB" value="3"/>
                </options>
            </bits>
        </reg>

        <reg protect="rw" name="side_tone">
        <bits access="rw" name="Side Tone Gain" pos="3:0" rst="0">
            <comment>Side Tone attenuation. The side tone is attenuated according to this programmable gain.
                <br /> 0000 = mute.
                <br /> 0001 = -36 dB.
                <br /> 0010 = -33 dB.
                <br /> 0011 = -30 dB.
                <br /> 0100 = -27 dB.
                <br /> 0101 = -24 dB.
                <br /> 0110 = -21 dB.
                <br /> 0111 = -18 dB.
                <br /> 1000 = -15 dB.
                <br /> 1001 = -12 dB.
                <br /> 1010 = -9 dB.
                <br /> 1011 = -6 dB.
                <br /> 1100 = -3 dB.
                <br /> 1101 = 0 dB.
                <br /> 1110 = +3 dB.
                <br /> 1111 = +6 dB.
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_AudioBCK"  protect="rw">
        <bits name="AudioBCK_Divider"    pos="10:0"   access="rw" rst="all1">
            <comment>The generated clock frequency is equal to the 156MHz divided by this value + 2. The 156MHz clock comes from a PLL.
            </comment>
        </bits>
        <bits access="rw" name="Bck Pol" pos="16" rst="0">
            <options>
                <default/>
                <option name="NORMAL" value="0"/>
                <option name="INVERT" value="1"/>
            </options>
            <comment> if Master Mode, invert BCLK out. if slave Mode, invert BCLK in.
            </comment>
        </bits>
        <bits access="r" name="Bck_Sel_Pll" pos="20" rst="0">
            <comment> 1: if Master Mode, and NOT Parallel_Mode_In/Out, BCK divided by source PLL 156MHz.
            </comment>
        </bits>
        <bits access="rw" name="Bck_Pll_Source" pos="21" rst="0">
            <comment> 0: if Master Mode, and NOT Parallel_Mode_In/Out, BCK divided by source PLL 150MHz; 1: From codec clock.
            </comment>
            <options>
                <default/>
                <option name="PLL_150M"  value="0"/>
                <option name="PLL_Codec" value="1"/>
            </options>
        </bits>
    </reg>
    <reg name="Cfg_Aif_Tx_Stb"  protect="rw">
        <bits name="Aif_Tx_Stb_Div" pos="13:0" access="rw" rst="all1">
            <comment>This divider generates strobe which goes to AIF. The generated strobe frequency is equal to the 48MHz divided by this value + 2, please notice this frequency should be 2 x AU_TX_STB freq, which is sent to analog macro.
            </comment>
        </bits>
        <bits name="Aif_Tx_Stb_26M_En" pos="30" access="rw" rst="0">
            <comment>Change TX strobe source clk from 48M to 26M.
            </comment>
        </bits>
        <bits name="Aif_Tx_Stb_En" pos="31" access="rw" rst="0">
            <comment>Enable TX strobe which goes to AIF.
            </comment>
        </bits>
    </reg>

</module>
</archive>
<archive relative='voc_ram.xml' >

<module name="voc_ram" category="Voc">

    <var name="VOC_RAM_X_SIZE" value="0x8000"/>
    <var name="VOC_RAM_Y_SIZE" value="0x8000"/>
    <var name="VOC_ROM_Z_SIZE" value="0x0000"/>
    <var name="VOC_RAM_I_SIZE" value="0x8000"/>

    <var name="VOC_RAM_X_SPACE" value="0x8000"/>
    <var name="VOC_RAM_Y_SPACE" value="0x8000"/>
    <var name="VOC_ROM_Z_SPACE" value="0x10000"/>
    <var name="VOC_RAM_I_SPACE" value="0x20000"/>
    
    <memory name="voc_ram_x_base" size="VOC_RAM_X_SIZE">
        <comment>VoC RAM X space. 
        </comment>
    </memory>
    <memory name="voc_ram_x_hole" size="VOC_RAM_X_SPACE - VOC_RAM_X_SIZE">
        <comment>VoC RAM X whole. 
        </comment>
    </memory>
    <memory name="voc_ram_y_base" size="VOC_RAM_Y_SIZE">
        <comment>VoC RAM Y space. 
        </comment>
    </memory>
    <memory name="voc_ram_y_hole" size="VOC_RAM_Y_SPACE - VOC_RAM_Y_SIZE">
        <comment>VoC RAM Y whole. 
        </comment>
    </memory>
    <memory name="voc_rom_z_hole" size="VOC_ROM_Z_SPACE - VOC_ROM_Z_SIZE">
        <comment>VoC ROM Y whole. 
        </comment>
    </memory>
    <memory name="voc_ram_i_base" size="VOC_RAM_I_SIZE">
        <comment>VoC RAM I space. 
        </comment>
    </memory>
    <memory name="voc_ram_i_hole" size="VOC_RAM_I_SPACE - VOC_RAM_I_SIZE">
        <comment>VoC RAM I whole. 
        </comment>
    </memory>

</module>

</archive>
<archive relative='voc_global.xml' >

  
  <var name="AHB_NB_BITS_ADDR" value="26" ><comment>AHB Address bus size</comment></var>
</archive>

<archive relative='voc_ahb.xml' >


<include file="voc_global.xml"/>

<module name="voc_ahb" category="Voc">
    <reg name="Irq_Status" protect="rw">
        <bits name="XCpu_Voc_Irq_Cause" pos="0" access="r" rst="0">
            <comment>1 when Voc triggered an Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_Dma_Irq_Cause" pos="1" access="r" rst="0">
            <comment>1 when the DMA triggered an Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_DmaVoc_Irq_Cause" pos="2" access="r" rst="0">
            <comment>1 when the DMA programmed from Voc triggered an Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_Debug_Irq_Cause" pos="3" access="r" rst="0">
            <comment>1 when a VoC stall state is reached during debugging.
            </comment>
        </bits>
        <bitgroup name="XCpu_Irq_Cause">
            <entry ref="XCpu_Voc_Irq_Cause"/>
            <entry ref="XCpu_Dma_Irq_Cause"/>
            <entry ref="XCpu_DmaVoc_Irq_Cause"/>
            <entry ref="XCpu_Debug_Irq_Cause"/>
        </bitgroup>
        <bits name="BCpu_Voc_Irq_Cause" pos="8" access="r" rst="0">
            <comment>1 when Voc triggered an Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_Dma_Irq_Cause" pos="9" access="r" rst="0">
            <comment>1 when the DMA triggered an Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_DmaVoc_Irq_Cause" pos="10" access="r" rst="0">
            <comment>1 when the DMA programmed from Voc triggered an Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_Debug_Irq_Cause" pos="11" access="r" rst="0">
            <comment>1 when a VoC stall state is reached during debugging.
            </comment>
        </bits>
        <bitgroup name="BCpu_Irq_Cause">
            <entry ref="BCpu_Voc_Irq_Cause"/>
            <entry ref="BCpu_Dma_Irq_Cause"/>
            <entry ref="BCpu_DmaVoc_Irq_Cause"/>
            <entry ref="BCpu_Debug_Irq_Cause"/>
        </bitgroup>
        <bits name="XCpu_Voc_Irq_Status" pos="16" access="r" rst="0">
            <comment>1 when Voc triggered an Irq to the XCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="XCpu_Dma_Irq_Status" pos="17" access="r" rst="0">
            <comment>1 when the DMA triggered an Irq to the XCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="XCpu_DmaVoc_Irq_Status" pos="18" access="r" rst="0">
            <comment>1 when the DMA programmed from Voc triggered an Irq to the XCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="XCpu_Debug_Irq_Status" pos="19" access="r" rst="0">
            <comment>1 when a VoC stall state is reached during debugging. (not masked, status only)
            </comment>
        </bits>
        <bitgroup name="XCpu_Irq_Status">
            <entry ref="XCpu_Voc_Irq_Status"/>
            <entry ref="XCpu_Dma_Irq_Status"/>
            <entry ref="XCpu_DmaVoc_Irq_Status"/>
            <entry ref="XCpu_Debug_Irq_Status"/>
        </bitgroup>
        <bits name="BCpu_Voc_Irq_Status" pos="24" access="r" rst="0">
            <comment>1 when Voc triggered an Irq to the BCpu (not masked, status only).
            </comment>
        </bits>
        <bits name="BCpu_Dma_Irq_Status" pos="25" access="r" rst="0">
            <comment>1 when the DMA triggered an Irq to the BCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="BCpu_DmaVoc_Irq_Status" pos="26" access="r" rst="0">
            <comment>1 when the DMA programmed from Voc triggered an Irq to the BCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="BCpu_Debug_Irq_Status" pos="27" access="r" rst="0">
            <comment>1 when a VoC stall state is reached during debugging. (not masked, status only)
            </comment>
        </bits>
        <bitgroup name="BCpu_Irq_Status">
            <entry ref="BCpu_Voc_Irq_Status"/>
            <entry ref="BCpu_Dma_Irq_Status"/>
            <entry ref="BCpu_DmaVoc_Irq_Status"/>
            <entry ref="BCpu_Debug_Irq_Status"/>
        </bitgroup>
    </reg>
    <reg name="Irq_Mask_Set" protect="rs">
        <bits name="XCpu_Voc_Irq_Mask" pos="0" access="rs" rst="0">
            <comment>Write 1 to set the mask for Voc Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_Dma_Irq_Mask" pos="1" access="rs" rst="0">
            <comment>Write 1 to set the mask for DMA Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_DmaVoc_Irq_Mask" pos="2" access="rs" rst="0">
            <comment>Write 1 to set the mask for DMA Irq to the XCpu when the DMA is programmed from Voc.
            </comment>
        </bits>
        <bits name="XCpu_Debug_Irq_Mask" pos="3" access="rs" rst="0">
            <comment>Write 1 to set the mask for Debug Irq to the XCpu.
            </comment>
        </bits>
        <bitgroup name="XCpu_Irq_Mask">
            <entry ref="XCpu_Voc_Irq_Mask"/>
            <entry ref="XCpu_Dma_Irq_Mask"/>
            <entry ref="XCpu_DmaVoc_Irq_Mask"/>
            <entry ref="XCpu_Debug_Irq_Mask"/>
        </bitgroup>
        <bits name="BCpu_Voc_Irq_Mask" pos="8" access="rs" rst="0">
            <comment>Write 1 to set the mask for Voc Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_Dma_Irq_Mask" pos="9" access="rs" rst="0">
            <comment>Write 1 to set the mask for DMA Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_DmaVoc_Irq_Mask" pos="10" access="rs" rst="0">
            <comment>Write 1 to set the mask for DMA Irq to the BCpu when the DMA is programmed from Voc.
            </comment>
        </bits>
        <bits name="BCpu_Debug_Irq_Mask" pos="11" access="rs" rst="0">
            <comment>Write 1 to set the mask for Debug Irq to the BCpu.
            </comment>
        </bits>
        <bitgroup name="BCpu_Irq_Mask">
            <entry ref="BCpu_Voc_Irq_Mask"/>
            <entry ref="BCpu_Dma_Irq_Mask"/>
            <entry ref="BCpu_DmaVoc_Irq_Mask"/>
            <entry ref="BCpu_Debug_Irq_Mask"/>
        </bitgroup>
    </reg>
    <reg name="Irq_Mask_Clr" protect="rc">
        <bits name="XCpu_Voc_Irq_Mask" pos="0" access="rc" rst="0">
            <comment>Write 1 to clear the mask for Voc Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_Dma_Irq_Mask" pos="1" access="rc" rst="0">
            <comment>Write 1 to clear the mask for DMA Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_DmaVoc_Irq_Mask" pos="2" access="rc" rst="0">
            <comment>Write 1 to clear the mask for DMA Irq to the XCpu when the DMA is programmed from Voc.
            </comment>
        </bits>
        <bits name="XCpu_Debug_Irq_Mask" pos="3" access="rc" rst="0">
            <comment>Write 1 to clear the mask for Debug Irq to the XCpu.
            </comment>
        </bits>
        <bitgroup name="XCpu_Irq_Mask">
            <entry ref="XCpu_Voc_Irq_Mask"/>
            <entry ref="XCpu_Dma_Irq_Mask"/>
            <entry ref="XCpu_DmaVoc_Irq_Mask"/>
            <entry ref="XCpu_Debug_Irq_Mask"/>
        </bitgroup>
        <bits name="BCpu_Voc_Irq_Mask" pos="8" access="rc" rst="0">
            <comment>Write 1 to clear the mask for Voc Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_Dma_Irq_Mask" pos="9" access="rc" rst="0">
            <comment>Write 1 to clear the mask for DMA Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_DmaVoc_Irq_Mask" pos="10" access="rc" rst="0">
            <comment>Write 1 to clear the mask for DMA Irq to the BCpu when the DMA is programmed from Voc.
            </comment>
        </bits>
        <bits name="BCpu_Debug_Irq_Mask" pos="11" access="rc" rst="0">
            <comment>Write 1 to clear the mask for Debug Irq to the BCpu.
            </comment>
        </bits>
        <bitgroup name="BCpu_Irq_Mask">
            <entry ref="BCpu_Voc_Irq_Mask"/>
            <entry ref="BCpu_Dma_Irq_Mask"/>
            <entry ref="BCpu_DmaVoc_Irq_Mask"/>
            <entry ref="BCpu_Debug_Irq_Mask"/>
        </bitgroup>
    </reg>
    <reg name="DMA_Cfg" protect="rw">
        <bits name="DMA_SizeLow" pos="1:0" access="r">
            <comment>Ignored on write, read as 0, so DMA_Size can be programmed in 15:0 as a byte size as long as the size in a multiple of 4.
            </comment>
        </bits>
        <bits name="DMA_WSize" pos="15:2" access="rw" rst="all1">
            <comment>Number of 32bits Words to transfer.
            </comment>
        </bits>
        <bitgroup name="DMA_Size">
            <entry ref="DMA_SizeLow"/>
            <entry ref="DMA_WSize"/>
        </bitgroup>
        <bits name="DMA_Run" pos="16" access="rw" rst="0">
            <comment>Start the DMA transfer
            </comment>
        </bits>
        <bits name="DMA_Dir" pos="20" access="rw" rst="1">
            <comment>Set the DMA transfer direction
            </comment>
            <options>
                <option name="Read" value="0"><comment>Read from main memory to Voc Memory</comment></option>
                <option name="Write" value="1"><comment>Write to main memory from Voc Memory</comment></option>
            </options>
        </bits>
        <bits name="DMA_B2S_En" pos="21" access="rw" rst="1">
            <comment>Enable the byte to short mode (b2s). For read access : every byte read from the external memory is cast to short and written to the internal memory (twice as much data written than received). For write access : every short read from the internal memory is trunkated to byte and written to the external memory (twice less data written than read). In both cases the size corresponds to the number of words transfered on the AHB.
            </comment>
        </bits>
        <bits name="DMA_B2S_Sign" pos="22" access="rw" rst="1">
            <comment> For read access only (byte to short cast): define if the cast is signed or unsigned.
            </comment>
        </bits>        
        <bits name="DMA_Wrap" pos="27:24" access="rw" rst="all1">
            <comment>Set the DMA wrap mode, refer to Voc documentation for a description of Wrap transfers.
            </comment>
        </bits>
    </reg>
    <reg name="DMA_LAddr" protect="rw">
        <bits name="DMA_LAddr" pos="16:1" access="rw" rst="0">
            <comment>DMA Local Address: Address in the Voc memory space.
            </comment>
            <options> 
                <mask/>
            </options>
        </bits>
    </reg>
    <reg name="DMA_EAddr" protect="rw">
        <bits name="DMA_EAddr" pos="AHB_NB_BITS_ADDR-1:2" access="rw" rst="0">
            <comment>DMA External Address: Address in the main memory space.
            </comment>
            <options> 
                <mask/>
            </options>
        </bits>
        <bits name="DMA_Single_B2S_En" pos="28" access="w" rst="0">
            <comment>Same as DMA_B2S_En, but  valid only when the DMA_Single bit is enabled.
            </comment>
        </bits>
        <bits name="DMA_Single_B2S_Sign" pos="29" access="w" rst="0">
            <comment> For read access only (byte to short cast): define if the cast is signed or unsigned.
            </comment>
        </bits>          
        <bits name="DMA_Write" pos="30" access="w" rst="0">
            <comment>Set the DMA transfer direction, valid only when the DMA_Single bit is enabled.
            </comment>
            <options>
                <option name="Read" value="0"><comment>Read from main memory to Voc Memory</comment></option>
                <option name="Write" value="1"><comment>Write to main memory from Voc Memory</comment></option>
            </options>
        </bits>
        <bits name="DMA_Single" pos="31" access="w" rst="0">
            <comment>When 1 start a DMA transfer in Single mode, the data is tranfered to/from the DMA_Data_Single register.
                <br/>When 0 start a regular DMA transfer using LAddr and Size.
            </comment>
        </bits>
    </reg>
    <reg name="DMA_Status" protect="r">
        <bits name="DMA_On" pos="0" access="r" rst="0">
            <comment>1 when DMA is running.
            </comment>
        </bits>
        <bits name="DMA_Sema_Status" pos="31" access="r" rst="1">
            <comment>Read the value of the DMA Semaphore without affecting it.
            </comment>
        </bits>
    </reg>
    <reg name="DMA_Sema" protect="w">
        <bits name="DMA_Sema" pos="1" access="w" rst="1">
            <comment>Read the value of the DMA Semaphore:
                <br/>If 1 is returned the DMA was available and is know taken.
                <br/>If 0 is returned the DMA is not available, you need to try again to get it. The software can wait on any DMA Irq before retrying if Sema is never free manually.
                <br/>Write 1 to free manually (got the semaphore and want to discard it without prgrammin a transfer.)
                <br/>The end of the DMA will also free the Semaphone.
            </comment>
        </bits>
    </reg>
    <reg name="DMA_2D" protect="rw">
        <bits name="DMA_StrideLow" pos="1:0" access="r">
            <comment>Ignored on write, read as 0, so DMA_Stride can be programmed as a byte size as long as the size in a multiple of 4.
            </comment>
        </bits>
        <bits name="DMA_WStride" pos="12:2" access="rw" rst="all0">
            <comment> Stride in Words (without the 2 lsb). The stride of the 2D transfer corresponds to the step from one line to another excluding the burst size (in bytes). Example : If the size is 12 bytes (3 words) and the stride is 20 bytes (5 words), starting from word position N, the DMA will transfer words at positions N, N+1, N+2, N+8, N+9, N+10, N+16, N+17, N+18, etc... If the number of lines is L this example will access a block with dimensions 3xL inside a block of size 8xL.
            </comment>
        </bits>
        <bitgroup name="DMA_Stride">
            <entry ref="DMA_StrideLow"/>
            <entry ref="DMA_WStride"/>
        </bitgroup>
        <bits name="DMA_Lines" pos="27:16" access="rw" rst="0">
            <comment>Number of lines of the 2D transfer. Example : this corresponds to the number L in the previous example.
            </comment>
        </bits>
    </reg>    
    <reg name="DMA_Stop" protect="w">
        <bits name="DMA_Stop" pos="0" access="w" rst="0">
            <comment>Write 1 to this register to cleanly stop the DMA. Note : a last burst may be on going when you requested the clean stop, and no more bursts will be executed after this last burst. Because of this potential last on going burst you need to poll the DMA_On field of the DMA_Status register to verify the completion of the DMA.
            </comment>
        </bits>
    </reg>
    
</module>

</archive>
<archive relative='voc_cfg.xml' >


<include file="voc_global.xml"/>

<module name="voc_cfg" category="Voc">
    <reg16 name="Ctrl" protect="rw">
        <bits name="Run" pos="2:0" access="w">
            <options>
                <option name="Pause" value="0"><comment>Pause VoC (no pipe flush). When paused, all events that wake up VoC (start, soft wake up, or wake up on extern event) will resume the execution from where it was paused.</comment></option>
                <option name="SoftWakeUp0" value="1"><comment>CPU generated event with id=0 that can wake VoC if the coresponding bit in the Wakeup_Mask register is set to '1'.</comment></option>
                <option name="SoftWakeUp1" value="3"><comment>CPU generated event with id=1 that can wake VoC if the coresponding bit in the Wakeup_Mask register is set to '1'</comment></option>
                <option name="Stop" value="4"><comment>Stop VoC and flush pipe. Used when the current task is finished (because the next task will have a different PC start). The PC start change should mandatorily be preceeded by a Stop. This ensures that no previously executed code that is still in the pipe will modify the registry during the first two instructions of the new task execution.</comment></option>
                <option name="Start" value="5"><comment>Wake up VoC regardless of the Wakeup_Mask setting (force wake up)</comment></option>
            </options>
        </bits>
        <bits name="BCPU_irq" pos="4" access="w">
            <comment>Writing '1' will generate an internal pulse recorded in the Irq_Status register of the voc_ahb interface (see voc_ahb registers). If the corresponding bit of the Irq_Mask vector is set to '1', a level interrupt will be generated to the BCPU. Should be configured by VoC_core only (not by a CPU)!
            </comment>
        </bits>
        <bits name="XCPU_irq" pos="5" access="w">
            <comment>Writing '1' will generate an internal pulse recorded in the Irq_Status register of the voc_ahb interface (see voc_ahb registers). If the corresponding bit of the Irq_Mask vector is set to '1', a level interrupt will be generated to the XCPU. Should be configured by VoC_core only (not by a CPU)!
            </comment>
        </bits>
        <bits name="Running" pos="0" access="r" rst="0">
            <options>
                <option name="Yes" value="1"><comment>VoC is running</comment></option>
                <option name="No" value="0"><comment>VoC is paused or stopped</comment></option>
                <default/>
            </options>
        </bits>
        <bits name="Sema_Status" pos="1" access="r" rst="1">
            <comment>Status of the VoC semaphore (reading this bit will not modify the semaphore).
            </comment>
        </bits>
    </reg16>
    <reg16 name="DMA_Wrap" protect="">
        <comment>Should be configured by VoC_core only (not by a CPU)! If VoC DMA is used by the CPU the equivalent voc_ahb registers should be configured.
        </comment>
        <bits name="DMA_Wrap" pos="3:0" access="w" rst="all0">
            <comment>Wrap register. 0 : no wrap, wrap_val (other than 0): the wrap_val LSB bits of the Word wrap address are at '0'.
            </comment>
        </bits>
    </reg16>
    <reg16 name="DMA_Size" protect="">
        <comment>Should be configured by VoC_core only (not by a CPU)! If VoC DMA is used by the CPU the equivalent voc_ahb registers should be configured.
        </comment>
        <bits name="DMA_Size" pos="13:0" access="w" rst="all0">
            <comment>Word Size of the DMA Transfer (number of INT32 to transfer) 
            </comment>
        </bits>
    </reg16>
    <reg16 name="DMA_Laddr" protect="">        
        <comment>Should be configured by VoC_core only (not by a CPU)! If VoC DMA is used by the CPU the equivalent voc_ahb registers should be configured.
        </comment>
        <bits name="DMA_LAddr" pos="15:0" access="w" rst="all0">
            <comment>DMA Local Word Address: Address in the Voc memory space.
            </comment>
        </bits>
    </reg16>
    <reg name="DMA_EAddr" protect="">
        <comment>Should be configured by VoC_core only (not by a CPU)! If VoC DMA is used by the CPU the equivalent voc_ahb registers should be configured.
        </comment>
        <bits name="DMA_EAddr" pos="AHB_NB_BITS_ADDR-1:2" access="w" rst="0">
            <comment>DMA External Byte Address (aligned to Word address, the 2 lsb are always '0'): Address in the main memory space.
            </comment>
            <options> 
                <mask/>
            </options>
        </bits>
        <bits name="DMA_B2S_En" pos="28" access="w" rst="0">
            <comment>Enable the byte to short mode (b2s). For read access : every byte read from the external memory is cast to short and written to the internal memory (twice as much data written than received). For write access : every short read from the internal memory is trunkated to byte and written to the external memory (twice less data written than read). In both cases the size corresponds to the number of words transfered on the AHB.
            </comment>
        </bits>
        <bits name="DMA_B2S_Sign" pos="29" access="w" rst="0">
            <comment> For read access only (byte to short cast): define if the cast is signed or unsigned.
            </comment>
        </bits>        
        <bits name="DMA_Write" pos="30" access="w" rst="0">
            <comment>Set the DMA transfer direction
            </comment>
            <options>
                <option name="Read" value="0"><comment>Read from main memory to Voc Memory</comment></option>
                <option name="Write" value="1"><comment>Write to main memory from Voc Memory</comment></option>
            </options>
        </bits>
        <bits name="DMA_Single" pos="31" access="w" rst="0">
            <comment>When 1 start a DMA transfer in Single mode, the data is tranfered to/from the DMA_Data_Single register.
                <br/>When 0 start a regular DMA transfer using LAddr and Size.
            </comment>
        </bits>
    </reg>
    <reg name="DMA_Data_Single" protect="rw">
        <bits name="DMA_Data_Single" pos="31:0" access="rw" rst="0">
            <comment>DMA Data for Single Access (source or destination depending on direction)
            </comment>
        </bits>
    </reg>
    <reg name="DMA_2D" protect="">
        <bits name="DMA_Stride" pos="12:0" access="w" rst="0">
            <comment>Stride in bytes of the 2D transfer, corresponding to the step from one line to another excluding the burst size (in bytes). Example : If the size is 12 bytes (3 words) and the stride is 20 bytes (5 words), starting from word position N, the DMA will transfer words at positions N, N+1, N+2, N+8, N+9, N+10, N+16, N+17, N+18, etc... If the number of lines is L this example will access a block with dimensions 3xL inside a block of size 8xL.
            </comment>
        </bits>
        <bits name="DMA_Lines" pos="27:16" access="w" rst="0">
            <comment>Number of lines of the 2D transfer. Example : this corresponds to the number L in the previous example.
            </comment>
        </bits>
    </reg>        
    <reg name="DMA_Addr_Offset" protect="rw">
        <bits name="DMA_Addr_Offset" pos="3:0" access="rw" rst="0">
            <comment> high 4 bits of DMA address.
            </comment>
        </bits>
        <bits name="DMA_Width_Select" pos="4" access="rw" rst="0">
            <comment> 1 for 64 bit axi access, 0 for 32 bit axi access.
            </comment>
        </bits>
    </reg>
    <reg16 name="DAI_Data_In" protect="r">
        <bits name="DAI_Data_In" pos="12:0" access="r" rst="0">
            <comment>Data from DAI Simple interface.
            </comment>
        </bits>
        <bits name="DAI_Data_Ready" pos="15" access="r" rst="0">
            <comment>Data ready.
            </comment>
        </bits>       
    </reg16>
    <reg16 name="DAI_Data_Out" protect="w">
        <bits name="DAI_Data_Out" pos="12:0" access="w">
            <comment>Data for DAI Simple.
            </comment>
        </bits>
    </reg16>
    <reg16 name="ROM_Page" protect="" rst="0">
        <bits name="ROM_Page" pos="15:0" access="rw">
           <comment>Number of the ROM page when a ROM bigger than 1 page is defined in voc_cfg_pkg.vhd. Otherwise this register does not exist.
           </comment>
        </bits>
    </reg16>
    <reg16 name="Debug" protect="rw" rst="0">
        <bits name="stall_on_bkp" pos="0" access="rw" rst="0">
           <comment>Enable or disable stall on hardware breakpoint.
           </comment>
        </bits>
        <bits name="stall_on_branch_taken" pos="1" access="rw" rst="0">
           <comment>Enable or disable stall when a branch is taken in the program.
           </comment>
        </bits>
        <bits name="step" pos="2" access="rw" rst="0">
           <comment>Enable or disable step mode (execute 1 instruction and stall).
           </comment>
        </bits>
    </reg16>
    <reg name="BIST_Ctrl"  protect="rw">
       <bits name="BIST_Run" pos="0" access="w">
            <comment>'1' : start.
            </comment>
       </bits>
       <bits name="BIST_Running" pos="0" access="r" rst="0">
            <comment>'0' : done.
            </comment>
       </bits>
       <bits name="BIST_Status" pos="1" access="r" rst="0">
            <comment>'1' : fail. '0' : succeed. Valid when BIST_Running is at '0'.
            </comment>
       </bits>        
       <bits name="BIST_CRC" pos="31:16" access="r" rst="0">
            <comment>16-bit CRC result of the ROM. Valid when BIST_Running is at '0'.
            </comment>
       </bits>        
    </reg>
    <reg16 name="Wakeup_Mask" protect="rw">
       <bits name="IFC0_Event_Mask" pos="0" access="rw" rst="0">
            <comment>Mask enabling the IFC0 half or whole buffer event.
            </comment>
       </bits>        
       <bits name="IFC1_Event_Mask" pos="1" access="rw" rst="0">
            <comment>Mask enabling the IFC1 half or whole buffer event.
            </comment>
       </bits>
       <bits name="DMAE_Event_Mask" pos="2" access="rw" rst="0">
            <comment>Mask enabling the DMAE event (DMA configured by extern master done).
            </comment>
       </bits>
       <bits name="DMAI_Event_Mask" pos="3" access="rw" rst="0">
            <comment>Mask enabling the DMAI event (DMA configured by VoC core done).
            </comment>
       </bits>
       <bits name="SOF0_Event_Mask" pos="4" access="rw" rst="0">
            <comment>Mask enabling the SOF0 event (Soft Wake Up with Id=0 generated by writing the corresponding value in the control register).
            </comment>
       </bits>
       <bits name="SOF1_Event_Mask" pos="5" access="rw" rst="0">
            <comment>Mask enabling the SOF1 event (Soft Wake Up with Id=1 generated by writing the corresponding value in the control register).
            </comment>
       </bits>
       <bitgroup name="Wakeup_Mask">
            <entry ref="IFC0_Event_Mask"/>
            <entry ref="IFC1_Event_Mask"/>
            <entry ref="DMAE_Event_Mask"/>
            <entry ref="DMAI_Event_Mask"/>
            <entry ref="SOF0_Event_Mask"/>
            <entry ref="SOF1_Event_Mask"/>
        </bitgroup>
    </reg16>
    <hole size="16"/>
    <reg16 name="Wakeup_Status" protect="rc">
       <bits name="IFC0_Event_Status" pos="0" access="rc" rst="0">
            <comment>'1': Triggered IFC0 event. Write '1' to clear.
            </comment>
       </bits>        
       <bits name="IFC1_Event_Status" pos="1" access="rc" rst="0">
            <comment>'1': Triggered IFC1 event. Write '1' to clear.
            </comment>
       </bits>
       <bits name="DMAE_Event_Status" pos="2" access="rc" rst="0">
            <comment>'1': Triggered DMAE event. Write '1' to clear.
            </comment>
       </bits>
       <bits name="DMAI_Event_Status" pos="3" access="rc" rst="0">
            <comment>'1': Triggered DMAI event. Write '1' to clear.
            </comment>
       </bits>
       <bits name="SOF0_Event_Status" pos="4" access="rc" rst="0">
            <comment>'1': Triggered SOF0 event. Write '1' to clear.
            </comment>
       </bits>
       <bits name="SOF1_Event_Status" pos="5" access="rc" rst="0">
            <comment>'1': Triggered SOF1 event. Write '1' to clear.
            </comment>
       </bits>
       <bitgroup name="Wakeup_Status">
            <entry ref="IFC0_Event_Status"/>
            <entry ref="IFC1_Event_Status"/>
            <entry ref="DMAE_Event_Status"/>
            <entry ref="DMAI_Event_Status"/>
            <entry ref="SOF0_Event_Status"/>
            <entry ref="SOF1_Event_Status"/>
        </bitgroup>
    </reg16>
    <reg16 name="Wakeup_Cause" access="r" rst="0">
       <comment>Logical AND of Wakeup_Status and Wakeup_Mask (show only the enabled events).
       </comment>
       <bits name="IFC0_Event_Cause" pos="0" access="r" rst="0">
       </bits>        
       <bits name="IFC1_Event_Cause" pos="1" access="r" rst="0">
       </bits>
       <bits name="DMAE_Event_Cause" pos="2" access="r" rst="0">
       </bits>
       <bits name="DMAI_Event_Cause" pos="3" access="r" rst="0">
       </bits>
       <bits name="SOF0_Event_Cause" pos="4" access="r" rst="0">
       </bits>
       <bits name="SOF1_Event_Cause" pos="5" access="r" rst="0">
       </bits>
    </reg16>  
    <reg16 name="Sema" protect="w">
       <bits name="Sema" pos="0" access="w" rst="1">
            <comment>VoC semaphore. If the register is read when the field = '1', the field = '0' on the next VoC clock cycle. Can write '0' or '1' in this field.
            </comment>
       </bits>
    </reg16>
    <hole size="144"/>
    <reg name="REG01" protect="rw">
        <bits name="REG0" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register REG0
            </comment>
        </bits>
        <bits name="REG1" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register REG1
            </comment>
        </bits>
        <l name="REG0"/>
        <h name="REG1"/>
    </reg>
    <reg name="REG23" protect="rw">
        <bits name="REG2" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register REG2
            </comment>
        </bits>
        <bits name="REG3" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register REG3
            </comment>
        </bits>
        <l name="REG2"/>
        <h name="REG3"/>
    </reg>
    <reg name="REG45" protect="rw">
        <bits name="REG4" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register REG4
            </comment>
        </bits>
        <bits name="REG5" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register REG5
            </comment>
        </bits>
        <l name="REG4"/>
        <h name="REG5"/>
    </reg>
    <reg name="REG67" protect="rw">
        <bits name="REG6" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register REG6
            </comment>
        </bits>
        <bits name="REG7" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register REG7
            </comment>
        </bits>
        <l name="REG6"/>
        <h name="REG7"/>
    </reg>
    <reg name="ACC0" protect="rw">
        <bits name="ACC0_LO" pos="15:0" access="rw" rst="0">
            <comment>Voc Accumulator Register ACC0 (lo)
            </comment>
        </bits>
        <bits name="ACC0_HI" pos="31:16" access="rw" rst="0">
            <comment>Voc Accumulator Register ACC0 (hi)
            </comment>
        </bits>
        <l name="ACC0_lo"/>
        <h name="ACC0_hi"/>
    </reg>
    <reg name="ACC1" protect="rw">
        <bits name="ACC1_LO" pos="15:0" access="rw" rst="0">
            <comment>Voc Accumulator Register ACC1 (lo)
            </comment>
        </bits>
        <bits name="ACC1_HI" pos="31:16" access="rw" rst="0">
            <comment>Voc Accumulator Register ACC1 (hi)
            </comment>
        </bits>
        <l name="ACC1_lo"/>
        <h name="ACC1_hi"/>
    </reg>
    <reg name="RL6" protect="rw">
        <bits name="RL6_LO" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register RL6 (lo)
            </comment>
        </bits>
        <bits name="RL6_HI" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register RL6 (hi)
            </comment>
        </bits>
        <l name="RL6_lo"/>
        <h name="RL6_hi"/>
    </reg>
    <reg name="RL7" protect="rw">
        <bits name="RL7_LO" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register RL7 (lo)
            </comment>
        </bits>
        <bits name="RL7_HI" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register RL7 (hi)
            </comment>
        </bits>
        <l name="RL7_lo"/>
        <h name="RL7_hi"/>
    </reg>
    <reg16 name="PC" protect="rw">
        <bits name="PC" pos="15:0" access="rw" rst="0">
            <comment>Voc Program Counter Register PC
            </comment>
        </bits>
    </reg16>
    <reg16 name="RA" protect="rw">
        <bits name="RA" pos="15:0" access="rw" rst="0">
            <comment>Voc Return Address Register RA
            </comment>
        </bits>
    </reg16>
    <reg16 name="SP16" protect="rw">
        <bits name="SP16" pos="15:0" access="rw" rst="0">
            <comment>Voc Stack Register SP16
            </comment>
        </bits>
    </reg16>
    <reg16 name="SP32" protect="rw">
        <bits name="SP32" pos="15:0" access="rw" rst="0">
            <comment>Voc Stack Register SP32
            </comment>
        </bits>
    </reg16>
    <hole size="64"/>
    <reg16 name="BKP" protect="rw">
        <bits name="BKP" pos="15:0" access="rw" rst="0">
            <comment>Voc Program Breakpoint Register. Valid when the Dbg_On mode in the Ctrl register is set to '1'
            </comment>
        </bits>
    </reg16>
    <hole size="16"/>
    <reg16 name="PC_PREV" protect="r">
        <bits name="PC_PREV" pos="15:0" access="r" rst="0">
            <comment>Previous PC value. Used to track the source PC of a branch when the stall_on_branch_taken bit in the Debug register is enabled
            </comment>
        </bits>
    </reg16>
    <reg16 name="LOOP" protect="r">
        <bits name="LOOP0" pos="7:0" access="r" rst="0">
            <comment>Loop 0 counter value
            </comment>
        </bits>
        <bits name="LOOP1" pos="15:8" access="r" rst="0">
            <comment>Loop 1 counter value
            </comment>
        </bits>
    </reg16>
    
</module>

</archive>
<archive relative='bb_ahb_monitor.xml' >

<module name="bb_ahb_monitor" category="Debug">
    <reg name="Control" protect="rw">
        <bits name="Enable" pos="0" access="rw" rst="0">
            <comment>Enable (start) the Monitor.
            </comment>
        </bits>
        <bits name="Record" pos="4" access="rw" rst="1">
            <options>
                <option name="Single_Shot" value="0"><comment>Monitor disable itself after the time window expires.</comment></option>
                <option name="Multi_Shot" value="1"/>
            </options>
        </bits>
        <bits name="Accumulation_Mode" pos="5" access="rw" rst="1">
            <options>
                <option name="Mean" value="0"><comment>get use counter value in the read register, sum the latency and count the number of access</comment></option>
                <option name="Max" value="1"><comment>get maximum of use counter and read register per time window, get maximum of latency per access.</comment></option>
            </options>
        </bits>
        <bits name="Target" pos="11:8" access="rw" rst="0">
            <comment>Define the element to monitor, it can be the BUS, a master, a slave or a special signal from Debug_Port: Signal_Select1.</comment>
            <options>
                <option name="BB_BUS" value="0"/>
                <option name="BB_IFC" value="1"><comment>Masters</comment></option>
                <option name="VOC" value="2"/>
                <option name="BCPU" value="3"/>
                <option name="BB_AHB2AHB" value="4"/>
                <option name="BB_Mem_Ext" value="5"><comment>Slaves</comment></option>
                <option name="BB_Mem_Int" value="6"/>
                <option name="BB_AHB2AHB_Slave" value="7"/>
                <option name="BB_IFC" value="8"/>
                <option name="BB_VOC_Slave" value="9"/>
                <option name="BB_SRam" value="10"/>
                <option name="Signal_Select1" value="11"><comment>Signal (counted as Slaves, the signal is used as a select signal)</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="Time_Window" pos="18:16" access="rw" rst="1">
            <comment>Define the duration af a Time Window</comment>
            <options>
                <option name="TW_1kC" value="0"><comment>1024 System clock cycle</comment></option>
                <option name="TW_32kC" value="1"><comment>32768 System clock cycle</comment></option>
                <option name="TW_1MC" value="2"><comment>1048576 System clock cycle</comment></option>
                <option name="TW_16MC" value="3"><comment>16777216 System clock cycle</comment></option>
                <option name="TW_1F" value="4"><comment>1 Frame (TCU must be running)</comment></option>
                <option name="TW_26F" value="5"><comment>26 Frames (TCU must be running)</comment></option>
                <option name="TW_52F" value="6"><comment>52 Frames (TCU must be running)</comment></option>
                <option name="TW_104F" value="7"><comment>104 Frames (TCU must be running)</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name="Access_Count" protect="rw">
        <bits name="Access_Count" pos="23:0" access="r" rst="0">
            <comment>Access counter reader (full 24bits view, 8 lower bit are also readable in latency register).
                <br/>
                <br/>For masters: count the number of access
                <br/>For slaves: count the number of access by checking the falling edge of select signal.
            </comment>
        </bits>
    </reg>
    <reg name="Use" protect="rw">
        <bits name="Use" pos="23:0" access="r" rst="0">
            <comment>Bus usage counter reader.
                <br/>
                <br/>For the bus: Count the cycles when the bus is used (by any master)
                <br/>For masters: Count cycles when selected master is granted
                <br/>For slaves: Count cycles when select signal is high.
            </comment>
        </bits>
    </reg>
    <reg name="Latency" protect="rw">
        <bits name="Latency" pos="23:0" access="r" rst="0">
            <comment>Latency counter reader (0xffffff means overflow)
                <br/>In Max mode, it's updated after each access, else it's adding the latency from all access in the time window
                <br/>For slaves it counts the duration of each access (in mean mode, it will give the same value as Use)
                <br/>
                <br/>For masters: count cycles between rise of request and first access.
                <br/>For slaves: count the duration of access by counting the high cycles. In that case it is equivalent to the use counter except in max mode where it counts the max by access not by time window.
            </comment>
        </bits>
        <bits name="Access_Cnt" pos="31:24" access="r" rst="0">
            <comment>Number of access (0xff means overflow)
                <br/>In max mode: 0 if no access, 1 if at least 1 access.
                <br/>In mean mode: it counts the number of access during the time window.
                <br/>
                <br/>For masters: count the number of access
                <br/>For slaves: count the number of access by checking the falling edge of select signal.
                <br/>
                <br/>It is the same as the Access_Count register except that the value is saturated on 8 bits. It's repeated here to garanty coherence with Latency to enable calculs of Mean Latency by doing the following operation:
                <br/> Mean_Latency = Latency/Access_Cnt .
            </comment>
        </bits>
    </reg>
</module>
</archive>
<archive relative='bb_cp2.xml' >

<module name="bb_cp2" category="Baseband">
    <reg name="ctrl" protect="rw">
        <bits name="First Poly" pos="2:0" access="rw" rst="111" display="hex">
            <comment>This field is used for setting the first polynomial to encode
                     or the CRC computation
                    <br/>First polynomial to encode :
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
                    <br/>Cyclic code :
                    <br/>000 = D8 + D4 + D3 + D2 + 1
                    <br/>001 = D3 + D + 1
                    <br/>010 = D14 + D13 + D5 + D3 + D2 +1
                    <br/>011 = D6 + D5 + D3 + D2 + D1 + 1
                    <br/>100 = D10 + D8 + D6 + D5 + D4 + D2 + 1
                    <br/>101 = D16 + D12 + D5 + 1
                    <br/>110 = (D23 + 1)*(D17 + D3 + 1)
                    <br/>111 = reserved
            </comment>
        </bits>
        <bits name="Second Poly" pos="5:3" access="rw" rst="111" display="hex">
            <comment>Second polynomial to encode :
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="Third Poly" pos="8:6" access="rw" rst="111" display="hex">
            <comment>Third polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="Fourth Poly" pos="11:9" access="rw" rst="111" display="hex">
            <comment>Fourth polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="Fith Poly" pos="14:12" access="rw" rst="111" display="hex">
            <comment>Fith polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="Sixth Poly" pos="17:15" access="rw" rst="111" display="hex">
            <comment>Sixth polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="RSC Poly" pos="20:18" access="rw" rst="111" display="hex">
            <comment>RSC (Recursive Systematic Convolutional) polynomial code:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No RSC
            </comment>
        </bits>
        <bits name="NB Poly" pos="23:21" access="rw" rst="111" display="hex">
            <comment>Number of polynomial code to process:
                    <br/>0x0 = 0
                    <br/>0x1 = 1 (First Poly)
                    <br/>0x2 = 2 (First poly and second Poly)
                    <br/>0x3 = 3 (First poly, second poly, third Poly)
                    <br/>0x6 = 6 (first Poly to sixth Poly)
                    <br/>0x7 = reserved
            </comment>
        </bits>
        <bits name="Enable Puncturing" pos="24" access="rw" rst="1">
            <comment>Enable Puncturing
                    <br/>0 = No puncturing (puncturing disabled)
                    <br/>1 = Enable puncturing
            </comment>
        </bits>
        <bits name="Enable Edge" pos="25" access="rw" rst="0">
            <comment>Enable EDGE
                    <br/>0 = Edge function disable
                    <br/>1 = Edge function enable
            </comment>
        </bits>
        <bits name="Edge Poly" pos="27:26" access="rw" rst="00" display="hex">
            <comment>edge code to process:
                    <br/>00 = G7
                    <br/>01 = D8+D6+D3+1
                    <br/>10 = D12+D11+D10+D8+D5+D4+1
            </comment>
        </bits>
    </reg>

    <reg name="bit number" protect="rw">
        <bits name="Bit number" pos="9:0" access="rw" rst="0x3FF" display="hex">
            <comment>Number of inputs bits to process
                <br/>0x01 = 1
                <br/>0x02 = 2
                <br/>0x03 = 3
                <br/>...
                <br/>0xFD = 253
                <br/>0xFE = 254
                <br/>0xFF = 255
                <br/>0x100 = 256
                <br/>...
                <br/>0x1BF = 447
                <br/>0x3ff = 1023
            </comment>
        </bits>
    </reg>

    <reg name="Status" protect="r">
        <bits name="Enable" pos="0:0" access="r" rst="0">
            <comment>When 1 the bb_cp2 is running
            </comment>
        </bits>
    </reg>

    <reg name="lram_addr" protect="rw">
        <bits name="LRAM Address" pos="4:0" access="rw" rst="0x0" display="hex">
            <comment>LRAM address for the next access
                <br/>Automatically incremented after each access
            </comment>
        </bits>
        <bits name="LRAM Select" pos="5" access="rw" rst="0x1">
            <comment>Select LRAM for the next access
                <br/>0 = Puncturing LRAM
                <br/>1 = Data LRAM
            </comment>
        </bits>
        <bits name="LRAM High Address" pos="6" access="rw" rst="0">
            <comment>LRAM High address
                <br/>Automatically incremented after each access
            </comment>
        </bits>

    </reg>

    <reg name="CRC code LSB" protect="r">
        <bits name="CRC code" pos="31:0" access="r" rst="0xFFFFFFFF" display="hex">
            <comment>CRC code LSB bits
            </comment>
        </bits>
    </reg>

    <reg name="CRC code MSB" protect="r">
        <bits name="CRC code" pos="7:0" access="r" rst="0xFF" display="hex">
            <comment>CRC code MSB bits
            </comment>
        </bits>
    </reg>

    <hole size="800" />

    <reg name="CP2 Select" protect="rw">
        <bits name="CP2 Select" pos="0" access="rw" rst="1">
            <comment>CP2 register access selection bit
                <br/>0= All registers are only accessible through the APB bus
                <br/>1= All registers are only accessible by the BCPU through the CP2 bus
            </comment>
        </bits>
    </reg>

    <reg name="LRAM Data" protect="rw">
        <bits name="LRAM Data" pos="31:0" access="rw" rst="no" display="hex">
            <comment>LRAM Data. This register is used for access to the
                     puncturing LRAM or to the Data LRAM.
                <br/>All access into this register, increment the LRAM_ADDR register.
            </comment>
        </bits>
    </reg>

</module>

<cjoker>
// changing xml generated defines
#undef BB_CP2_ENABLE_PUNCTURING
#undef BB_CP2_LRAM_DATA
#undef BB_CP2_BIT_NUMBER

#define BB_CP2_ENABLE_PUNCTURING(n) (((n)&amp;1)&lt;&lt;24)

/// BB_CP2 address mapping
#define BB_CP2_CTRL                              0
#define BB_CP2_BIT_NUMBER                        1
#define BB_CP2_STATUS                            2
#define BB_CP2_LRAM_ADDR                         3
#define BB_CP2_CRC_CODE_LSB                      4
#define BB_CP2_CRC_CODE_MSB                      5
#define BB_CP2_LRAM_DATA                         0
#define BB_CP2_LRAM_PUNC                         (0&lt;&lt;5)
#define BB_CP2_DATA_LRAM                         (1&lt;&lt;5)

/* BB_CP2 ACCESSES */
// macro for converting a constant to a string
#define CT_CONVERT_TO_STRING(x) #x
// control register -> GPR
#define CT_BB_CP2_RD_CTRL_REG(regaddr, n)       asm volatile("cfc2 %0, $" CT_CONVERT_TO_STRING(regaddr) :"=r"((n)))
//              GPR -> control register
#define CT_BB_CP2_WR_CTRL_REG(regaddr, n)       asm volatile("ctc2 %0, $" CT_CONVERT_TO_STRING(regaddr) ::"r"((n)))
// general register -> GPR
#define CT_BB_CP2_RD_GNRL_REG_GPR(regaddr, n)   asm volatile("mfc2 %0, $" CT_CONVERT_TO_STRING(regaddr) :"=r"((n)))
//              GPR -> general register
#define CT_BB_CP2_WR_GNRL_REG_GPR(regaddr, n)   asm volatile("mtc2 %0, $" CT_CONVERT_TO_STRING(regaddr) ::"r"((n)))
// general register -> memory
#define CT_BB_CP2_RD_GNRL_REG_MEM(regaddr, out)	asm volatile("swc2 $" CT_CONVERT_TO_STRING(regaddr) ", 0(%0)"::"r"((out)))
//           memory -> general register
#define CT_BB_CP2_WR_GNRL_REG_MEM(regaddr, in) 	asm volatile("lwc2 $" CT_CONVERT_TO_STRING(regaddr) ", 0(%0)"::"r"((in)))


</cjoker>

</archive>

<archive relative='bb_ifc.xml' >

<include file="globals.xml"/>
<module name="bb_ifc" category="Baseband">
  <var name="BB_IFC_ADDR_LEN" value="15" />

  <var name="BB_IFC_ADDR_ALIGN" value="2" />

  <var name="BB_IFC_TC_LEN" value="8" />

  

  <struct count="2" name="ch">
    <comment>
        The Channel 0 conveys data from the AIF to the memory.<br/>
        The Channel 1 conveys data from the memory to the AIF.
        <br/>These Channels only exist with Voice Option.
    </comment>
    <reg protect="rw" name="control">
      <bits access="w" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer. </comment>
      </bits>

      <bits access="w" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit disable the channel.
        <br />When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled. </comment>
      </bits>

      <bits access="rw" name="auto_disable" pos="4" rst="0">
        <comment>Automatic channel Disable. When this bit is set, the channel is automatically disabled at the next interrupt. 
        </comment>
      </bits>
    </reg>

    <reg protect="r" name="status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>When 1 the channel is enabled</comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>When 1 the fifo is empty </comment>
      </bits>

      <bits access="r" name="cause_ief" pos="8" rst="0">
        <comment>Cause interrupt End of FIFO. </comment>
      </bits>

      <bits access="r" name="cause_ihf" pos="9" rst="0">
        <comment>Cause interrupt Half of FIFO. </comment>
      </bits>

      <bits access="r" name="cause_i4f" pos="10" rst="0">
        <comment>Cause interrupt Quarter of FIFO. </comment>
      </bits>
      
      <bits access="r" name="cause_i3_4f" pos="11" rst="0">
        <comment>Cause interrupt Three Quarter of FIFO. </comment>
      </bits>

      <bits access="r" name="ief" pos="16" rst="0">
        <comment>End of FIFO interrupt status bit. </comment>
      </bits>

      <bits access="r" name="ihf" pos="17" rst="0">
        <comment>Half of FIFO interrupt status bit. </comment>
      </bits>

      <bits access="r" name="i4f" pos="18" rst="0">
        <comment>Quarter of FIFO interrupt status bit. </comment>
      </bits>

      <bits access="r" name="i3_4f" pos="19" rst="0">
        <comment>Three Quarter of FIFO interrupt status bit.</comment>
      </bits>
    </reg>

    <reg protect="rw" name="start_addr">
      <bits access="rw" name="start_addr"
            pos="NB_BITS_ADDR-1:BB_IFC_ADDR_ALIGN" rst="0xFFFFFFFF" display="hex">
        <comment>AHB Start Address. This field represent the start address of the FIFO located in RAM.
        </comment>
      </bits>
     </reg>

    <reg protect="rw" name="Fifo_Size">
      <bits access="rw" name="Fifo_Size" pos="14:4" rst="0xFFF" display="hex">
        <comment>Fifo size in bytes, max 32kBytes.
            <br />The size of the fifo must be a multiple of 16 (The four LSB are always zero). 
        </comment>
      </bits>
    </reg>
    <hole size="32" />
    <reg protect="rw" name="int_mask">
      <bits access="rw" name="end_fifo" pos="8" rst="0">
        <comment>END FIFO Mask interrupt. When one this interrupt is enabled.
        </comment>
      </bits>

      <bits access="rw" name="half_fifo" pos="9" rst="0">
        <comment>HALF FIFO Mask interrupt. When one this interrupt is enabled.
        </comment>
      </bits>

      <bits access="rw" name="quarter_fifo" pos="10" rst="0">
        <comment>QUARTER FIFO Mask interrupt. When one this interrupt is
        enabled. </comment>
      </bits>
      
      <bits access="rw" name="three_quarter_fifo" pos="11" rst="0">
        <comment>THREE QUARTER FIFO Mask interrupt. When one this interrupt is
        enabled. </comment>
      </bits>
    </reg>

    <reg protect="rw" name="int_clear">
      <bits access="c" name="end_fifo" pos="8" rst="0">
        <comment>Write one to clear end of fifo interrupt. </comment>
      </bits>

      <bits access="c" name="half_fifo" pos="9" rst="0">
        <comment>Write one to clear half of fifo interrupt. </comment>
      </bits>

      <bits access="c" name="quarter_fifo" pos="10" rst="0">
        <comment>Write one to clear Quarter fifo interrupt. </comment>
      </bits>

      <bits access="c" name="three_quarter_fifo" pos="11" rst="0">
        <comment>Write one to clear Three Quarter fifo interrupt. </comment>
      </bits>
    </reg>

    <reg protect="r" name="cur_ahb_addr">
      <bits access="r" name="cur_ahb_addr" pos="NB_BITS_ADDR-1:0" rst="0" display="hex">
        <comment>Current AHB address value. The nine MSB bit is constant and
        equal to the PAGE_ADDR field in the IFC_CH_AHB_START_ADDR register.
        </comment>
      </bits>
    </reg>
  </struct>

  

  <reg protect="rw" name="ch2_control">
    <bits access="w" name="enable" pos="0" rst="no">
      <comment>Channel Enable, write one in this bit enable the channel.
      <br />When the channel is enabled, for a peripheral to memory transfer
      the DMA wait request from peripheral to start transfer. </comment>
    </bits>

    <bits access="w" name="disable" pos="1" rst="no">
      <comment>Channel Disable, write one in this bit disable the channel.
      <br />When writing one in this bit, the current AHB transfer and current
      APB transfer (if one in progress) is completed and the channel is then
      disabled.</comment>
    </bits>

    <bits access="rw" name="burst_size" pos="16" rst="1">
      <comment>Burst size on AHB bus 
        <br />0 = Single access 
        <br />1 = burst Access (4 words). 
      </comment>
    </bits>

    <bits access="rw" name="fifo_mode" pos="17" rst="1">
      <comment>Set FIFO mode . <br />0 = no fifo mode, transfer stop when the
      current transfer counter reaches zero. Channel must be re-enabled for
      future transfer. <br />1 = Fifo mode, when the current AHB address
      counter reaches the end address of the FIFO. AHB address counter is
      reloaded with the initial value. In FIFO mode channel is not disabled at
      the end of the transfer.</comment>
    </bits>
  </reg>

  <reg protect="r" name="ch2_status">
    <bits access="r" name="enable" pos="0" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>In no fifo mode the channel is automatically disabled at the
      end of the transfer. In fifo mode the channel is disabled only when
      disabled write is performed in the control register. </comment>
    </bits>

    <bits access="r" name="fifo_empty" pos="4" rst="1">
      <comment>When 1 the fifo is empty </comment>
    </bits>

    <bits access="r" name="cause_itc" pos="8" rst="0">
      <comment>Cause interrupt End of TC.</comment>
    </bits>

    <bits access="r" name="cause_ief" pos="9" rst="0">
      <comment>Cause interrupt End of FIFO. </comment>
    </bits>

    <bits access="r" name="cause_ihtc" pos="10" rst="0">
      <comment>Cause interrupt Half Transfer Count (This interruption is
      generated when the IFC has transferred 96 word).</comment>
    </bits>

    <bits access="r" name="itc" pos="12" rst="0">
      <comment>End of TC interrupt status bit. </comment>
    </bits>

    <bits access="r" name="ief" pos="13" rst="0">
      <comment>End of FIFO interrupt status bit. </comment>
    </bits>

    <bits access="r" name="ihtc" pos="14" rst="0">
      <comment>Half TC interrupt status bit.</comment>
    </bits>

    <bits access="r" name="cur_tc" pos="BB_IFC_TC_LEN-1+16:16" rst="0">
      <comment>Current value of transfer counter.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch2_start_addr">
    <bits access="rw" name="start_addr"
          pos="BB_IFC_ADDR_LEN-1:BB_IFC_ADDR_ALIGN" rst="0xFFFFFFFF" display="hex">
      <comment>AHB Start Address. This field represent the start address in
      the page. The AHB FIFO start address is the concatenation of of
      Page_ADDR and Start_Addr field. </comment>
    </bits>

    <bits access="rw" name="page_addr" pos="NB_BITS_ADDR-1:BB_IFC_ADDR_LEN" rst="0xFFFFFFFF" display="hex">
      <comment>AHB PAGE Address. These nine bits is the MSB bit of the start
      AHB FIFO address. These bits are not incremented during the transfer.
      </comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch2_end_addr">
    <bits access="rw" name="end_addr"
          pos="BB_IFC_ADDR_LEN-1:BB_IFC_ADDR_ALIGN" rst="0xFFFFFFFF" display="hex">
      <comment>The last page address of the FIFO, it is the first address not
      used for the FIFO. The start address of the FIFO is specified by the
      register AHB_ADDR and the last page address of the FIFO is specified by
      this field. The size of the fifo (END_ADDR - START_ADDR) must be a
      multiple of burst of 4x32-bits. </comment>
    </bits>
    <bits access="r" name="page_addr" pos="NB_BITS_ADDR-1:BB_IFC_ADDR_LEN" rst="0xFFFFFFFF" display="hex">
      <comment>AHB PAGE Address. Read only equal to the page_addr field in ch2_start_addr register.
      </comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch2_tc">
    <bits access="rw" name="tc" pos="BB_IFC_TC_LEN-1:0" rst="0xFFFFFFFF" display="hex">
      <comment>Transfer Count <br/>In no FIFO mode, this bit indicated
      the transfer size in 32-bits word to perform. Up to 255 32-bits word per
      transfer. <br/>In FIFO mode this field define, after how many
      transfer an interrupt in generated.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch2_int_mask">
    <bits access="rw" name="end_tc" pos="0" rst="0">
      <comment>End TC Mask interrupt. When one this interrupt is
      enabled.</comment>
    </bits>

    <bits access="rw" name="end_fifo" pos="1" rst="0">
      <comment>END FIFO Mask interrupt. When one this interrupt is enabled.
      </comment>
    </bits>

    <bits access="rw" name="half_tc" pos="2" rst="0">
      <comment>Half TC Mask interrupt. When one this interrupt is
      enabled</comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch2_int_clear">
    <bits access="c" name="end_tc" pos="0" rst="0">
      <comment>Write one to clear end of TC interrupt.</comment>
    </bits>

    <bits access="c" name="end_fifo" pos="1" rst="0">
      <comment>Write one to clear end of FIFO interrupt.</comment>
    </bits>

    <bits access="c" name="half_fifo" pos="2" rst="0">
      <comment>Write one to clear end of Half TC interrupt.</comment>
    </bits>
  </reg>

  <reg protect="r" name="ch2_cur_ahb_addr">
    <bits access="r" name="cur_ahb_addr" pos="NB_BITS_ADDR-1:0" rst="0">
      <comment>Current AHB address value. The nine MSB bit is constant and
      equal to the PAGE_ADDR field in the IFC_CH_AHB_START_ADDR register.
      </comment>
    </bits>
  </reg>
  

  <reg protect="w" name="ch3_control">
    <bits access="w" name="enable" pos="0" rst="no">
      <comment>Channel Enable, write one in this bit enable the channel.
      <br />When the channel is enabled, for a peripheral to memory transfer
      the DMA wait request from peripheral to start transfer. </comment>
    </bits>

    <bits access="w" name="disable" pos="1" rst="no">
      <comment>Channel Disable, write one in this bit disable the channel.
      <br />When writing one in this bit, the current AHB transfer and current
      APB transfer (if one in progress) is completed and the channel is then
      disabled.</comment>
    </bits>
  </reg>

  <reg protect="r" name="ch3_status">
    <bits access="r" name="enable" pos="0" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>In no fifo mode the channel is automatically disabled at the
      end of the transfer. In fifo mode the channel is disabled only when
      disabled write is performed in the control register. </comment>
    </bits>

    <bits access="r" name="fifo_empty" pos="4" rst="1">
      <comment>When 1 the fifo is empty </comment>
    </bits>

    <bits access="r" name="cause_itc" pos="8" rst="0">
      <comment>Cause interrupt End of TC.</comment>
    </bits>

    <bits access="r" name="itc" pos="12" rst="0">
      <comment>End of TC interrupt status bit. </comment>
    </bits>

    <bits access="r" name="cur_tc" pos="BB_IFC_TC_LEN-1+16:16" rst="0">
      <comment>Current value of transfer counter.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch3_start_addr">
    <bits access="rw" name="start_addr"
          pos="BB_IFC_ADDR_LEN-1:BB_IFC_ADDR_ALIGN" rst="0xFFFFFFFF" display="hex">
      <comment>AHB Start Address.</comment>
    </bits>
  </reg>
  <hole size="32"/>
  <reg protect="rw" name="ch3_tc">
    <bits access="rw" name="tc" pos="BB_IFC_TC_LEN-1:0" rst="0xFFFFFFFF" display="hex">
      <comment>Transfer Count <br/>this bit indicated
      the transfer size in 32-bits word to perform. Up to 255 32-bits word per
      transfer.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch3_int_mask">
    <bits access="rw" name="end_tc" pos="0" rst="0">
      <comment>End TC Mask interrupt. When one this interrupt is
      enabled.</comment>
    </bits>
  </reg>
  <reg protect="rw" name="ch3_int_clear">
    <bits access="c" name="end_tc" pos="0" rst="0">
      <comment>Write one to clear end of TC interrupt.</comment>
    </bits>
  </reg>

  <reg protect="r" name="ch3_cur_ahb_addr">
    <bits access="r" name="cur_ahb_addr" pos="NB_BITS_ADDR-1:0" rst="0">
      <comment>Current AHB address value. 
      </comment>
    </bits>
  </reg>

</module>
</archive>
<archive relative='bb_irq.xml' >


<include file="globals.xml"/>

<module name="bb_irq" category="Baseband">
    
    
    <enum name="BCPU_Irq_Lines">
        <entry name="BCpu_Main_Irq_Line"><comment>BCPU Irq Lines</comment></entry>
        
        <entry name="BCpu_Debug_Irq_Line" value="4"/>
        <entry name="BCpu_Host_Irq_Line"/>
    </enum>


    <reg name="Cause" protect="rw">
        <comment>If cause is not null and interrupt are enabled then the interrupt line 0 is driven on the system CPU.
            <br/>The cause for the Irq sources, one bit for each module's irq source.
            <br/>The cause is the actual Irq source masked by the mask register.
        </comment>
        <bits name="Cause" pos="BB_NB_IRQ-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Status" protect="rw">
        <comment>The status for the level Irq sources, one bit for each module's irq source.
            <br/>The status reflect the actual Irq source.
        </comment>
        <bits name="Status" pos="BB_NB_IRQ-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Mask_Set" protect="rw">
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Set" pos="BB_NB_IRQ-1:0" access="rs" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Mask_Clear" protect="rw">
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Clr" pos="BB_NB_IRQ-1:0" access="rc" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="NonMaskable" protect="rw">
        <bits name="Main_IRQ" pos="10" access="r" rst="0">
            <comment>This is the Main Irq source it drive the system CPU interrupt line 0.
                <br/>This bit comes from the modules irq and is masked by the Mask and SC registers.
            </comment>
        </bits>
        
        <bits name="Debug_IRQ" pos="14" access="rw" rst="0">
            <comment>This is the debug Irq source, the value written here drives the system CPU interrupt line 4.
            </comment>
        </bits>
        <bits name="Host_IRQ" pos="15" access="r" rst="0">
            <comment>This is the Host Irq source it drive the system CPU interrupt line 5.
                <br/>This bit is controlled by the host internal register.
            </comment>
        </bits>
        <bits name="IntEnable_Status" pos="31" access="r" rst="1">
            <comment>Status of the Interrupt enable semaphore bit.
            </comment>
        </bits>
   </reg>
    <reg name="SC" protect="">
        <bits name="IntEnable" pos="0" access="rw" rst="1">
            <comment>Interrupt enable semaphore, used for critical section.
                <br/>Read returns its value and then clears it to '0' disabling interrupts.
                <br/>Write the read value to restore the previous state, this will exit the critical section.
            </comment>
        </bits>
    </reg>
    <reg name="WakeUp_Mask" protect="rw">
        <comment>Each bit to '1' in that registers allows the correcponding interrupt to wake up the System CPU (i.e.: Reenable it's clock, see CLOCK_BB_ENABLE and CLOCK_BB_DISABLE registers in general registers section)
        </comment>
        <bits name="WakeUp_Mask" pos="BB_NB_IRQ-1:0" access="rw" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Cpu_Sleep" protect="rw">
        <bits name="Sleep" pos="0" access="w" rst="0">
            <comment>Writing '1' to this bit will put the BCPU to sleep (i.e.: Disable it's clock, see CLOCK_BB_ENABLE and CLOCK_BB_DISABLE registers in general registers section)
            </comment>
        </bits>
    </reg>
    <reg name="Pulse_Mask_Set" protect="rw">
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Pulse_Mask_Set" pos="BB_NB_IRQ_PULSE-1:0" access="rs" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Mask_Clr" protect="rw">
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Pulse_Mask_Clr" pos="BB_NB_IRQ_PULSE-1:0" access="rc" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Clear" protect="rw">
        <comment>Writing '1' clears the corresponding Pulse IRQ.
            <br/>Pulse IRQ are set by the modules and cleared here.
        </comment>
        <bits name="Pulse_Clr" pos="BB_NB_IRQ_PULSE-1:0" access="c" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Status" protect="rw">
        <comment>The status for the Pulse Irq sources, one bit for each module's irq source.
            <br/>The status reflect the actual Irq source.
        </comment>
        <bits name="Status" pos="BB_NB_IRQ_PULSE-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>


</module>

</archive>
<archive relative='bb_sram.xml' >


<include file="globals.xml"/>

<module name="bb_sram" category="Baseband">

    <memory name="ram_array" size="BB_SRAM_SIZE">
        <comment>Baseband side internal memory, also used by accelerators.
        </comment>
    </memory>
</module>


</archive>

<archive relative='comregs.xml' >

<module name="comregs" category="Modem">

    <var name="NB_INT" value="16" />
    <var name="NB_INT_HALF" value="8" />

    <reg name="Snapshot" protect="r">
        <bits name="Snapshot" pos="1:0" access="r" rst="0">
            <comment>Value of snapshots, snapshot value is automatically incremented at frame interrupt. This snapshot counter wrap at the value given by Snapshot_Cfg.
            </comment>
        </bits>
    </reg>
    <reg name="Snapshot_Cfg" protect="rw">
        <bits name="Snapshot_Cfg"  pos="1:0" access="rw" rst="2">
            <comment>Number of snapshot.
            </comment>
            <options>
                <option name="Wrap_2" value="2"><comment>The snapshot counter as Two values : 0,1.</comment></option>
                <option name="Wrap_3" value="3"><comment>The snapshot counter as Three values : 0,1,2.</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Cause" protect="rw">
        <bits name="Irq0_Cause" pos="7:0" access="r" rst="0">
            <comment>When read from the Xcpu, this return the cause of interruption, basically the set/clear register Irq0 part masked with Irq0_Mask.
                <br/>When read from the Bcpu, this return the cause of interruption, basically the set/clear register Irq0 part masked with Irq0_Mask.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Irq1_Cause" pos="15:8" access="r" rst="0">
            <comment>When read from the Xcpu, this return the cause of interruption, basically the set/clear register X_Irq1 part masked with X_Irq1_Mask.
                <br/>When read from the Bcpu, this return the cause of interruption, basically the set/clear register Irq1 part masked with Irq1_Mask.
            </comment>
            <options><mask/><shift/></options>
        </bits>
    </reg>
    <reg name="Mask_Set" protect="rw">
        <bits name="Irq0_Mask_Set" pos="7:0" access="rs" rst="0">
            <comment>When read: returns the value of the Irq0_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' sets the corresponding bit in the Irq0_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The Irq0_Mask masks the set/clear register to trigger interrupts on the XCPU/BCPU using line 0.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Irq1_Mask_Set" pos="15:8" access="rs" rst="0">
            <comment>When read: returns the value of the Irq1_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' sets the corresponding bit in the Irq1_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The Irq1_Mask masks the set/clear register to trigger interrupts on the XCPU/BCPU using line 1.
            </comment>
           <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="Mask_Clr" protect="rw">
        <bits name="Irq0_Mask_Clr" pos="7:0" access="rc" rst="0">
            <comment>When read: returns the value of the Irq0_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' clears the corresponding bit in the Irq0_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The Irq0_Mask masks the set/clear register to trigger interrupts on the XCPU/BCPU using line 0.
             </comment>
            <options><mask/><shift/><default/></options>
         </bits>
        <bits name="Irq1_Mask_Clr" pos="15:8" access="rc" rst="0">
            <comment>When read: returns the value of the Irq1_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' clears the corresponding bit in the Irq1_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The Irq1_Mask masks the set/clear register to trigger interrupts on the XCPU/BCPU using line 1.
             </comment>
             <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="ItReg_Set" protect="rw">
        <comment>If accesses to ItReg_Set and ItReg_Clr registers are done simultaneously from both CPUs and affecting the same bits, the priority is given to set a bit.
            <br/>Note: Read value is the SET value by itself.
        </comment>
        <bits name="Irq0_Set" pos="7:0" access="rs" rst="0">
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' sets the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the XCPU/BCPU if enabled.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Irq1_Set" pos="15:8" access="rs" rst="0">
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' sets the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the XCPU/BCPU if enabled.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bitgroup name="Irq">
            <entry ref="Irq0_Set"/>
            <entry ref="Irq1_Set"/>
        </bitgroup>
    </reg>

    <reg name="ItReg_Clr" protect="rw">
        <comment>If accesses to ItReg_Set and ItReg_Clr registers are done simultaneously from both CPUs and affecting the same bits, the priority is given to set a bit.
            <br/>Note: Read value is the IRQ value from the other side.
        </comment>
        <bits name="Irq0_Clr" pos="7:0" access="rc" rst="0">
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' clears the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the XCPU/BCPU if enabled.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Irq1_Clr" pos="15:8" access="rc" rst="0">
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' clears the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the XCPU/BCPU if enabled.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bitgroup name="Irq">
            <entry ref="Irq0_Clr"/>
            <entry ref="Irq1_Clr"/>
        </bitgroup>
    </reg>

</module>
</archive>
<archive relative='bcpu_cache.xml' >

<module name="bcpu_cache" category="Debug">

    <struct name="Line" count="exp2(6)">
        <reg name="Data" protect="rw" count="4">
        <comment>The BCpu cache is accessible only when it is disabled or the cpu is stalled.
            <br/>The bits "9:4" of the address select the line.
            <br/>If the Tag at the corresponding line is valid, the bits "24:10" of the tag are the corresponding address bits.
            <br/>The bits "3:0" of the address select the Data in the line.
        </comment>
            <bits name="data" pos="31:0" access="rw">
            </bits>
        </reg>
    </struct>
</module>
</archive>
<archive relative='bcpu_tag.xml' >

<module name="bcpu_tag" category="Debug">

    <reg name="Line" protect="rw" count="exp2(6)">
        <comment>The BCpu tags are accessible only when the corresponding cache is disabled or the cpu is stalled.
            <br/>The bits "9:4" of the address select the line
        </comment>
        <bits name="Tag" pos="24:10" access="rw">
            <comment>The Tag represents the bits "24:10" of the address present in the corresponding cache Line.
            </comment>
            <options><default/><shift/><mask/></options>
        </bits>
        <bits name="Valid" pos="29" access="rw">
            <comment>When 1 the Tag is valid
            </comment>
            <options><default/><shift/><mask/></options>
        </bits>
    </reg>
</module>
</archive>
<archive relative='cipher.xml' >

<module name="cipher" category="Baseband">
  <reg protect="rw" name="ctrl">
    <bits access="w" name="Enable" pos="0" rst="no">
        <comment>
            Writing a '1' in this register triggers an A5 process. Ignored if the module is
            already processing. Auto-reset bit
        </comment>
    </bits>
    <bits access="rw" name="Algorithm" pos="4" rst="1">
        <comment>Selects the appropriate algorithm
        </comment>
        <options>
            <option name="A5_1" value="0"/>
            <option name="A5_2" value="1"/>
        </options>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Running" pos="0" rst="0">
      <comment>1 when running, 0 in other case. </comment>
    </bits>
    <bits access="r" name="Data_Blk_Rdy" pos="4" rst="0">
        <comment>1 when data block ready (Ciphering processed), reseted when the data register is read.
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="Kc low">
    <bits access="rw" name="Kc_Lsb" pos="31:0" rst="0xFFFFFFFF" display="hex">
      <comment>Cipher key Kc, LSB bit [31:0].</comment>
    </bits>
  </reg>
  
  <reg protect="rw" name="Kc high">
    <bits access="rw" name="Kc_Msb" pos="31:0" rst="0xFFFFFFFF" display="hex">
      <comment>Cipher key Kc, MSB bit [31:0].</comment>
    </bits>
  </reg>
  
  <reg protect="rw" name="Count">
    <bits access="rw" name="Count" pos="21:0" rst="0x3FFFFFF" display="hex">
      <comment>Count register, this field represent the TDMA frame number.</comment>
    </bits>
  </reg>

  <reg protect="r" name="Data0_block2">
    <bits access="r" name="Data_blk2" pos="31:0" rst="no">
      <comment>Data block2 bit[31:0]</comment>
    </bits>
  </reg>

  <reg protect="r" name="Data1_block2">
      <bits access="r" name="Data_blk2" pos="31:0" rst="no">
      <comment>Data block2 bit[63:32]</comment>
    </bits>
  </reg>

  <reg protect="r" name="Data2_block2">
    <bits access="r" name="Data_blk2" pos="31:0" rst="no">
      <comment>Data block2 bit[95:64]</comment>
    </bits>
  </reg>

  <reg protect="r" name="Data3_block2">
    <bits access="r" name="Data_blk2" pos="17:0" rst="no">
      <comment>Data block2 bit[113:96]</comment>
    </bits>
  </reg>

 <struct count="29" name="Data_block1">
    <reg protect="r" name="Data block1">
      <bits access="r" name="Bit0" pos="7" rst="no">
        <comment> </comment>
      </bits>
      <bits access="r" name="Bit1" pos="15" rst="no">
        <comment> </comment>
      </bits>
      <bits access="r" name="Bit2" pos="23" rst="no">
        <comment> </comment>
      </bits>
      <bits access="r" name="Bit3" pos="31" rst="no">
        <comment> </comment>
      </bits>
    </reg>
  </struct>

</module>
</archive>


<archive relative='excor.xml' >


<include file="globals.xml"/>

<module name="excor" category="Baseband">

 <var name="EXCOR_IDLE" value="0" />
 <var name="EXCOR_BMMLZF" value="1" />
 <var name="EXCOR_COMPMATRIMUL" value="2" />
 <var name="EXCOR_COMPCONV" value="3" />
 <var name="EXCOR_COMPPOW" value="4" />
 <var name="EXCOR_DEROTATE" value="5" />
 <var name="EXCOR_DCCOMP" value="6" />
 <var name="EXCOR_SRECPSK8" value="7" />
 <var name="EXCOR_FCCH" value="8" />
 <var name="EXCOR_IR_COMB" value="9" />
 <var name="EXCOR_IQ_SHIFT" value="10" />
 <var name="EXCOR_STATUS_MASK" value="1" />
 
  <reg name="ctrl" protect="rw">
    <bits access="rw" name="cmd" pos="7:0" rst="0x0">
      <comment>Control setting. comand type. </comment>
    </bits>

    <bits access="rw" name="nb_iloop" pos="15:8" rst="0x0">
      <comment>Control setting. Number of internal loop iteration.
      </comment>
    </bits>

    <bits access="rw" name="nb_oloop" pos="25:16" rst="0x0">
      <comment>Control setting. Number of nb_symbol.
      </comment>
    </bits>

    <bits access="rw" name="shift_bit" pos="30:26" rst="0x0">
      <comment>Control setting. Number of shift bits.
      </comment>
    </bits>
  </reg>


 <reg name="addr0" protect="rw">
    <bits access="rw" name="addr0" pos="31:0" rst="0x0">
        <comment>address register 0. </comment>
    </bits>
  </reg>
  
  <reg name="addr1" protect="rw">
    <bits access="rw" name="addr1" pos="31:0" rst="0x0">
        <comment>address register 1. </comment>
    </bits>
  </reg>
  
  <reg name="addr2" protect="rw">
    <bits access="rw" name="addr2" pos="31:0" rst="0x0">
        <comment>address register 2. </comment>
    </bits>
  </reg>
  

<reg name="addr3" protect="rw">
    <bits access="rw" name="addr3" pos="31:0" rst="0x0">
        <comment>address register 3. </comment>
    </bits>
  </reg>
  

<reg name="addr4" protect="rw">
    <bits access="rw" name="addr4" pos="31:0" rst="0x0">
        <comment>address register 4. </comment>
    </bits>
  </reg>
  
  

<reg name="addr5" protect="rw">
    <bits access="rw" name="addr5" pos="31:0" rst="0x0">
        <comment>address register 5. </comment>
    </bits>
  </reg>
  
  

 <reg name="data0" protect="rw">
    <bits access="rw" name="data0" pos="31:0" rst="0x0">
        <comment>data register 0. </comment>
    </bits>
  </reg>
  
  

 <reg name="data1" protect="rw">
    <bits access="rw" name="data1" pos="31:0" rst="0x0">
        <comment>data register 1. </comment>
    </bits>
  </reg>
  

 <reg name="data2" protect="rw">
    <bits access="rw" name="data2" pos="31:0" rst="0x0">
        <comment>data register 2. </comment>
    </bits>
  </reg>
  
    

 <reg name="data3" protect="rw">
    <bits access="rw" name="data3" pos="31:0" rst="0x0">
        <comment>data register 3. </comment>
    </bits>
  </reg>
  
  

 <reg name="data4" protect="rw">
    <bits access="rw" name="ircom_psidx0" pos="3:0" rst="0x0">
      <comment>for ircombine idx0 </comment>
    </bits>
    <bits access="rw" name="ircom_psidx1" pos="7:4" rst="0x0">
      <comment>for ircombine idx1 </comment>
    </bits>
    <bits access="rw" name="ircom_psidx2" pos="18:8" rst="0x0">
      <comment>for ircombine idx2 </comment>
    </bits>
  </reg>
    
  

 <reg name="data5" protect="rw">
    <bits access="rw" name="data5" pos="31:0" rst="0x0">
        <comment>data register 5. </comment>
    </bits>
  </reg>
    
  
  
  <reg name="status" protect="rw">
    <bits access="rw" name="status" pos="7:0" rst="0x0">
        <comment>Status is set to 1 when an operation is finished. </comment>
    </bits>
  </reg>
  
</module>

</archive>


<archive relative='evitac.xml' >


<include file="globals.xml"/>

<module name="evitac" category="Baseband">

  <reg name="ctrl" protect="rw">
    <bits access="rw" name="psampl_inc" pos="7:0" rst="0x0">
      <comment>Control setting. psample increment. </comment>
    </bits>

    <bits access="rw" name="nb_symbol" pos="15:8" rst="0x0">
      <comment>Control setting. Number of symbols.
      </comment>
    </bits>

    <bits access="rw" name="nodemetric_his" pos="23:16" rst="0x0">
      <comment>Control setting. node metric history.
      </comment>
    </bits>

    <bits access="rw" name="cmd" pos="31:24" rst="0x0">
      <comment>Control setting. Command.
      </comment>
    </bits>
  </reg>

  <reg name="pbmml_addr" protect="rw">
    <bits access="rw" name="pbmml_addr" pos="31:0" rst="0x0">
        <comment>pbmml address.</comment>
    </bits>
  </reg>
  
  <reg name="pzfm_addr" protect="rw">
    <bits access="rw" name="pzfm_addr" pos="31:0" rst="0x0">
        <comment>pzfm address.</comment>
    </bits>
  </reg>
  
  <reg name="psmpl_addr" protect="rw">
    <bits access="rw" name="psmpl_addr" pos="31:0" rst="0x0">
        <comment>psample address.</comment>
    </bits>
  </reg>
  
  <reg name="output_bits_addr" protect="rw">
    <bits access="rw" name="output_bits_addr" pos="31:0" rst="0x0">
        <comment>softbits output address.</comment>
    </bits>
  </reg>
  
  <reg name="shift_status" protect="rw">
  	<bits access="rw" name="status" pos="7:0" rst="0x0">
      <comment>Status is set to 1 when an operation is finished,It must be reset before lauching a new operation</comment>
    </bits>
    
    <bits access="rw" name="svshift" pos="15:8" rst="0x0">
      <comment>sv shift bits. </comment>
    </bits>
    
    <bits access="rw" name="bmshift" pos="23:16" rst="0x0">
        <comment>bm shift bits.</comment>
    </bits>
  </reg>
  
  <reg name="zfhist_history" protect="rw">
    <bits access="rw" name="zfhist_history" pos="31:0" rst="0x0">
        <comment>zfhist history.</comment>
    </bits>
  </reg>
  
  
  <var name="EVITAC_START" value="1" />
</module>

</archive>


<archive relative='cordic.xml' >


<module name="cordic" category="Baseband">

  <reg name="yin" protect="rw">
    <bits access="rw" name="y_addr" pos="31:0" rst="0x0">
      <comment>Control setting. y, i.e. numerator of atan computation. </comment>
    </bits>
  </reg>

  <reg name="xin" protect="rw">
    <bits access="rw" name="x_addr" pos="31:0" rst="0x0">
      <comment>Control setting. x, i.e. denominator of atan computation. </comment>
    </bits>
  </reg>

  <reg name="cmd" protect="rw">
    <bits access="rw" name="cmd" pos="0" rst="0x0">
      <comment>The start signal. Use the posedge of this signal. </comment>
      <options>
          <option name="RST" value="0"></option>
          <option name="START" value="1"></option>
      </options>
    </bits>
  </reg>

  <reg name="status" protect="r">
    <bits access="r" name="op" pos="31:0" rst="0x0">
      <comment>Status is set to 1 when an operation is finished. </comment>
      <options>
          <option name="Busy" value="0x00000000"></option>
          <option name="Free" value="0xFFFFFFFF"></option>
      </options>
    </bits>
  </reg>

  <reg name="dout" protect="r">
    <bits access="r" name="result_angle" pos="15:0" rst="0x0">
      <comment>angle. The actual value is angle*pi/4</comment>
      <options>
          <mask/>
      </options>
    </bits>
    <bits access="r" name="result_amplitude" pos="31:16" rst="0x0">
      <comment>amplitude.</comment>
      <options>
          <mask/>
      </options>
    </bits>
  </reg>

  <reg name="amp" protect="r">
    <bits access="r" name="result_amp" pos="15:0" rst="0x0">
      <comment>amplitude only.</comment>
      <options>
          <mask/>
      </options>
    </bits>
  </reg>

</module>

</archive>

<archive relative='debug_host.xml' >



<module name="debug_host" category="Debug">
  <reg protect="--" name="cmd">
    <bits access="r" name="Addr" pos="28:0" rst="-">
      <comment>Address of data to be read or written. </comment>
    </bits>

    <bits access="r" name="Size" pos="30:29" rst="-">
      <comment>These two bits indicates element data size. <br />
            when "00" = "byte". <br />
            when "01" = "half word". <br />
            when "10" = "word". 
        </comment>
    </bits>

    <bits access="r" name="Write_H" pos="31" rst="-">
      <comment>This bit indicates command is read or write. <br />
        when "0" = "Read". <br />
        when "1" = "Write".  
      </comment>
    </bits>

  </reg>

  <reg protect="--" name="data">
    <bits access="rw" name="data" pos="31:0" rst="-">
      <comment>Those bits are data to be read or written by IFC. </comment>
    </bits>
    
  </reg>

  <reg protect="w" name="event">
    <bits access="rw" name="event0_sema" pos="0" rst="0">
      <comment>When read, this bit is used for event semaphore. <br />
            '0' = no new event should be programed. <br />
            '1' = no pending event, new event is authorised. <br />
            If host is not enabled, this bit is always '1'. However in this case, 
            any event written will be ignored. <br />
            When Write, this bit is the least significant bit for a 32-bit event.
      </comment>
    </bits>

    <bits access="w" name="event31_1" pos="31:1" rst="-">
      <comment> These bits combined with bit0 consists a 32-bit event number. If a
            new event is written before the previous event has been sent, it will 
            be ignored. 
      </comment>
    </bits>
  </reg>

  <reg protect="rw" name="mode">
    <bits access="rw" name="force_on" pos="0" rst="1">
      <comment>When '1', force the debug host on, use clock UART if clock host is not
            detected. </comment>
    </bits>

    <bits access="r" name="Clk_Host_On" pos="1" rst="0">
      <comment>This bit indicates if clock host is detected to be on or not. <br />
            '0' = no clock host. <br />
            '1' = clock host detected. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="h2p_status">
    <bits access="r" name="h2p_status" pos="7:0" rst="0">
      <comment>Status which can be written through debug uart interface into a debug host
            internal register and read by APB. </comment>
      <options>
        <mask/>
        <shift/>
      </options>
    </bits>
    <bits access="w" name="h2p_status_rst" pos="16" rst="0">
      <comment>write in this bit will reset h2p status register. </comment>
    </bits>
  </reg>
  
  <reg protect="rw" name="p2h_status">
    <bits access="rw" name="p2h_status" pos="7:0" rst="0">
      <comment>Status which can be written by APB and read through debug uart interface 
            as a debug host internal register.
      </comment>
    </bits>
  </reg>
  
  <reg protect="wr" name="irq">
    <bits access="rw" name="xcpu_irq" pos="0" rst="0">
      <comment>when write '1', clear the xcpu irq level which is programmed in a debug host
          internal register, this bit is automatic cleared. <br /> when read, get the xcpu
          irq status. </comment>
    </bits>
    
    <bits access="rw" name="bcpu_irq" pos="1" rst="0">
      <comment>when write '1', clear the bcpu irq level which is programmed in a debug host
            internal register, this bit is automatic cleared.<br /> when read, get the bcpu
            irq status.</comment>
    </bits>
    
  </reg>
</module>



</archive>

<archive relative='debug_host_internals.xml' >


<include file="globals.xml"/>

	<module name="debug_host_internal_registers" category="Debug">
		<ireg name="CTRL_SET" protect="rw">
			<comment>General control signals set.</comment>
			<bits name="Debug_Reset" pos="0" rst="0" access="rs">
				<comment>Debug host generated reset. Signal to system control. Active high.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="XCPU_Force_Reset" pos="1" rst="0" access="rs">
				<comment>Force XCPU Reset signal. Active high. Hold XCPU in reset state until this bit is cleared.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_Wakeup" pos="2" rst="0" access="rs">
				<comment>Force wakeup. Active high.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_BP_XCPU" pos="3" rst="0" access="rs">
				<comment>Force XCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by XCPU.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="Force_BP_BCPU" pos="4" rst="0" access="rs">
				<comment>Force BCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by BCPU.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="IT_XCPU" pos="5" rst="0" access="rs">
				<comment>When write '1, generate a level IRQ to XCPU. Write '0 is ignored. This IRQ can be cleared by written APB register. When Read, Get the IRQ status.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="IT_BCPU" pos="6" rst="0" access="rs">
				<comment>When write '1', generate a level IRQ to BCPU. Write '0' is ignored. This IRQ can be cleared by written APB register. When Read, Get the IRQ status.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="Debug_Port_Lock" pos="7" rst="0" access="rs">
				<comment>Lock Debug port set.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
		</ireg>
		
		<ireg name="CTRL_CLR" protect="rw">
			<comment>General control signals clear.</comment>		
			<bits name="XCPU_Force_Reset" pos="1" rst="0" access="rc">
				<comment>Force XCPU Reset signal. Active high. Hold XCPU in reset state until this bit is cleared.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_Wakeup" pos="2" rst="0" access="rc">
				<comment>Force wakeup. Active high.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_BP_XCPU" pos="3" rst="0" access="rc">
				<comment>Force XCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by XCPU.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>	
			<bits name="Force_BP_BCPU" pos="4" rst="0" access="rc">
				<comment>Force BCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by BCPU.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="Debug_Port_Lock" pos="7" rst="0" access="rc">
				<comment>Lock Debug port clear.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>            
		</ireg>

		<ireg name="CLKDIV" protect="rw">
			<comment>Configure Debug UART Clock divider.</comment>
			<bits name="CFG_CLK" pos="5:0" rst="2" access="rw">
				<comment>Debug host clock divider. The serial clock is generated by dividing  14,7456MHz Host Clock by (CFG_CLK+2). So By default, the serial clock is 14,7456MHz / (2+2) = 3,6864 MHz which corresponds to the 921,6K Baud-rate.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
        </ireg>

		<ireg name="CFG" protect="rw">
			<comment>Configure Debug UART.</comment>
			<bits name="Disable_Uart_H" pos="0" rst="0" access="rw">
                <comment>When '1', Disable Normal Uart functional group.
                    <br/>This bit is set to '1' when break.
                    <br/>Reseted by signal rst_host_reg.
                </comment>
			</bits>
			<bits name="Disable_IFC_H" pos="1" rst="0" access="rw">
                <comment>When '1', Ignore IFC write and read access so only debug host internal is accessible.
                    <br/>This bit is set to '1' when break.
                    <br/>Reseted by signal rst_host_reg.
                </comment>
			</bits>
			<bits name="Debug_Host_Sel" pos="2" rst="0" access="rw">
                <comment>The usage of this bit is deternimed by the specific chip.
                    <br/>Can be used as Debug_Port_Lock register to protect some register change by the regular software while debug hosr is used to set thoses registers to specific values.
                    <br/>Reseted by signal rst_host_reg.
                </comment>
			</bits>
			<bits name="Force_Prio_H" pos="7" rst="1" access="rw">
				<comment>When '1', force the Debug Uart to have priority on TX.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>	
        </ireg>
        

		<ireg name="CRC" protect="rw">
			<comment>Status of CRC.</comment>
			<bits name="CRC" pos="0" rst="0" access="rc">
				<comment>This bit represents that an CRC error has occured in commands received by Debug Host. Once set to '1', it will keep the value until this register is clearred by write '1'.<br/>'0' = no CRC error.<br/>'1' = CRC error.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="FC_Fifo_Ovf" pos="1" rst="0" access="r">
				<comment>This bit represents if the 16-byte Flow Control FIFO has an overflow error. This status will be kept until a RX break is received.<br/>'0' = no Flow Control Overflow Error.<br/>'1' = Flow Control Overflow Error.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>
			
		<ireg name="H2P_STATUS" protect="rw">
			<comment>Host write, APB readable register.</comment>
			<bits name="STATUS" pos="7:0" rst="0" access="rw">
				<comment>These bits can be read by APB and write by host. Corresponds to APB register STATUS. They can also be reseted to zeros by APB command. (see details in debug host APB register mapping) <br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>

		<ireg name="P2H_STATUS" protect="rw">
			<comment>APB write, Host readable register.</comment>
			<bits name="STATUS" pos="7:0" rst="0" access="rw">
				<comment>These bits can be written by APB and read by host. Corresponds to APB register STATUS.<br/>Write to Bit 0 can reset the P2H status.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>

		<ireg name="AHB_SYS_HMBURSREQ" protect="r">
			<comment>Debug information of system side AHB bus status.</comment>
			<bits name="SYS_IFC_HMBURSREQ" pos="0" rst="-" access="r">
				<comment>The bit represent Sys Ifc HMBURSREQ.</comment>
			</bits>
			<bits name="SYS_DMA_HMBURSREQ" pos="1" rst="-" access="r">
				<comment>The bit represent Dma HMBURSREQ.</comment>
			</bits>
			<bits name="SYS_AHB2AHB_HMBURSREQ" pos="2" rst="-" access="r">
				<comment>The bit represent Sys Ahb2ahb HMBURSREQ.</comment>
			</bits>
			<bits name="XCPU_HMBURSREQ" pos="3" rst="-" access="r">
				<comment>The bit represent Xcpu HMBURSREQ.</comment>
            </bits>
			<bits name="AXI2AHB_HMBURSREQ" pos="4" rst="-" access="r">
				<comment>The bit represent USBC HMBURSREQ.</comment>
            </bits>
		</ireg>
            
		<ireg name="AHB_SYS_HMGRANT" protect="r">
			<bits name="SYS_IFC_HMGRANT" pos="0" rst="-" access="r">
				<comment>The bit represent Sys Ifc HMGRANT.</comment>
			</bits>
			<bits name="SYS_DMA_HMGRANT" pos="1" rst="-" access="r">
				<comment>The bit represent Dma HMGRANT.</comment>
			</bits>
			<bits name="SYS_AHB2AHB_HMGRANT" pos="2" rst="-" access="r">
				<comment>The bit represent Sys Ahb2ahb HMGRANT.</comment>
			</bits>
			<bits name="XCPU_HMGRANT" pos="3" rst="-" access="r">
				<comment>The bit represent Xcpu HMGRANT.</comment>
			</bits>
			<bits name="AXI2AHB_HMGRANT" pos="4" rst="-" access="r">
				<comment>The bit represent USBC HMGRANT.</comment>
            </bits>
		</ireg>
	
		<ireg name="AHB_SYS_HSEL" protect="r">
			<comment>Debug information of AHB bus status HSEL.</comment>
			<bits name="SYS_MEM_EXT_HSEL" pos="0" rst="-" access="r">
				<comment>The bit represent Sys MEM_EXT HSEL.</comment>
			</bits>
			<bits name="SYS_MEM_INT_HSEL" pos="1" rst="-" access="r">
				<comment>The bit represent Sys MEM_INT HSEL.</comment>
			</bits>
			<bits name="SYS_IFC_HSEL" pos="2" rst="-" access="r">
				<comment>The bit represent Sys Ifc HSEL.</comment>
			</bits>
			<bits name="SYS_AHB2AHB_HSEL" pos="3" rst="-" access="r">
				<comment>The bit represent Sys Ahb2ahb HSEL.</comment>
			</bits>
			<bits name="SYS_DP_AP_HSEL" pos="4" rst="-" access="r">
				<comment>The bit represent USBC HSEL.</comment>
            </bits>
			<bits name="SYS_AHB2AXI_HSEL" pos="5" rst="-" access="r">
				<comment>The bit represent GOUDA HSEL.</comment>
            </bits>               
			<bits name="SYS_EXT_AHB_HSEL" pos="6" rst="-" access="r">
				<comment>The bit represent GOUDA HSEL.</comment>
            </bits>               
			<bits name="SYS_XCPU_RAM_HSEL" pos="7" rst="-" access="r">
				<comment>The bit represent XCPU RAM HSEL.</comment>
            </bits>               
		</ireg>

		<ireg name="AHB_SYS_HSREADY" protect="r">
			<bits name="SYS_IFC_HSREADY" pos="0" rst="-" access="r">
				<comment>The bit represent Sys Ifc HSREADY.</comment>
			</bits>
			<bits name="SYS_MEM_HSREADY" pos="1" rst="-" access="r">
				<comment>The bit represent Sys EBC HSREADY.</comment>
			</bits>
			<bits name="SYS_AHB2AHB_HSREADY" pos="2" rst="-" access="r">
				<comment>The bit represent Sys Ahb2ahb HSREADY.</comment>
            </bits>
			<bits name="SYS_DP_AP_HSREADY" pos="3" rst="-" access="r">
				<comment>The bit represent USBC HSREADY.</comment>
            </bits>
			<bits name="SYS_AHB2AXI_HSREADY" pos="4" rst="-" access="r">
				<comment>The bit represent GOUDA HSREADY.</comment>
            </bits>
			<bits name="SYS_EXT_AHB_HSREADY" pos="5" rst="-" access="r">
				<comment>The bit represent GOUDA HSREADY.</comment>
            </bits>
			<bits name="SYS_XCPU_RAM_HSREADY" pos="6" rst="-" access="r">
				<comment>The bit represent XCPU RAM HSREADY.</comment>
            </bits>              
			<bits name="SYS_HREADY" pos="7" rst="-" access="r">
				<comment>The bit represent Sys HSREADY which is sent to all sys AHB slaves.</comment>
			</bits>
		</ireg>

		<ireg name="AHB_BB_MASTER" protect="r">
			<comment>Debug information of baseband side AHB bus status.</comment>
			<bits name="BB_IFC_HMBURSREQ" pos="0" rst="-" access="r">
				<comment>The bit represent BB Ifc HMBURSREQ.</comment>
			</bits>
			<bits name="BB_NONE_HMBURSREQ" pos="1" rst="-" access="r">
				<comment>The bit represent NONE HMBURSREQ.</comment>
			</bits>
			<bits name="BB_AHB2AHB_HMBURSREQ" pos="2" rst="-" access="r">
				<comment>The bit represent BB Ahb2ahb HMBURSREQ.</comment>
			</bits>
			<bits name="BCPU_HMBRSREQ" pos="3" rst="-" access="r">
				<comment>The bit represent Bcpu HMBURSREQ.</comment>
			</bits>
			<bits name="BB_IFC_HMGRANT" pos="4" rst="-" access="r">
				<comment>The bit represent BB Ifc HMGRANT.</comment>
			</bits>
			<bits name="BB_NONE_HMGRANT" pos="5" rst="-" access="r">
				<comment>The bit represent NONE HMGRANT.</comment>
			</bits>
			<bits name="BB_AHB2AHB_HMGRANT" pos="6" rst="-" access="r">
				<comment>The bit represent BB Ahb2ahb HMGRANT.</comment>
			</bits>
			<bits name="BCPU_HMGRANT" pos="7" rst="-" access="r">
				<comment>The bit represent Bcpu HMGRANT.</comment>
			</bits>
		</ireg>

		<ireg name="AHB_BB_HSREADY" protect="r">
			<comment>Debug information of AHB bus status HSEL.</comment>
			<bits name="BB_MEM_HSREADY" pos="0" rst="-" access="r">
				<comment>The bit represent BB MEM HSREADY.</comment>
            </bits>
			<bits name="BB_NONE_HSREADY" pos="1" rst="-" access="r">
				<comment>The bit represent BB NONE HSREADY.</comment>
			</bits>
			<bits name="BB_SRAM_HSREADY" pos="2" rst="-" access="r">
				<comment>The bit represent BB Sram HSREADY.</comment>
			</bits>
			<bits name="BB_IFC_HSREADY" pos="3" rst="-" access="r">
				<comment>The bit represent BB Ifc HSREADY.</comment>
			</bits>
			<bits name="BB_AHB2AHB_HSREADY" pos="4" rst="-" access="r">
				<comment>The bit represent BB Ahb2ahb HSREADY.</comment>
			</bits>
			<bits name="BB_HREADY" pos="7" rst="-" access="r">
				<comment>The bit represent BB HREADY which is sent to all BB AHB slaves.</comment>
			</bits>
		</ireg>

		<ireg name="AHB_BB_HSEL" protect="r">
			<comment>Debug information of AHB bus status HSEL.</comment>
			<bits name="BB_MEM_EXT_HSEL" pos="0" rst="-" access="r">
				<comment>The bit represent BB MEM_EXT HSEL.</comment>
			</bits>
			<bits name="BB_MEM_INT_HSEL" pos="1" rst="-" access="r">
				<comment>The bit represent BB MEM_INT HSEL.</comment>
			</bits>
			<bits name="BB_NONE_HSEL" pos="2" rst="-" access="r">
				<comment>The bit represent BB NONE HSEL.</comment>
			</bits>
			<bits name="BB_SRAM_HSEL" pos="3" rst="-" access="r">
				<comment>The bit represent BB Sram HSEL.</comment>
			</bits>
			<bits name="BB_IFC_HSEL" pos="4" rst="-" access="r">
				<comment>The bit represent BB Ifc HSEL.</comment>
			</bits>
			<bits name="BB_AHB2AHB_HSEL" pos="5" rst="-" access="r">
				<comment>The bit represent BB Ahb2ahb HSEL.</comment>
			</bits>
		</ireg>

		<ireg name="AHB_SYS_MASK_SPLIT" protect="r">
            <comment>Represents the split status register of the SYS_AHBC.</comment>
            <bits name="Sys_Mask_Split" pos="SYS_NB_MASTERS:1" access="r" rst="-" cut="1" cutenum="Sys_Master_Id" cutprefix="Mask_Split" cutstart="1">
            </bits>
		</ireg>
		<ireg name="AHB_BB_MASK_SPLIT" protect="r">
            <comment>Represents the split status register of the BB_AHBC.</comment>
            <bits name="BB_Mask_Split" pos="BB_NB_MASTERS:1" access="r" rst="-" cut="1" cutenum="BB_Master_Id" cutprefix="Mask_Split" cutstart="1">
            </bits>
		</ireg>
        
	</module>

</archive>

<archive relative='debug_uart.xml' >

<module name="debug_uart" category="System">
  <var  name="DEBUG_UART_RX_FIFO_SIZE"    value="16"  />
  <var  name="DEBUG_UART_TX_FIFO_SIZE"    value="16"  />
  <var  name="DEBUG_UART_NB_RX_FIFO_BITS" value="4"   />
  <var  name="DEBUG_UART_NB_TX_FIFO_BITS" value="4"   />
  <var  name="ESC_DAT"                    value="92"  />
  
  <reg protect="rw" name="ctrl">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Allows to turn off the UART:<br />0 = Disable<br />1 = Enable
      </comment>
    </bits>

    <bits access="rw" name="Data Bits" pos="1" rst="0">
      <options>
        <option name="7_BITS" value="0" />

        <option name="8_BITS" value="1" />

        <default />
      </options>

      <comment>Number of data bits per character (least significant bit
          first):<br />0 = 7 bits<br />1 = 8 bits <br /> This bit will be masked to
          '1' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Tx Stop Bits" pos="2" rst="0">
      <options>
        <option name="1_BIT" value="0" />

        <option name="2_BITS" value="1" />

        <default />
      </options>

      <comment>Stop bits controls the number of stop bits transmitted. Can
      receive with one stop bit (more inaccuracy can be compensated with two
      stop bits when divisor mode is set to 0).<br />0 = one stop bit is
      transmitted in the serial data.<br />1 = two stop bits are generated and
      transmitted in the serial data out. <br /> This bit will be masked to
      '0' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Parity Enable" pos="3" rst="0">
      <options>
        <option name="NO" value="0" />

        <option name="YES" value="1" />

        <default />
      </options>

      <comment> Parity is enabled when this bit is set. <br /> This bit will be masked to
      '0' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Parity Select" pos="5:4" rst="0">
      <options>
        <option name="ODD" value="0" />

        <option name="EVEN" value="1" />

        <option name="SPACE" value="2" />

        <option name="MARK" value="3" />

        <default />
      </options>

      <comment> Controls the parity format when parity is enabled:<br />00 =
      an odd number of received 1 bits is checked, or transmitted (the parity
      bit is included).<br />01 = an even number of received 1 bits is checked
      or transmitted (the parity bit is included).<br />10 = a space is
      generated and received as parity bit.<br />11 = a mark is generated and
      received as parity bit. <br /> These bit will be ignored if debug host is
      enabled. </comment>
    </bits>

    <bits access="rw" name="Tx Break Control" pos="6" rst="0">
      <comment> Sends a break signal by holding the Uart_Tx line low until
          this bit is cleared.<br /> This bit will be masked to '0' if debug host
          is enabled. </comment>
      <options>
        <option name="OFF" value="0" />
        <option name="ON"  value="1" />
        <default />
      </options>
    </bits>

    <bits access="rw" name="Rx Fifo Reset" pos="7" rst="0">
      <comment> Writing a 1 to this bit resets and flushes the Receive Fifo.
      This bit does not need to be cleared. </comment>
    </bits>

    <bits access="rw" name="Tx Fifo Reset" pos="8" rst="0">
      <comment> Writing a 1 to this bit resets and flushes the Transmit Fifo.
      This bit does not need to be cleared. </comment>
    </bits>

    <bits access="rw" name="DMA Mode" pos="9" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Enables the DMA signaling for the Uart_Dma_Tx_Req_H and
      Uart_Dma_Rx_Req_H to the IFC. </comment>
    </bits>

    <bits access="rw" name="SWRX flow ctrl" pos="13:12" rst="1">
        <comment> When this field is "00" and SWTX_flow_Ctrl is also "00", hardwre
            flow ctrl is used. Otherwise, software flow control is used: <br />
            00 = no transmit flow control. <br />
            01 = transmit XON1/XOFF1 as flow control bytes<br />
            10 = transmit XON2/XOFF2 as flow control bytes<br />
            11 = transmit XON1 and XON2/XOFF1 and XOFF2 as flow control bytes<br />
        </comment>
        <options><default/><mask/><shift/></options>
    </bits>

    <bits access="rw" name="SWTX flow ctrl" pos="15:14" rst="1">
        <comment> When this field is "00" and SWRX_flow_Ctrl is also "00", hardwre
            flow ctrl is used. Otherwise, software flow control is used: <br />
            00 = no receive flow control<br />
            01 = receive XON1/XOFF1 as flow control bytes<br />
            10 = receive XON2/XOFF2 as flow control bytes<br />
            11 = receive XON1 and XON2/XOFF1 and XOFF2 as flow control bytes<br />
            <br /> Note: If single XON/XOFF character is used for flow contol, the received 
            XON/XOFF character will not be put into Rx FIFO. This is also the case if XON is
            received when XOFF is expected. <br />
            If double XON/XOFF characters are expected, the XON1/XOFF1 must followed sequently 
            by XON2/XOFF2 to be considered as patterns, which will not be put into Rx FIFO. 
            Otherwise they will be considered as data. This is also the case if XOFF1 is followed
            by character other than XOFF2. <br />
        </comment>
        <options><default/><mask/><shift/></options>
    </bits>

    <bits access="rw" name="BackSlash En" pos="16" rst="1">
        <comment> When soft flow control characters or backslash are encountered in the data file, 
            they will be inverted and a backslash will be added before them. for example, if tx data
            is XON(0x11) with BackSlash_En = '1', then uart will send 5Ch(Backslash) + EEh (~XON).
        </comment>
    </bits>

    <bits access="s" name="Send XON" pos="17" rst="1">
        <comment>Write in this bit will send an XON. This command should be used only for debug. It can be used in case when UART has not received any byte for long time after previous XON is sent. This bit does not need to be cleared. <br />
        </comment>
    </bits>    
    
    <bits access="rw" name="Tx Finish n Wait" pos="19" rst="0">
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>

    <bits access="rw" name="Divisor Mode" pos="20" rst="0">
      <comment>Selects the divisor value used to generate the baud rate
      frequency (BCLK) from the SCLK (see UART Operation for details). If IrDA
      is enable, this bit is ignored and the divisor used will be 16.<br />0 =
      (BCLK = SCLK / 4)<br />1 = (BCLK = SCLK / 16) <br /> This bit will be
      masked to '0' if debug host is enabled.</comment>
    </bits>

    <bits access="rw" name="IrDA Enable" pos="21" rst="0">
      <comment>When set, the UART is in IrDA mode and the baud rate divisor
      used is 16 (see UART Operation for details). <br /> This bit will be
      masked to '0' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Rx RTS" pos="22" rst="0">
      <comment>Controls the Uart_RTS output (not directly in auto flow control
      mode).<br />0 = the Uart_RTS will be inactive high<br />1 = the Uart_RTS
      will be active low <br /> This bit will be masked to '1' if debug host is
      enabled. </comment>
      <options>
        <option name="INACTIVE" value="0" />
        <option name="ACTIVE"  value="1" />
        <default />
      </options>
    </bits>

    <bits access="rw" name="Auto Flow Control" pos="23" rst="0">
      <options>       
        <option name="ENABLE" value="1" />
        
        <option name="DISABLE" value="0" />
        
        <default />
      </options>
      <comment>Enables the auto flow control. <br/> 
          In case HW flow control (both swTx_Flow_ctrl=0 and swRx_Flow_Ctrl=0),
          If Auto_Flow_Control is enabled, Uart_RTS is controlled by the Rx RTS bit in 
          CMD_Set register and the UART Auto Control Flow System(flow controlled by Rx
          Fifo Level and AFC_Level in Triggers register). 
          Tx data flow is stopped If Uart_CTS become inactive high.<br/>
          If Auto_Flow_Control is disabled, Uart_RTS is controlled only by the Rx RTS
          bit in CMD_Set register. Uart_CTS will not take effect. <br/><br/>

          In case SW flow control(either swTx_Flow_ctrl/=0 or swRx_Flow_Ctrl/=0),
          If Auto_Flow_Control is enabled, XON/XOFF will be controlled by the Rx RTS bit
          in CMD_Set register and the UART Auto Control Flow System(flow controlled by Rx
          Fifo Level and AFC_Level in Triggers register). <br/>
          If Auto_Flow_Control is disabled, XON/XOFF will be controlled only by Rx RTS bit
          in CMD_Set register. Tx data flow will be stoped when XOFF is received either
          this bit is enable or disabled.<br/>
          <br /> This bit will be masked to '1' if debug host is enabled.
      </comment>
    </bits>

    <bits access="rw" name="Loop Back Mode" pos="24" rst="0">
      <comment>When set, data on the Uart_Tx line is held high, while the
      serial output is looped back to the serial input line, internally. In
      this mode all the interrupts are fully functional. This feature is used
      for diagnostic purposes. Also, in loop back mode, the modem control
      input Uart_CTS is disconnected and the modem control output Uart_RTS are
      looped back to the inputs, internally. In IrDA mode, Uart_Tx signal is
      inverted (see IrDA SIR Mode Support). </comment>
    </bits>

    <bits access="rw" name="Rx Lock Err" pos="25" rst="0">
      <comment>Allow to stop the data receiving when an error is detected
      (framing, parity or break). The data in the fifo are kept. <br /> This bit 
      will be masked to '0' if debug host is enabled. </comment>
      <options>
        <option name="DISABLE" value="0" />
        <option name="ENABLE" value="1" />
        <default />
      </options>
    </bits>

    <bits access="rw" name="HST TXD oen" pos="26" rst="0">
      <comment>HST TXD output enable. '0' enable.</comment>
      <options>
        <option name="DISABLE" value="1" />
        <option name="ENABLE" value="0" />
        <default />
      </options>
    </bits>

    <bits access="rw" name="Rx Break Length" pos="31:28" rst="0xF">
      <comment>Length of a break, in number of bits. <br /> This bit will be masked
      to "1011" if debug host is enabled. </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Rx Fifo Level" pos="4:0" rst="0">
        <options>
            <mask/>
            <shift/>
        </options>
    <comment>Those bits indicate the number of data available in the Rx
      Fifo. Those data can be read. </comment>
    </bits>

    <bits access="r" name="Tx Fifo Level" pos="12:8" rst="0">
         <options>
            <mask/>
            <shift/>
        </options>
      <comment>Those bits indicate the number of data available in the Tx
      Fifo. Those data will be sent. </comment>
    </bits>

    <bits access="r" name="Tx Active" pos="13" rst="0">
      <comment>This bit indicates that the UART is sending data. If no data is
      in the fifo, the UART is currently sending the last one through the
      serial interface. </comment>
    </bits>

    <bits access="r" name="Rx Active" pos="14" rst="0">
      <comment>This bit indicates that the UART is receiving a byte.
      </comment>
    </bits>

    <bits access="r" name="Rx Overflow Err" pos="16" rst="0">
      <comment>This bit indicates that the receiver received a new character
      when the fifo was already full. The new character is discarded. This bit
      is cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Tx Overflow Err" pos="17" rst="0">
      <comment>This bit indicates that the user tried to write a character when fifo was
          already full. The written data will not be kept. This bit is cleared when 
          the UART_STATUS register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Parity Err" pos="18" rst="0">
      <comment>This bit is set if the parity is enabled and a parity error
      occurred in the received data. This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Framing Err" pos="19" rst="0">
      <comment>This bit is set whenever there is a framing error occured. A
      framing error occurs when the receiver does not detect a valid STOP bit
      in the received data. This bit is cleared when the UART_STATUS register
      is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Break Int" pos="20" rst="0">
      <comment>This bit is set whenever the serial input is held in a logic 0
      state for longer than the length of x bits, where x is the value
      programmed Rx Break Length. A null word will be written in the Rx Fifo.
      This bit is cleared when the UART_STATUS register is written with any
      value. </comment>
    </bits>

    <bits access="r" name="Tx DCTS" pos="24" rst="0">
      <comment>In case HW flow ctrl(both swRx_Flow_Ctrl=0 and swTx_Flow_Ctrl=0), 
            This bit is set when the Uart_CTS line changed since the last
            time this register has been written. <br/>
            In case SW flow ctrl(either swRx_Flow_Ctrl/=0 or swTx_Flow_Ctrl/=0), 
            This bit is set when received XON/XOFF status changed since the last time
            this register has been writtern. <br/>
            This bit is cleared when the UART_STATUS register is written with any value. 
       </comment>
    </bits>

    <bits access="r" name="Tx CTS" pos="25" rst="0">
        <comment>In case HW flow ctrl(both swRx_Flow_Ctrl=0 and swTx_Flow_Ctrl=0),
            current value of the Uart_CTS line. 
            <br/> '1' = Tx not allowed. 
            <br/> '0' = Tx allowed. 
            <br/>In case SW flow ctrl(either swRx_Flow_Ctrl/=0 or swTx_Flow_Ctrl/=0),
            current state of software flow control.
            <br/> '1' = when XOFF received. 
            <br/> '0' = when XON received. 
        </comment>
    </bits>

    <bits access="r" name="Tx Fifo Rsted L" pos="28" rst="0">
      <comment>This bit is set when Tx Fifo Reset command is received by CTRL
      register and is cleared when Tx fifo reset process has finished.      
      </comment>
    </bits>

    <bits access="r" name="Rx Fifo Rsted L" pos="29" rst="0">
      <comment>This bit is set when Rx Fifo Reset command is received by CTRL
      register and is cleared when Rx fifo reset process has finished.      
      </comment>
    </bits>
    
    <bits access="r" name="Enable n finished" pos="30" rst="0">
      <comment>This bit is set when bit enable is changed from '0' to '1' or 
      from '1' to '0', it is cleared when the enable process has finished.      
      </comment>
    </bits>
    
    <bits access="r" name="Clk Enabled" pos="31" rst="0">
      <comment>This bit is set when Uart Clk has been enabled and received by
      UART after Need Uart Clock becomes active. It serves to avoid enabling
      Rx RTS too early.</comment>
    </bits>
  </reg>

  <reg protect="--" name="rxtx_buffer">
    <bits access="r" name="Rx Data" pos="7:0" rst="no">
      <comment>The UART_RECEIVE_BUFFER register is a read-only register that
      contains the data byte received on the serial input port. This register
      accesses the head of the receive FIFO. If the receive FIFO is full and
      this register is not read before the next data character arrives, then
      the data already in the FIFO will be preserved but any incoming data
      will be lost. An overflow error will also occur. </comment>
    </bits>

    <bits access="w" name="Tx Data" pos="7:0" rst="no">
      <comment>The UART_TRANSMIT_HOLDING register is a write-only register
      that contains data to be transmitted on the serial output port. 16
      characters of data may be written to the UART_TRANSMIT_HOLDING register
      before the FIFO is full. Any attempt to write data when the FIFO is full
      results in the write data being lost. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="irq_mask">
    <bits access="rw" name="Tx Modem Status" pos="0" rst="0">
        <comment>Clear to send signal change or XON/XOFF detected. </comment>
    </bits>

    <bits access="rw" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. </comment>
    </bits>

    <bits access="rw" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>Pulse detected on Uart_Dma_Tx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>Pulse detected on Uart_Dma_Rx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
      <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.</comment>
    </bits>
    
    <bits access="rw" name="XOFF detected" pos="8" rst="0">
      <comment>XOFF detected.</comment>
    </bits>
    
  </reg>

  <reg protect="rw" name="irq_cause">
    <bits access="r" name="Tx Modem Status" pos="0" rst="0">
      <comment>Clear to send signal detected. Reset control: This bit is
      cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). Reset control: Reading the UART_RECEIVE_BUFFER
      until the Fifo drops below the trigger level. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). Reset control: Writing into UART_TRANSMIT_HOLDING
      register above threshold level. </comment>
    </bits>

    <bits access="r" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. Reset control: Reading from the UART_RECEIVE_BUFFER register.
      </comment>
    </bits>

    <bits access="r" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. Reset control: This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Tx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Rx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.</comment>
    </bits>

    <bits access="rw" name="XOFF detected" pos="8" rst="0">
      <comment>XOFF detected.</comment>
    </bits>
    
    <bits access="r" name="Tx Modem Status U" pos="16" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Data Available U" pos="17" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed U" pos="18" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Timeout U" pos="19" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Line Err U" pos="20" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Dma Done U" pos="21" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Done U" pos="22" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Timeout U" pos="23" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="rw" name="XOFF detected U" pos="24" rst="0">
      <comment>XOFF detected.</comment>
    </bits>
    
  </reg>

  <reg protect="rw" name="triggers">
    <bits access="rw" name="Rx Trigger" pos="3:0" rst="0">
      <comment>Defines the threshold level at which the Data Available
      Interrupt will be generated. <br />The Data Available interrupt is
      generated when quantity of data in Rx Fifo &gt; Rx Trigger.</comment>
    </bits>

    <bits access="rw" name="Tx Trigger" pos="7:4" rst="0">
      <comment>Defines the threshold level at which the Data Needed
      Interrupt will be generated.<br />The Data Needed Interrupt is generated
      when quantity of data in Tx Fifo &lt;= Tx Trigger.</comment>
    </bits>

    <bits access="rw" name="AFC Level" pos="11:8" rst="0">
      <comment>Controls the Rx Fifo level at which the Uart_RTS Auto Flow
      Control will be set inactive high (see UART Operation for more details
      on AFC).<br />The Uart_RTS Auto Flow Control will be set inactive high
      when quantity of data in Rx Fifo &gt; AFC Level.</comment>
    </bits>
  </reg>
  <reg protect="rw" name="XChar">
    <bits access="rw" name="XON1" pos="7:0" rst="17">
        <comment>XON1 character value. Reset Value is CTRL-Q 0x11.</comment>
    </bits>
    <bits access="rw" name="XOFF1" pos="15:8" rst="19">
        <comment>XOFF1 character value. Reset Value is CTRL-S 0x13</comment>
    </bits>
    <bits access="rw" name="XON2" pos="23:16" rst="0">
        <comment>XON2 character value. </comment>
    </bits>
    <bits access="rw" name="XOFF2" pos="31:24" rst="0">
        <comment>XOFF2 character value. </comment>
    </bits>
    <comment> These characters must respect following constraints: They must be different if used in software control, if BackSlash_En='1', they cannot be '\' and they cannot be complementary to each other, for example neither XON1 = ~XOFF1 nor XON1 = ~'\' is permitted. </comment>
  </reg>
  
</module>
</archive>

<archive relative='dma.xml' >

<module name="dma" category="System">
  <reg protect="w" name="get_channel">
    <bits access="r" name="Get Channel" pos="0" rst="0">
      <comment>Returns 1 and locks the DMA channel for a transaction if it is
      available. Else returns 0. <br />Clear the transfer done interrupt
      status. </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Enable" pos="0" rst="0">
      <comment>Status of the DMA: 1 if enabled, 0 if disabled. </comment>
    </bits>

    <bits access="r" name="Int Done Cause" pos="1" rst="0">
      <comment>Cause of the interrupt. This bit is set when the transfer is
      done and the interrupt mask bit is set. <br />Write one in the Int Clear
      or write 0 in Enable control bits to clear Int Done Cause bit.
      </comment>
    </bits>

    <bits access="r" name="Int Done Status" pos="2" rst="0">
      <comment>Status of the interrupt. Status of the transfer: 1 if the
      transfer is finished, 0 if it is not finished. <br />Write one in the
      Int Clear or write 0 in Enable control bits to clear Int Done Status
      bit. </comment>
    </bits>

    <bits access="r" name="Channel Lock" pos="4" rst="0">
      <comment>Actual status of channel lock. Channel is unlocked at the end
      of transaction or when the DMA is disabled. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="control">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <comment>Controls the DMA. Write 1 to enable the DMA, write 0 to disable
      it. When 0 is written in this register, the Int Done Status and Cause
      bits are reset. </comment>
    </bits>

    <bits access="rw" name="Int Done Mask" pos="1" rst="0">
      <comment>End of transfer interrupt generation. When 1, the DMA will send
      an interrupt at transaction completion. </comment>
      <options>
        <shift/>
      </options>  
    </bits>

    <bits access="rw" name="Int Done Clear" pos="2" rst="0">
      <comment>Clear the transfer done interruption (this will clear Int Done
      Status and Int Done Cause). <br />This bit is auto-clear. You will
      always read 0 here. </comment>
    </bits>

    <bits access="rw" name="Use Pattern" pos="4" rst="0">
      <comment>If this bit is set, the source address will be ignored and the
      memory will be fill with the value of the pattern register. </comment>
    </bits>

    <bits access="w" name="Stop Transfer" pos="8" rst="0">
      <comment>The DMA stop the current transfer and flush his FIFO (write
      only bit). When the FIFO is empty and last write performed, the DMA is
      disabled and available for a next transfer. The number of bytes copied
      is readable on DMA_XFER_SIZE register.</comment>
    </bits>

    <bits access="rw" name="GEA Enable" pos="12" rst="0">
      <options>
        <option name="DMA" value="0" />

        <option name="GEA" value="1" />

        <default />
      </options>

      <comment>Enable Gea process when 1.</comment>
    </bits>

    <bits access="rw" name="GEA Algorithm" pos="13" rst="1">
      <options>
        <option name="GEA1" value="0" />

        <option name="GEA2" value="1" />

        <default />
      </options>

      <comment>This field sets the type of GEA algorithm to process.</comment>
    </bits>

    <bits access="rw" name="GEA Direction" pos="14" rst="1">
      <options>
        <shift/>
      </options>
      <comment>This field selects the Direction in the GEA algorithm.
      </comment>
    </bits>

    <bits access="rw" name="FCS Enable" pos="16" rst="0">
      <options>
        <option name="NORMAL_DMA" value="0" />

        <option name="FCS_PROCESS" value="1" />

        <default />
      </options>

      <comment>Enable FCS process when 1.</comment>
    </bits>

    <bits access="rw" name="Dst Addr Mgt" pos="21:20" rst="0">
      <options>
        <option name="NORMAL_DMA" value="0" />

        <option name="CONST_ADDR" value="1" />

        <option name="ALTERN_ADDR" value="2" />

        <option name="RESERVED" value="3" />

        <default />
      </options>

      <comment>Destination address management.<br />00 : Normal DMA operation,
      DMA_DST_ADDR register define the destination address.<br /> 01 : DMA
      write address is constant (no incremented) and defined by the
      DMA_DST_ADDR register. All data write are in 16-bit.<br /> 10 : DMA
      write address is alternatively defined by DMA_DST_ADDR and
      DMA_SD_DST_ADDR registers. All data write are in 16-bit. <br />In this
      configuration, DMA write operation is alternatively: <br />DMA_DST_ADDR
      &lt;= DMA_PATTERN register <br />DMA_SD_DST_ADDR &lt;=
      Data[DMA_SRC_ADDR] <br />11 : reserved </comment>
    </bits>
  </reg>

  <reg protect="rw" name="src_addr">
    <bits access="rw" name="Src Address" pos="31:0" rst="0xFFFFFFFF">
      <comment>Source start read byte address. When a transfer is stalled by
      the Stop_Transfer bit, this register give the next current source
      address, which is directly the value to re-program to complete the
      transfer stopped.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="dst_addr">
    <bits access="rw" name="Dst Address" pos="31:0" rst="0xFFFFFFFF">
      <comment>Destination start read byte address. When a transfer is stalled
      by the Stop_Transfer bit, this register give the next current
      destination address, which is directly the value to re-program to
      complete the transfer stopped.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="sd_dst_addr">
    <bits access="rw" name="Sd Dst Address" pos="31:0" rst="0xFFFFFFFF">
      <comment>Second destination address. This register is only used when
      Dst_Address_Mgt=10.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="xfer_size">
    <bits access="rw" name="Transfer Size" pos="17:0" rst="0xFFFFFFFF">
      <comment>Transfer size in bytes. Maximum: 262144 bytes. When a transfer
      is stopped by the Stop_Transfer bit, this register give the number of
      remainder bytes to transfer.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="pattern">
    <bits access="rw" name="Pattern" pos="31:0" rst="0xFFFFFFFF">
      <comment>Value taken to fill the memory when the configuration bit Use
      Pattern is set. When the pattern mode is used the destination address
      must be 32-bit aligned and the transfer size multiple of 4. when
      Dst_Address_Mgt=10 Pattern is the data written at the address given by
      the Dst_Address register.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gea_kc_low">
    <bits access="rw" name="KC_LSB" pos="31:0" rst="0xFFFFFFFF">
      <comment>GEA key Kc, LSB bit [31:0]. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gea_kc_high">
    <bits access="rw" name="KC_MSB" pos="31:0" rst="0xFFFFFFFF">
      <comment>GEA key Kc, MSB bit [31:0]. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gea_messkey">
    <bits access="rw" name="MessKey" pos="31:0" rst="0xFFFFFFFF">
      <comment>MessKey (Input) register. </comment>
    </bits>
  </reg>

  <reg protect="r" name="fcs">
    <bits access="r" name="FCS" pos="23:0" rst="0">
      <comment>Frame Check Sequence.</comment>
    </bits>

    <bits access="r" name="FCS Correct" pos="31" rst="0">
      <comment>The FCS is correct in reception when the final remainder is
      equal to C(x)= x^22 + x^21 + x^19 + x^18 + x^16 + x^15 + x^11 + x^8 +
      x^5 + x^4</comment>
    </bits>

    
  </reg>
</module>
</archive>
<archive relative='mem_bridge.xml' >


<include file="globals.xml"/>
<include file="bb2g_generic_config.xml"/>

    <var    name="EBC_NB_BITS_CS" value="3" />
    <var    name="EBC_NB_CS" value="5" /> 
    <var    name="FIRST_CS_WITH_POLARITY" value="2" />

    <var    name="NB_BITS_EXTADDR" value="EBC_NB_BITS_ADDR+1" /> 

    <var    name="NB_BITS_MAXSPACE" value="22" />
    <var    name="NB_BITS_CS4" value="21" />
    <var    name="EBC_CS0_SIZE" value="exp2(NB_BITS_MAXSPACE)" /> 
    <var    name="EBC_CS1_SIZE" value="exp2(NB_BITS_MAXSPACE-1)" /> 
    <var    name="EBC_CS2_SIZE" value="exp2(19)" /> 
    <var    name="EBC_CS3_SIZE" value="exp2(18)" /> 
    <var    name="EBC_CS4_SIZE" value="exp2(NB_BITS_CS4)" /> 
    
    <var    name="INT_RAM_NB_BITS" value="17" /> 
    <var    name="INT_RAM_NB_BLOCK" value="MEMBRIDGE_RAM_NB_BLOCK" /> 
    <var    name="INT_RAM_SIZE" value="32768*INT_RAM_NB_BLOCK" /> 

    <var    name="INT_ROM_NB_BITS" value="17" /> 
    <var    name="INT_ROM_SIZE" value="128*1024" /> 

    <var    name="NB_BIT_ROM_PACHT" value="4" />
    <var    name="NB_ROM_PACHT" value="16" />


<module name="mem_bridge" category="System">

    
    <reg name="FIFO_Ctrl" protect="rw">
        <bits name="Lock"         pos="0"     access="rw" rst="0">
            <comment>Lock mode: when locked the FIFO only accept requests from the XCPU, other masters receive the Split response until the lock mode is disabled. (If blocked in debug, use host internal reg reset+xcpu hold).

            </comment>
            <options>
                <option name="Enable" value="1"/>
                <option name="Disable" value="0"/>
            </options>
        </bits>
        <bits name="AHB_Cmd_Full_Shift"  pos="4" access="rw" rst="0">
            <comment>In order to solve the possible AHBC arbitration bug, a delay is put to the AHB_Cmd_Full signal. 
By default, when a slot is freed in the FIFO a master can come and take this slot before the previously splitted masters are even unsplitted.
There is a 5 clock delay between the freed spot and the HSLIT signal that this shifter will compentiate only when a slot is freed 
(falling edge of AHB_Cmd_Full) not when the FIFO is full (rising edge of AHB_Cmd_Full).

This option has to be set as well as the New arbitration feature in the AHBC module in order be effective.
            </comment>
            <options>
                <option name="Enable" value="0"/>
                <option name="Disable" value="1"/>
            </options>
        </bits>
    </reg>
    <reg name="FIFO_Status" protect="rw">
        <bits name="FIFO_A_Level"      pos="5:4"     access="r" rst="0">
            <comment>Number of requests pending in System fifo.
            </comment>
            <options><default/><mask/><shift/></options>
        </bits>
        <bits name="FIFO_B_Level"      pos="9:8"     access="r" rst="0">
            <comment>Number of requests pending in Baseband FIFO
            </comment>
            <options><default/><mask/><shift/></options>
        </bits>
    </reg>
    <reg name="Monitor_Ctrl" protect="rw">
        <bits name="Monitor_Sel"    pos="0"     access="rw" rst="0">
            <comment>Monitor signal selection
            </comment>
            <options>
                <option name="Side_by_Side" value="0"><comment>Select FIFO Data access used by each side</comment></option>
                <option name="Data_vs_External" value="1"><comment>Select FIFO Data used by both side against Cycle used on External interface</comment></option>
            </options>
        </bits>
    </reg>

    
    <reg name="Rom_Bist" protect="rw">
        <bits name="Ctrl"    pos="0"     access="rw" rst="0">
            <comment>Write 1 to start the CRC Computation on the Rom, Read to get the status
            </comment>
            <options>
                <option name="Done" value="0"/>
                <option name="Running" value="1"/>
            </options>
        </bits>
        <bits name="CRC"    pos="31:16" access="r"  rst="0">
            <comment>The Computed CRC
            </comment>
        </bits>
    </reg>
    <reg name="SRam_Bist" protect="rw">
        <bits name="Ctrl"    pos="0"     access="w" rst="0">
            <comment>Write 1 to start the BIST on the selected SRam block, Read to get the status
            </comment>
            <options>
                <option name="Done" value="0"/>
                <option name="Running" value="1"/>
            </options>
        </bits>
        <bits name="Block_Sel"  pos="INT_RAM_NB_BITS-1:15"  access="rw">
            <comment>The Bock of 32k on which to run the March C- algorithm
            </comment>
        </bits>
        <bits name="Status"    pos="31" access="r"  rst="0">
            <comment>The Bist Status (valid when Done)
            </comment>
            <options>
                <option name="Bad" value="1"/>
                <option name="OK" value="0"/>
            </options>
        </bits>
    </reg>

    <reg name="MemSC" protect="" count="32">
        <bits name="Sema_Enable" pos="0" access="rw" rst="1">
            <comment>Mem semaphore enable, used for critical section.
                <br/>Read returns its value and then clears it to '0'.
                <br/>Write the read value to restore the previous state.
            </comment>
        </bits>
    </reg>

    <reg name="MemSC_Status" protect="r">
        <bits name="MemSC_Status" pos="31:0" access="r" rst="0xffffffff">
            <comment>Status of memory semaphore enable, used for critical section.
            </comment>
        </bits>
    </reg>

    <hole size="832"/> 

    
    <reg name="Rom_Patch" count="NB_ROM_PACHT" protect="rw">
        <bits name="block_addr" pos="INT_RAM_NB_BITS-1:4" access="rw">
            <comment>Base address of block in int_Rom patched (corresponding data are read from int_SRam)
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Patch"  pos="31"    access="rw" rst="0">
            <options>
                <option name="Enable" value="1"/>
                <option name="Disable" value="0"/>
            </options>
        </bits>
    </reg>
    
 
    <hole size="1536"/> 
    
    <hole size="2048"/>
    <hole size="2048"/>

    
    <reg name="EBC_Ctrl" protect="rw">
        <bits name="Enable"         pos="0"     access="rw" rst="1">
            <comment>Enable the ebc
                <br/>1 = Enable
                <br/>0 = Disable (will finish current transfer anyway)
            </comment>
        </bits>
        <bits name="IdleDrive"      pos="12"    access="rw" rst="0">
            <comment>This bit select wether (1) or not (0) the EBC drives the data bus lines during idle (ie: between tranfers)
            </comment>
        </bits>
        <bits name="clkout_inv"     pos="16"    access="rw" rst="0">
            <comment>clk out invert
            </comment>
        </bits>
    </reg>
    <reg name="EBC_Status" protect="rw">
        <bits name="Enable"         pos="0"     access="r" rst="1">
            <comment>Enable status of the module (as reading EBC_Ctrl will return the written value)
            </comment>
        </bits>
        <bits name="Update_CS"      pos="4"     access="r" rst="0">
            <comment>This bit shows that a CS update is in progress. It reads as 1 when a chip select register has been written but not yet updated in the actual configuration. This is to ensure the configuration does not change during an access.
            </comment>
        </bits>
    </reg>
    <hole size="32"/> 
    <reg name="CS_Time_Write" protect="rw">
        <comment>This register is used to program the CS_Time register of One CS_Config at the same time as the CS_Mode regiter is set (so the two registers are always synchronized with each other).
            <br/>To update Chip Select n configuration, first write the timing value in this register, then write the CS_Mode configuration in the corresponding CS_Config[n].CS_Mode.
        </comment>
        <bits name="RdLatHalfMode" pos="0" access="rw" rst="1">
            <comment>Read access Latency Half cycle Mode:
                <br/>when 1 reduce the cycle latency by half a cycle between 2 consecutive half word access.
                <br/>In burst mode, when 1 extend the cycle latency by half a cycle for all half word access.
            </comment>
        </bits>
        <bits name="RdLat" pos="5:1" access="rw" rst="all1">
            <comment>Read access Latency: Access time for read.
                <br/>Access time in clock cycle is the value of this field +1.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="OEDlyHalfMode" pos="8" access="rw" rst="1">
            <comment>Chip select to Output enable Setup half mode:
                <br/>1 add one half cycle to the time
            </comment>
        </bits>
        <bits name="OEDly" pos="11:9" access="rw" rst="all1">
            <comment>Chip select to Output enable Setup time:
                <br/>The time in clock cycle is the value of this field.

            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="PageLat" pos="15:13" access="rw" rst="all1">
            <comment>Page mode Latency value: Page mode access time (for read or write page mode)
                <br/>Access time in clock cycle is the value of this field +1.
                <br/>Note: if Half cycle mode is enabled it also applies to the page mode.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="WrLatHalfMode" pos="16" access="rw" rst="1">
            <comment>Write access Latency Half cycle Mode:
                <br/>when 1 reduce the cycle latency by half a cycle between 2 consecutive half word access.
            </comment>
        </bits>
        <bits name="WrLat" pos="21:17" access="rw" rst="all1">
            <comment>Write access Latency: Access time for write.
                <br/>Access time in clock cycle is the value of this field +1.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="WEDlyHalfMode" pos="24" access="rw" rst="1">
            <comment>Chip select to Write enable Setup half mode:
                <br/>1 add one half cycle to the time
            </comment>
        </bits>
        <bits name="WEDly" pos="27:25" access="rw" rst="all1">
            <comment>Chip select to Write enable Setup time:
                <br/>The time in clock cycle is the value of this field.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="Relax" pos="30:28" access="rw" rst="all1">
            <comment>Relaxation delay between sequence of access (all read or all write) to the same chip select and any new sequence or idle state.
                <br/>The delay in number of clock cycle is the value of this field.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="ForceRelax" pos="31" access="rw" rst="1">
            <comment>Force Relaxation cycles to be inserted between any access. (same page or same burst consecutive access are considered a single access)
            </comment>
        </bits>
    </reg>
    <struct name="CS_Config" count="EBC_NB_CS">
        <reg name="CS_Mode" protect="rw">
            <comment>Writing this register will also copy the content of CS_Time_Write to the CS_Time register.
            </comment>
            <bits name="CSEn" pos="0" access="rw" rst="0">
                <comment>Enable the chip select.
                </comment>
            </bits>
            <bits name="Polarity" pos="1" access="rw" rst="0">
                <comment>Chip Select polarity: 1 active High, '0' active Low.
                    <br/>CS0 and CS1 are always active low (0) so this bit is not writable for them.
                </comment>
                <options>
                    <option name="ActiveHigh" value="1"/>
                    <option name="ActiveLow" value="0"/>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="ADMuxMode" pos="2" access="rw" rst="0">
                <comment>1 use Address/Data Mux for 16 lower address bits.
                </comment>
            </bits>
            <bits name="WriteAllow" pos="4" access="rw" rst="1">
                <comment>1 to allow write, else a write to the memory of this chip select will be dropped from the controller without notice.
                </comment>
            </bits>
            <bits name="WBEMode" pos="5" access="rw" rst="1">
                <comment>1 to use BE as WE for each byte (to use two 8bits chips)
                </comment>
            </bits>
            <bits name="BEDlyMode" pos="6" access="rw" rst="1">
                <comment>0: BE active after OEDly/WEDly
                    <br/>1: BE active during full access
                </comment>
            </bits>
            <bits name="WaitMode" pos="8" access="rw" rst="1">
                <comment>1 to use the wait input to delay end of a read access.
                    <br/>(RdLat min 4)
                </comment>
            </bits>
            <bits name="WriteWaitMode" pos="9" access="rw" rst="1">
                <comment>1 to use the wait input to delay end of a write access.
                    <br/>(WrLAt min 4)
                </comment>
            </bits>
            <bits name="PageSize" pos="14:12" access="rw" rst="all1">
                <options>
                    <option name="4HW" value="0"><comment>4 half words </comment></option>
                    <option name="8HW" value="1"><comment>8 half words </comment></option>
                    <option name="16HW" value="2"><comment>16 half words </comment></option>
                    <option name="32HW" value="3"><comment>32 half words </comment></option>
                    <option name="64HW" value="4"><comment>64 half words </comment></option>
                    <option name="128HW" value="5"><comment>128 half words </comment></option>
                    <option name="256HW" value="6"><comment>256 half words </comment></option>
                    <option name="FULL" value="7"><comment>Full page (in burst mode, else reserved)</comment></option>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
                <comment>Page size for page or bursts access.
                </comment>
            </bits>
            <bits name="PageMode" pos="16" access="rw" rst="1">
                <comment>1 enable page mode for read access:
                    <br/>only address changes, chip select keeps enabled while address keeps in a page (defined by PageSize). 
                </comment>
            </bits>
            <bits name="WritePageMode" pos="17" access="rw" rst="1">
                <comment>1 enable page mode for write access.
                </comment>
            </bits>
            <bits name="BurstMode" pos="20" access="rw" rst="1">
                <comment>1 enable burst mode for read access.
                    <br/>Use PageSize.
                    <br/>Require the use of the M_ADV and M_CLK pins.
                </comment>
            </bits>
            <bits name="WriteBurstMode" pos="21" access="rw" rst="1">
                <comment>1 enable burst mode for write access.
                </comment>
            </bits>
            <bits name="ADVAsync" pos="24" access="rw" rst="1">
                <comment>1 the M_ADV pin is low only during the first cycle of an asynchronous access (for asynchronous modes on burst capable chips)
                </comment>
            </bits>
            <bits name="ADVWEPulse" pos="25" access="rw" rst="1">
                <comment>1 the M_WE is valid only during the M_ADV pulse.
                </comment>
            </bits>
            <bits name="ADMuxDly" pos="27:26" access="rw" rst="0">
                <comment>Address/Data Mux timing
                </comment>
                <options>
                    <option name="normal" value="0"><comment>ADV signal as in burst mode</comment></option>
                    <option name="F1" value="1"><comment>ADV signal fall a half cycle after CS for 1 cycle</comment></option>
                    <option name="F1_5" value="2"><comment>ADV signal fall a half cycle after CS for 1.5 cycle</comment></option>
                    <option name="F2" value="3"><comment>ADV signal fall a half cycle after CS for 2 cycle</comment></option>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="WriteSingle" pos="28" access="rw" rst="1">
                <comment>1 the Write Burst mode PageSize is replaced by 1 to do synchronous single write access. (while PageSize is still used for Read burst access)
                </comment>
            </bits>
            <bits name="WriteHold" pos="29" access="rw" rst="1">
                <comment>1 the data remains driven during Relaxation time.
                </comment>
            </bits>
        </reg>
        <reg name="CS_Time" protect="r">
            <comment>This register cannot be written direclty. To update it, write to the CS_Time_write register, then to the CS_Mode register.
            </comment>
            <bits name="RdLatHalfMode" pos="0" access="r" rst="1">
                <comment>Read access Latency Half cycle Mode:
                    <br/>when 1 reduce the cycle latency by half a cycle between 2 consecutive half word access.
                    <br/>In burst mode, when 1 extend the cycle latency by half a cycle for all half word access.
                </comment>
            </bits>
            <bits name="RdLat" pos="5:1" access="r" rst="all1">
                <comment>Read access Latency: Access time for read.
                    <br/>Access time in clock cycle is the value of this field +1.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="OEDlyHalfMode" pos="8" access="r" rst="1">
                <comment>Chip select to Output enable Setup half mode:
                    <br/>1 add one half cycle to the time
                </comment>
            </bits>
            <bits name="OEDly" pos="11:9" access="r" rst="all1">
                <comment>Chip select to Output enable Setup time:
                    <br/>The time in clock cycle is the value of this field.

                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="PageLat" pos="15:13" access="r" rst="all1">
                <comment>Page mode Latency value: Page mode access time (for read or write page mode)
                    <br/>Access time in clock cycle is the value of this field +1.
                    <br/>Note: if Half cycle mode is enabled it also applies to the page mode.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="WrLatHalfMode" pos="16" access="r" rst="1">
                <comment>Write access Latency Half cycle Mode:
                    <br/>when 1 reduce the cycle latency by half a cycle between 2 consecutive half word access.
                </comment>
            </bits>
            <bits name="WrLat" pos="21:17" access="r" rst="all1">
                <comment>Write access Latency: Access time for write.
                    <br/>Access time in clock cycle is the value of this field +1.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="WEDlyHalfMode" pos="24" access="r" rst="1">
                <comment>Chip select to Write enable Setup half mode:
                    <br/>1 add one half cycle to the time
                </comment>
            </bits>
            <bits name="WEDly" pos="27:25" access="r" rst="all1">
                <comment>Chip select to Write enable Setup time:
                    <br/>The time in clock cycle is the value of this field.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="Relax" pos="30:28" access="r" rst="all1">
                <comment>Relaxation delay between sequence of access (all read or all write) to the same chip select and any new sequence or idle state. (burst reaching end of page in non Full Page mode also insert a Relaxation delay)
                    <br/>The delay in number of clock cycle is the value of this field.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name="ForceRelax" pos="31" access="r" rst="1">
                <comment>Force Relaxation cycles to be inserted between any access. (same page or same burst consecutive access are considered a single access)
                </comment>
            </bits>
        </reg>
    </struct>
    <hole size="1600"/> 

    
    <reg name="AHBM_Ctrl" protect="rw">
        <bits name="Enable"         pos="0"     access="rw" rst="1">
            <comment>Enable the AHB Master
                <br/>1 = Enable
                <br/>0 = Disable (will finish current transfer anyway)
            </comment>
        </bits>
    </reg>
    <reg name="AHBM_Status" protect="rw">
        <bits name="Enable"         pos="0"     access="r" rst="1">
            <comment>Enable status of the module (as reading AHBM_Ctrl will return the written value)
            </comment>
        </bits>
        <bits name="Update_SB"      pos="4"     access="r" rst="0">
            <comment>This bits shows that a SpaceBase update is in progress. It reads as 1 when a SpaceBase register has been written but not yet updated in the actual configuration. This is to ensure the configuration does not change during an access.
            </comment>
        </bits>
    </reg>
    <hole size="64"/>
    <reg name="SpaceBase" protect="rw" count="EBC_NB_CS">
        <bits name="BaseAddr" pos="31:4" access="rw" rst="all1" display="hex">
            <comment>Base address added to the lower bits of address from FIFO.
            </comment>
        </bits>
    </reg>


</module>


<module name="mem_FIFO" category="System">

    <reg name="Flush" protect="rw">
        <comment>Reading this register ensure the previous write command are all done (any read would do anyway) but this does not access external controller. When changing CS Config it will only work if the baseband is off (boot...) ! Poll CS_Update in reg CS Status instead.
        </comment>
        <bits name="Flush"         pos="0"     access="r" rst="0">
        </bits>
    </reg>
    <reg name="EBC_CRE" protect="rw">
        <bits name="CRE"         pos="0"     access="rw" rst="0">
            <comment>Write here the desired state of the M_CRE pin. 
                <br/>As this register is placed in the FIFO with the memory commands, it ensure the sequence of memory access and change to this register will be kept in sequence.
            </comment>
        </bits>
    </reg>
    <reg name="EBC_CS4_Block_Remap" protect="rw">
        <bits name="Block_Remap"         pos="NB_BITS_EXTADDR-2:NB_BITS_CS4"     access="rw" rst="all0">
            <comment>When the CS4 is accessed the adress is extended by the bits in this register and the MSB is set to 1.
                <br/>As this register is placed in the FIFO with the memory commands, it ensure the sequence of memory access and change to this register will be kept in order.
            </comment>
            <options><default/><mask/><shift/></options>
        </bits>
    </reg>
    <reg name="Side_Id" protect="r">
        <bits name="Side_Id"         pos="0"     access="r" rst="no">
            <comment>Read as 0 on System side, as 1 on BaseBand Side.
            </comment>
            <options>
                <option name="System" value="0"/>
                <option name="Baseband" value="1"/>
            </options>
        </bits>
    </reg>
</module>

<module name="ebc_cs0" category="System">
    <memory name="ram_array" size="EBC_CS0_SIZE">
        <comment>EBC Chip select 0 memory space.
            <br/>Space accessed by M_CS_0 line.
            <br/>This chip select is dedicated to Flash access, the CPU will boot from here.
        </comment>
    </memory>
</module>
<module name="ebc_cs1" category="System">
    <memory name="ram_array" size="EBC_CS1_SIZE">
        <comment>EBC Chip select 1 memory space.
            <br/>Space accessed by M_CS_1 line.
            <br/>This chip select is dedicated to ram access.
        </comment>
    </memory>
</module>
<module name="ebc_cs2" category="System">
    <memory name="ram_array" size="EBC_CS2_SIZE">
        <comment>EBC Chip select 2 memory space.
            <br/>Space accessed by M_CS_2 line
        </comment>
    </memory>
</module>
<module name="ebc_cs3" category="System">
    <memory name="ram_array" size="EBC_CS3_SIZE">
        <comment>EBC Chip select 3 memory space.
            <br/>Space accessed by M_CS_3 line
        </comment>
    </memory>
</module>
<module name="ebc_cs4" category="System">
    <memory name="ram_array" size="EBC_CS4_SIZE">
        <comment>EBC Chip select 4 memory space.
            <br/>Space accessed by M_CS_4 line
        </comment>
    </memory>
</module>


<module name="int_sram" category="System">
    <memory name="sram_array" size="INT_RAM_SIZE">
        <comment>Internal SRam Space
        </comment>
    </memory>
</module>

<module name="int_rom" category="System">
    <memory name="rom_array" size="INT_ROM_SIZE">
        <comment>Internal Rom Space
            <br/>This rom is used for boot code.
        </comment>
    </memory>
</module>

</archive>

<archive relative='gpio.xml' >


  
  <include file="bb2g_generic_config.xml"/>

  
  <var name="IDX_GPIO_DCON" value="0" />
  <var name="IDX_GPO_CHG" value="0" />


<module name="gpio" category="Periph">

  

  <reg protect="rw" name="gpio_oen_val">
    <bits access="rw" name="oen_val" pos="NB_GPIO-1:0" rst="0xffffffff" display="hex">
      <options>
        <option name="INPUT" value="1" />

        <option name="OUTPUT" value="0" />

        <default />
      </options>

      <comment>Set the direction of the GPIO n.<br />0 = output<br />1 =
      input</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_out">
    <bits access="rc" name="oen_set_out" pos="NB_GPIO-1:0" rst="0">
      <comment>'Write '1' sets the corresponding GPIO pin as output.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_in">
    <bits access="rs" name="oen_set_in" pos="NB_GPIO-1:0" rst="0xffffffff" display="hex">
      <comment>'Write '1' sets the corresponding GPIO pin as input.</comment>
    </bits>
  </reg>

  

  <reg protect="rw" name="gpio_val">
    <bits access="rw" name="gpio_val" pos="NB_GPIO-1:0" rst="0xffffffff" display="hex">
      <comment>When write, update the output value. When read, get the input
      value. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_set">
    <bits access="rs" name="gpio_set" pos="NB_GPIO-1:0" rst="0">
      <comment>Write '1' will set GPIO output value. When read, get the GPIO
      output value.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_clr">
    <bits access="rc" name="gpio_clr" pos="NB_GPIO-1:0" rst="0">
      <comment>'Write '1' clears corresponding GPIO output value. When read, get the GPIO
      output value. </comment>
    </bits>
  </reg>

  

  <reg protect="rw" name="gpint_ctrl_set">
    <bits access="rs" name="gpint_r_set" pos="7:0" rst="0">
      <comment>Write '1' will set GPIO interrupt mask for rising edge and
      level high. When read, get the GPIO interrupt mask for rising edge and
      level high. </comment>
    </bits>

    <bits access="rs" name="gpint_f_set" pos="15:8" rst="0">
      <comment>Write '1' will set GPIO interrupt mask for falling edge and
      level low. When read, get the GPIO interrupt mask for falling edge and
      level low.</comment>
    </bits>

    <bits access="rs" name="dbn_en_set" pos="23:16" rst="0">
      <comment>Write '1' will enable debounce mechanism.</comment>
    </bits>

    <bits access="rs" name="gpint_mode_set" pos="31:24" rst="0">
      <comment>Write '1' will set interruption mode to level.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpint_ctrl_clr">
    <bits access="rc" name="gpint_r_clr" pos="7:0" rst="0">
      <comment>'Write '1' will clear GPIO interrupt mask for rising edge and
      level high.</comment>
    </bits>

    <bits access="rc" name="gpint_f_clr" pos="15:8" rst="0">
      <comment>Write '1' will clear GPIO interrupt mask for falling edge and
      level low.</comment>
    </bits>

    <bits access="rc" name="dbn_en_clr" pos="23:16" rst="0">
      <comment>Write '1' will disable debounce mechanism.</comment>
    </bits>

    <bits access="rc" name="gpint_mode_clr" pos="31:24" rst="0">
      <comment>Write '1' will set interruption mode to edge
      triggered.</comment>
    </bits>
  </reg>

  

  <reg protect="w" name="int_clr">
    <bits access="c" name="gpint_clr" pos="NB_GPIO_INT-1:0" rst="0">
      <comment>'Write '1' will clear GPIO interrupt.</comment>
    </bits>
  </reg>

  <reg protect="r" name="int_status">
    <bits access="r" name="gpint_status" pos="NB_GPIO_INT-1:0" rst="0">
      <comment>Each bit represents if there is a GPIO interrupt
      pending.</comment>
      <options>
        <default/>
        <mask/>
        <shift/>
      </options>
    </bits>
  </reg>

  
  <reg protect="rw" name="chg_ctrl">
    <bits access="rw" name="out_time" pos="3:0" rst="0xf" display="hex">
        <comment>time for which GPIO0 is set to output mode, after a start read
            DCON command is issued.<br />The output time = (OUT_TIME+1)*30.5us.
        </comment>
    </bits>

    <bits access="rw" name="wait_time" pos="9:4" rst="0x3f" display="hex">
        <comment>time for which GPIO0 should wait before reading DC_ON, after
            a start read DCON command is issued.<br />The wait time = (WAIT_TIME+1)*30.5us.
            <br/>NOTE: wait_time must be strictly greater than out_time;
        </comment>
    </bits>

    <bits access="rw" name="int_mode" pos="17:16" rst="0x3" display="hex">
        <comment>interruption mode of GPIO0 in mode DC_ON detection.<br />
        </comment>
            <options>
                <option name="L2H" value="0">
                    <comment>
                        "00" = send IRQ if last read DCON is '0' and now is '1'. 
                    </comment>
                </option>
                <option name="H2L" value="1">
                    <comment>
                        "01" = send IRQ if last read DCON is '1' and now is '0'.
                    </comment>
                </option>
                <option name="RR" value="3">
                    <comment>
                        "11" = send IRQ every time read is ready.
                    </comment>
                </option>
            </options>
    </bits>
  </reg>
  
  

  <reg protect="w" name="chg_cmd">
    <bits access="s" name="dcon_mode_set" pos="0" rst="0">
      <comment>Write '1' to set GPIO0 to charger DCON detect mode.</comment>
    </bits>
      
    <bits access="s" name="chg_mode_set" pos="4" rst="0">
      <comment>Write '1' to set GPO0 to charger watchdog mode.</comment>
    </bits>

    <bits access="c" name="dcon_mode_clr" pos="8" rst="0">
      <comment>Write '1' to clear charger DCON detect mode of GPIO0.</comment>
    </bits>

    <bits access="c" name="chg_mode_clr" pos="12" rst="0">
      <comment>Write '1' to clear the charger watchdog mode of GPO0.</comment>
    </bits>

    <bits access="s" name="chg_down" pos="24" rst="0">
      <comment>Write '1' to generate a pulse of '0' on GPO0 for 16 CLK_OSC cycles.</comment>
    </bits>
  </reg>

  

  <reg protect="rw" name="gpo_set">
    <bits access="rs" name="gpo_set" pos="NB_GPO-1:0" rst="0xaaaaaaaa" display="hex">
      <comment>'Write '1' will set GPO output value. When read, get the GPO
      output value.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpo_clr">
    <bits access="rc" name="gpo_clr" pos="NB_GPO-1:0" rst="0xaaaaaaaa" display="hex">
      <comment>'Write '1' will clear GPO output value. When read, get the GPO
      output value.</comment>
    </bits>
  </reg>
</module>


</archive>


<archive relative='itlv.xml' >


<include file="globals.xml"/>

<module name="itlv" category="Baseband">
  <reg name="command" protect="rw">
    <bits access="rw" name="nb_bits" pos="29:20" rst="0x0">
      <comment>Number of bits to be (De)Interleaved.</comment>
    </bits>

    <bits access="rw" name="burst_offset" pos="12:8" rst="0x0">
      <comment>This value gives the write offset (in number of bursts) to be
      added to a Burst Base address (ignored for Type 1b). For normal
      operation, this offset should be even (lsb will be ignored).</comment>
    </bits>

    <bits access="rw" name="itlv_type" pos="6:4" rst="0x0">
      <comment>Selects (de-)interleaving type.</comment>
            <options>
                <option name="TYPE_1A" value="0">
                    <comment>TCH/FS, TCH/EFS, FACCH/F, TCH/F2.4, TCH/AFS (speech, ratscch, sid_first)</comment>
                </option>
                <option name="TYPE_1B" value="1">
                    <comment>SACCH, TCH/AFS(sid_update), PDTCH(CS-1 to CS-4), BCCH, PCH, AGCH, PACCH, PBCCH, PAGCH, PPCH, PNCH, PTCCH/D</comment>
                </option>
                <option name="TYPE_1C" value="2">
                    <comment>FACCH/H</comment>
                </option>
                <option name="TYPE_2A" value="3">
                    <comment>TCH/HS and TCH/AHS</comment>
                </option>
                <option name="TYPE_2B" value="4">
                    <comment>TCH/HS and TCH/AHS</comment>
                </option>
                <option name="TYPE_3" value="5">
                    <comment>TCH/F14.4, TCH/F9.6, TCH/F4.8, TCH/H4.8, and TCH/H2.4</comment>
                </option>
                <default/>
                <mask/>
                <shift/>
            </options>
    </bits>

    <bits access="rw" name="int_mask" pos="3" rst="0x0">
      <comment>Sets the interrupt mask ('1': interruption enabled)</comment>
    </bits>

    <bits access="rw" name="ditlv_start" pos="1" rst="0x0">
      <comment>Starts the de-interleaving process.</comment>
    </bits>

    <bits access="rw" name="itlv_start" pos="0" rst="0x0">
      <comment>Starts the interleaving process.</comment>
    </bits>
  </reg>

  <reg name="status" protect="r">
    <bits access="r" name="busy" pos="0" rst="0x0">
      <comment>This bit is high when a (de-)interleaving process is ongoing. It
      stays high if the module is stalled during operation.</comment>
    </bits>
  </reg>

  <reg name="burst_base" protect="rw">
    <bits access="rw" name="burst_base" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>This is the start address of the burst buffer in SRAM
      </comment>
    </bits>
  </reg>

  <reg name="frame_base" protect="rw">
    <bits access="rw" name="frame_base" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>This is the start address of the frame buffer in
      SRAM.</comment>
    </bits>
  </reg>

  <reg name="int_status" protect="r">
    <bits access="r" name="it_status" pos="16" rst="0x0">
      <comment>This bit is the unmasked version of the IT_CAUSE bit.</comment>
    </bits>

    <bits access="r" name="it_cause" pos="0" rst="0x0">
      <comment>This bit is set when the ITLV module finishes an ongoing
      operation. It can be masked by setting ITLV_CMD(IT_MASK) to '1'.
      Resetting this bit is done by writing in IT_CLEAR register. IT_CAUSE is
      the image of the ITLV_DONE_H interrupt line to the CPU. </comment>
    </bits>
  </reg>

  <reg name="int_clear" protect="w">
    <bits access="w" name="it_clear" pos="0" rst="0x0">
      <comment>Setting this bit to '1' resets the Interleaver's
      interrupt.</comment>
    </bits>
  </reg>
</module>

</archive>


<archive relative='page_spy.xml' >


<include file="globals.xml"/>


<module name="page_spy" category="Debug">

  <var name="PAGE_SPY_NB_PAGE" value="16"/>

  <reg protect="rw" name="enable">
    <bits access="rs" name="enable_page" pos="PAGE_SPY_NB_PAGE-1:0" rst="0" cut="1" cutprefix="enable_page">
      <comment>Writing '1' enable the page (n), writing '0' leave the page in
      it's current state. Reading returns '1' if the page is active (hit or
      not).</comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="status_page" pos="PAGE_SPY_NB_PAGE-1:0" rst="0" cut="1" cutprefix="status_page">
      <options>
        <option name="NOT_HIT" value="0" />

        <option name="HIT" value="1" />

        <default />
      </options>
      <comment>Status of the page.</comment>
    </bits>

  </reg>

  <reg protect="rw" name="disable">
    <bits access="rc" name="disable_page" pos="PAGE_SPY_NB_PAGE-1:0" rst="0" cut="1" cutprefix="disable_page">
      <comment>Writing '1' disable the page (n) and clears the hit status if
      any, writing '0' leave the page in it's current state. Reading returns
      '1' if the page is active (hit or not).</comment>
    </bits>
  </reg>

  <hole size="32" />

  <struct count="PAGE_SPY_NB_PAGE" name="page">
    <reg protect="rw" name="start">
      <bits access="rw" name="start_address" pos="NB_BITS_ADDR-1:0" rst="no">
        <comment>Start address of page (n) (included). </comment>
      </bits>

      <bits access="rw" name="detect_read" pos="30" rst="no">
        <comment>If '1' any read within the range will trigger the
        page.</comment>
      </bits>

      <bits access="rw" name="detect_write" pos="31" rst="no">
        <comment>If '1' any read within the range will trigger the
        page.</comment>
      </bits>
      <bitgroup name="mode">
        <entry ref="detect_read"/>
        <entry ref="detect_write"/>
      </bitgroup>  
    </reg>

    <reg protect="rw" name="end">
      <bits access="rw" name="end_address" pos="NB_BITS_ADDR-1:0" rst="no">
        <comment>End address of page (n) (excluded).</comment>
      </bits>
    </reg>

    <reg protect="r" name="master">
      <bits access="r" name="master" pos="2:0" rst="0">
        <options>
          <option name="NO_ACCESS" value="0" />
          <option name="BIST" value="1" />
          <option name="DMA" value="2" />
          <option name="SYS_XCPU" value="3" />
          <option name="AHB2AHB" value="4" />
          <option name="IFC" value="5" />
          <option name="USB" value="6" />
          <default />
        </options>

        <comment>The master that wrote in the page (n). </comment>
      </bits>
    </reg>

    <reg protect="r" name="addr">
      <bits access="r" name="hit_addr" pos="24:0" rst="no">
        <comment>Address that triggered page (n). </comment>
      </bits>

      <bits access="r" name="hit_read" pos="30" rst="no">
        <comment>If '1' a read has triggered the page.</comment>
      </bits>

      <bits access="r" name="hit_write" pos="31" rst="no">
        <comment>If '1' a write has triggered the page.</comment>
      </bits>
    </reg>
  </struct>
</module>

</archive>
<archive relative='rf_if.xml' >

<module name="rf_if" category="Baseband">

  <reg protect="rw" name="Buffer">
    <bits access="rw" name="Rx/Tx data" pos="31:0" rst="no">
      <comment>In read mode this register contains the sample received on the Rx chain. I component is located on bit[15:0] and Q component is located on bit[31:16].
      <br />This register accesses to the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data sample arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overflow error will also occur.
      <br />The data written[29:0] into this register is the data transmitted. Any attempt to write data when the FIFO is full results in the write data being lost.
      </comment>
    </bits>
  </reg>

  <reg protect="rw" name="Ctrl">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <options>
        <option name="Disable" value="0" />
        <option name="Enable" value="1" />
      </options>
      <comment>Turn on/off the rf_if interface</comment>
    </bits>
    
    <bits access="rw" name="DigRF Enable" pos="1" rst="0">
      <options>
        <option name="Disable" value="0"><comment>Analog more selected</comment></option>
        <option name="Enable" value="1"><comment>DigRF mode selected</comment></option>
      </options>
      <comment>Turn on/off the DigRF mode</comment>
    </bits>
    
    <bits access="rw" name="Rx overflow Enable" pos="4" rst="1">
      <options>
        <option name="Disable" value="0"><comment>Disable (mask) Rx fifo overflow interrupt</comment></option>
        <option name="Enable" value="1"><comment>Enable Rx fifo overflow interrupt</comment></option>
      </options>
      <comment>Rx Fifo Overflow interrupt Enable</comment>
    </bits>
    
    <bits access="rw" name="Rx Cal Bypass" pos="5" rst="1">
      <options>
        <option name="Enabled" value="0" />
        <option name="Bypassed" value="1" />
      </options>
      <comment>Calibration bypass</comment>
    </bits>
    
    <bits access="rw" name="Rx Swap I/Q" pos="6" rst="0">
      <options>
        <option name="NO" value="0"><comment>No Swap</comment></option>
        <option name="YES" value="1"><comment>Swap I/Q</comment></option>
      </options>
      <comment>Rx swap I/Q</comment>
    </bits>
    
    <bits access="rw" name="Rx Force ADC On" pos="7" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Rx_On output controlled by TCO_RX_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced ADC on;Rx_On output always high</comment></option>
      </options>
      <comment>Force Rx On. This bit is used only with the analog option.</comment>
    </bits>

    <bits access="rw" name="Rx Force Dec On" pos="8" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, decimator controlled by Rx_dec_on signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced; decimator always on</comment></option>
      </options>
      <comment>Force Decimator On</comment>
    </bits>
    
    <bits access="w" name="Rx Force SOC" pos="9" rst="no">
      <comment>Force start of calibation in receive mode
        <br />Writing a 1 to this bit launch the calibration phase. Write only bit, this bit doesn't need to be cleared.
      </comment>
    </bits>
    
    <bits access="w" name="Rx Fifo Reset" pos="10" rst="no">
      <comment>Writing a 1 to this bit resets and flush the receive Fifo. 
        <br />Write only bit, this bit doesn't need to be cleared.
      </comment>
    </bits>
    
  
    <bits access="rw" name="Tx overflow Enable" pos="16" rst="1">
      <options>
        <option name="Disable" value="0"><comment>Disable (mask) Tx fifo overflow interrupt</comment></option>
        <option name="Enable" value="1"><comment>Enable Tx fifo overflow interrupt</comment></option>
      </options>
      <comment>Tx Fifo Overflow interrupt Enable</comment>
    </bits>
    
    <bits access="rw" name="Tx underflow Enable" pos="17" rst="1">
      <options>
        <option name="Disable" value="0"><comment>Disable (mask) Tx fifo undeflow interrupt</comment></option>
        <option name="Enable" value="1"><comment>Enable Tx fifo underflow interrupt</comment></option>
      </options>
      <comment>Tx Fifo Underflow interrupt Enable:</comment>
    </bits>
    
    <bits access="rw" name="Tx Force DAC On" pos="18" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Tx_On output controlled by TCO_TX_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced DAC on; Tx_On output always high</comment></option>
      </options>
      <comment>Force DAC On. This bit is used only with the analog option.</comment>
    </bits>
    
    <bits access="rw" name="Tx Force DAC Off" pos="19" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Tx_On output controlled by TCO_TX_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced DAC Off; Tx_On output always low</comment></option>
      </options>
      <comment>Force DAC Off. This bit is used only with the analog option.</comment>
    </bits>


    <bits access="rw" name="Tx Force oen" pos="20" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Tx_Oen controlled by TCO_TX_OEN signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced; Tx_Oen always high, Low pass output in HZ</comment></option>
      </options>
      <comment>Force Tx Oen. This bit is used only with the analog option.</comment>
    </bits>
  
    <bits access="rw" name="Tx Force GMSK On" pos="21" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, transmit serial interface controlled by TCO_GMSK_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced; serializer always enabled</comment></option>
      </options>
      <comment>Force GMSK On.</comment>
    </bits>
    <bits access="rw" name="Tx Swap I/Q" pos="22" rst="0">
      <options>
        <option name="NO" value="0"><comment>No Swap</comment></option>
        <option name="YES" value="1"><comment>Swap I/Q</comment></option>
      </options>
      <comment>Tx swap I/Q. This bit is used only with the analog option.</comment>
    </bits>
 
    <bits access="w" name="Tx Fifo Reset" pos="23" rst="no">
      <comment>Writing a 1 to this bit resets and flush the transmit Fifo. 
        <br />Write only bit, this bit doesn.t need to be cleared.
      </comment>
    </bits>
    
    <bits access="rw" name="DigRF Rx Rate" pos="24" rst="1">
      <options>
        <option name="ONE" value="0"><comment>One sample per symbol</comment></option>
        <option name="TWO" value="1"><comment>Two samples per symbol</comment></option>
      </options>
      <comment>Rx rate for DigRF interface. This bit is used only when DigRF is enabled (DigRF Enabled)
      </comment>
    </bits>
    
    <bits access="rw" name="DigRF Rx Clk Pol" pos="25" rst="1">
      <comment>Change the polarity of the DigRF Rx clock. This bit is used only when DigRF is enabled (DigRF Enabled)
        <br />0 = No inversion
        <br />1 = Invert clock polarity
      </comment>
    </bits>
    
    <bits access="rw" name="DigRF Tx mode" pos="26" rst="1">
      <options>
        <option name="Stream" value="0"></option>
        <option name="Block" value="1"></option>
      </options>
      <comment>Tx mode for the DigRF interface. This bit is used only when DigRF is enabled (DigRF Enabled)
      </comment>
    </bits>

    <bits access="rw" name="DigRF Tx Clk Pol" pos="27" rst="1">
      <comment>Change the polarity of the DigRF Rx clock. This bit is used only when DigRF is enabled (DigRF Enabled)
        <br />0 = No inversion
        <br />1 = Invert clock polarity
      </comment>
    </bits>

    <bits access="rw" name="DigRF Sample Size" pos="30:28" rst="all1" display="hex">
      <comment>Shift input sample in DigRF mode only. 
        <br />The Rx sample are on 16-bit, this field select a variable of bit among 16.
        <br />000 = 16-bit selected
        <br />001 = 15-bit selected 
        <br />010 = 14-bit selected
        <br />011 = 13-bit selected
        <br />100 = 12-bit selected
      </comment>
    </bits>
    <bits access="rw" name="DigRF Alignement Select" pos="31" rst="1" display="hex">
      <comment>Select the sample alignement in DigRF mode only.. 
        <br />0 = MSB aligned sample
        <br />1 = LSB aligned sample 
      </comment>
    </bits>
  </reg>
  

    <reg protect="r" name="Status">
      <bits access="r" name="Rx Fifo level" pos="4:0" rst="0">
        <comment>Those bits indicate the number of data available in the Rx Fifo.</comment>
      </bits>
      <bits access="r" name="Tx Fifo level" pos="6:5" rst="0">
        <comment>Those bits indicate the number of data available in the Tx Fifo. Those data will be sent.
        </comment>
      </bits>
      <bits access="r" name="Rx Overflow Cause" pos="8" rst="0">
        <comment>Rx overflow cause register
        <br />This bit indicates that an interruption was generated when the Rx fifo is overflow. 
        <br />This bit is cleared when the Rx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits access="r" name="Tx Overflow Cause" pos="9" rst="0">
        <comment>Tx overflow cause register
        <br />This bit indicates that an interruption was generated when the Tx fifo is overflow. 
        <br />This bit is cleared when the Tx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits access="r" name="Tx Underflow Cause" pos="10" rst="0">
        <comment>Tx underflow cause register
        <br />This bit indicates that an interruption was generated when the Tx fifo is underflow. 
        <br />This bit is cleared when the Tx_underflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits access="r" name="Rx Overflow Status" pos="16" rst="0">
        <comment>This bit indicates that the receiver received a new sample when the FIFO was already full. 
        <br />The new sample is discarded. This bit is cleared when the Rx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
      <bits access="r" name="Tx Overflow Status" pos="17" rst="0">
        <comment>This bit indicates that the user tried to write on the FIFO while it was already full. 
        <br />This bit is cleared when the Tx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
      <bits access="r" name="Tx Underflow Status" pos="18" rst="0">
        <comment>This bit indicates that the modulator tried to read on the FIFO while it was empty. 
        <br />This bit is cleared when the Tx_Underflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
    </reg>

    <reg protect="w" name="Interruption_clear">
      <bits access="w" name="Rx Overflow" pos="0" rst="no">
        <comment>Clear Rx Interrupt Overflow interrupt.
        </comment>
      </bits>
      <bits access="w" name="Tx Overflow" pos="1" rst="no">
        <comment>Clear Tx Interrupt Overflow interrupt.
        </comment>
      </bits>
      <bits access="w" name="Tx Underflow" pos="2" rst="no">
        <comment>Clear Tx Interrupt Underflow interrupt.
        </comment>
      </bits>
    </reg>
    <reg count="4" name="Tx Burst descriptor" protect="rw">
        <bits name="NB symbols" pos="7:0" access="rw" rst="0">
            <comment>Number of symbol to transmit
            </comment>
        </bits>
        <bits name="Modulation" pos="16" access="rw" rst="0">
            <comment>0 for GMSK, 1 for 8PSK 
            </comment>
        </bits>
        <bits name="End Burst" pos="24" access="rw" rst="0">
            <comment>Indicate an end of the transmit for this current burst
            </comment>
        </bits>
    </reg>

    <reg protect="r" name="Rx Offset">
      <bits access="r" name="Rx_Offset_I" pos="15:0" rst="all0" display="hex">
        <comment>Rx offset measured after calibration for I channel
        </comment>
      </bits>
      <bits access="r" name="Rx_Offset_Q" pos="31:16" rst="all0" display="hex">
        <comment>Rx offset measured after calibratio for Q channel
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="Rx Gain">
      <bits access="rw" name="Rx_Gain_dig" pos="9:0" rst="all0">
        <comment>Rx gain for digital.
        </comment>
      </bits>
      <bits access="rw" name="Rx_Gain_Ana" pos="12:10" rst="all0">
        <comment>Rx gain for analog.
        </comment>
      </bits>
      <bits access="rw" name="Rx_Gain_Enable" pos="13" rst="0">
        <comment>Rx gain enable.
        </comment>
      </bits>
    </reg>
</module>
</archive>
<archive relative='rf_spi.xml' >


    <var    name="CMD_FIFO_LEN_BITS" value="5"/>
    <var    name="CMD_FIFO_LEN" value="20"/> 
    <var    name="CMD_SIZE_BITS" value="8"/>
    
    <var    name="CMD_DATA_FIFO_LEN_BITS" value="4"/>
    <var    name="CMD_DATA_FIFO_LEN" value="exp2(CMD_DATA_FIFO_LEN_BITS)"/>
    
    <var    name="GAIN_TABLE_LEN_BITS" value="4"/>
    <var    name="GAIN_TABLE_LEN" value="15"/>  
    <var    name="GAIN_SIZE_BITS" value="4"/>

    <var    name="RX_DATA_FIFO_LEN_BITS" value="2"/>
    <var    name="RX_DATA_FIFO_LEN" value="exp2(RX_DATA_FIFO_LEN_BITS)"/>
    

<module name="rf_spi" category="Modem">

    <reg name="Ctrl" protect="rw">
        <bits name="Enable"         pos="0"     access="rw" rst="0">
            <comment>Enable the rf spi
                <br/>1 = Enable
                <br/>0 = Disable (will finish current command anyway)
            </comment>
        </bits>
        <bits name="CS_Polarity"    pos="1"     access="rw" rst="1">
            <comment>Chip select polarity
                <br/>1 = the chip select is active low
                <br/>0 = the chip select is active high
            </comment>
        </bits>
        <bits name="DigRF_Read"     pos="2"     access="rw" rst="1">
            <comment>DigRF Read style mode
                <br/>1 = DigRF Read style mode (read after CS disabled)
                <br/>0 = SPI Read mode (read during write)
            </comment>
        </bits>
        <bits name="Clocked_Back2Back"  pos="3" access="rw" rst="1">
            <comment>DigRF style clocked back to back mode
                <br/>1 = clocked back to back transfers using turnarround timing only when more data are present in the FIFO.
                <br/>0 = stop the clock between each access according to CS_End_Hold and CS_Pulse_Min timings
            </comment>
        </bits>
        <bits name="Input_Mode"     pos="4"     access="rw" rst="1">
            <comment>Input mode
                <br/>1 = Record input data to input FIFO
                <br/>0 = No input data
            </comment>
        </bits>
        <bits name="Clock_Polarity" pos="5"     access="rw" rst="1">
            <comment>SPI Clock polarity
                <br/>1 = the clock disabled level is high, and the first edge is a falling edge.
                <br/>0 = the clock disabled level is low, and the first edge is a rising edge.
            </comment>
        </bits>
        <bits name="Clock_Delay"    pos="7:6"   access="rw" rst="3">
            <comment>Transfer start to first edge delay
                <br/> value from 0 to 2 is the number of spi clock half period between the Transfer start and the first clock edge.
            </comment>
        </bits>
        <bits name="DO_Delay"       pos="9:8"   access="rw" rst="3">
            <comment>Transfer start to first data out delay
                <br/> value from 0 to 2 is the number of spi clock half period between the Transfer start and the first data out.
            </comment>
        </bits>
        <bits name="DI_Delay"       pos="11:10" access="rw" rst="3">
            <comment>Transfer start to first data in sampled delay
                <br/> value from 0 to 3 is the number of spi clock half period between the Transfer start and the first data sampled in.
                <br/> The DI_Delay only specify the sampling time, for frame size, the counter is based on the DO_Delay even in DigRF read mode.
            </comment>
        </bits>
        <bits name="CS_Delay"       pos="13:12" access="rw" rst="3">
            <comment>Transfer start to CS activation delay
                <br/> value from 0 to 3 is the number of spi clock half period between the Transfer start and the CS activation edge.
            </comment>
        </bits>
        <bits name="CS_End_Hold"    pos="15:14" access="rw" rst="3">
            <comment>Transfer end to chip select deactivation delay
                <br/> value from 0 to 3 is the number of spi clock half period between the end of transfer (DO) and the CS deactivation edge.
                <br/> <Strong>Not used for Clocked_Back2Back mode</Strong>
            </comment>
        </bits>
        <bits name="Frame_Size"     pos="20:16" access="rw" rst="31">
            <comment>Number of data in the frame, or number of out data in DigRF read mode.
                <br/>The actual frame size is the value of this register + 1; valid value are 3 to 31 (frame size 4 to 32bits)
                <br/>The frame size is given for the number of data, the actual number of clock pulses might be greater. First if Clock_Delay &lt; DO_Delay an extra clock pulse is generated, second in case of DigRF read or back2back, some more clock pulses will be generated.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="CS_End_Pulse"   pos="23:22" access="rw" rst="3">
            <comment>Chip select deactivation to new start of transfer minimum delay
                <br/>value from 0 to 3 is the number of spi clock half period between the CS deactivation and a new transfer start (transfer will start only if more data are available in the transmit FIFO)
                <br/> <Strong>Not used for Clocked_Back2Back mode</Strong>
            </comment>
        </bits>
        <bits name="Input_Frame_Size"   pos="28:24" access="rw" rst="31">
            <comment>Frame Size For Input in DigRF input mode
                <br/>The actual frame size is the value of this register + 1; valid value are 3 to 31 (frame size 4 to 32bits)
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="TurnAround_Time"    pos="31:30" access="rw" rst="3">
            <comment>TurnAround time: end of write frame to start of read frame delay (in cycles)
                <br/>value from 0 to 3 is the number of spi clock period between the end of the output frame (without the DO_Delay) and the Input Frame start.
                <br/>Also used for Clocked_Back2Back mode, when Clocked_Back2Back=1 and there is more data available in the transmit FIFO:
                <br/>value from 0 to 3 is the number of spi clock period between the end of the frame (without the DO_Delay) and the start of the new frame.
                (It can also be seen as the number of spi clock period between the end of the last data bit and the start of the new data bit.)
            </comment>
        </bits>
    </reg>
    <reg name="Status" protect="rw">
        <bits name="Active_Status"      pos="0"     access="r" rst="0">
            <comment>The SPI activity status
                <br/>1 = A transfer is in progress
                <br/>0 = The transfer is done
            </comment>
        </bits>
        <bits name="Error_Cmd"          pos="1"     access="rc" rst="0">
            <comment>Error status
                <br/>1 = a new command (or gain) has been requested while a command was in progress.
                <br/>0 = No error
                <br/>Write 1 to clear.
            </comment>
        </bits>
        <bits name="Table_Ovf"          pos="6"     access="rc" rst="0">
            <comment>The Gain Table overflow status.
                <br/>1 = Too many data has been written in the table
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Table_Udf"          pos="7"     access="rc" rst="0">
            <comment>The Gain Table underflow status.
                <br/> 1 = a next gain request has been received while the read pointer was already at the top of the table.
                <br/> Writing a '1' clear the underflow status.
            </comment>
        </bits>
        <bits name="Cmd_Level"          pos="CMD_FIFO_LEN_BITS+7:8" access="r" rst="0">
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Command FIFO level, number of command in the FIFO
            </comment>
        </bits>
        <bits name="Cmd_Ovf"            pos="14"    access="rc" rst="0">
            <comment>The command FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Cmd_Udf"            pos="15"    access="rc" rst="0">
            <comment>The command FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
        <bits name="Cmd_Data_Level"     pos="CMD_DATA_FIFO_LEN_BITS+16:16"  access="r" rst="0">
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Command FIFO level, number of bytes in the FIFO
            </comment>
        </bits>
        <bits name="Cmd_Data_Ovf"       pos="22"    access="rc" rst="0">
            <comment>The command data FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Cmd_Data_Udf"       pos="23"    access="rc" rst="0">
            <comment>The command data FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
        <bits name="Rx_Level"           pos="RX_DATA_FIFO_LEN_BITS+24:24"   access="r" rst="0">
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Receive FIFO level, number of bytes in the FIFO
            </comment>
        </bits>
        <bits name="Rx_Ovf"             pos="30"    access="rc" rst="0">
            <comment>The receive FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Rx_Udf"             pos="31"    access="rc" rst="0">
            <comment>The receive FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
    </reg>
    <reg name="Rx_Data" protect="">
        <bits name="Rx_Data"    pos="7:0"   access="rw"  rst="no">
            <comment>Read in the receive FIFO
                <br/>Writing this register will write to Cmd_Data fifo (same as Cmd_Data register). This is because this address is used by the IFC channels to access the fifos.
            </comment>
        </bits>
    </reg>
    <reg name="Command" protect="w">
        <bits name="Send_Cmd"           pos="0"     access="w">
            <comment> Writing 1 send the next command in the Cmd FIFO (This replace the TCU next cmd signal)
            </comment>
        </bits>
        <bits name="Flush_Cmd_FIFO"     pos="8"     access="w">
            <comment>Writing 1 flush both Cmd, and cmd_data FIFO, <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name="Flush_Rx_FIFO"      pos="16"    access="w">
            <comment>Writing 1 flush the receive data FIFO, <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name="Restart_Gain"       pos="24"    access="w">
            <comment>Writing 1 place the read pointer at the beginning of the gain table. <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name="Reload_Gain"        pos="28"    access="w">
            <comment>Writing 1 place the write pointer at the beginning of the gain table allowing to fill the table.
            </comment>
        </bits>
        <bits name="Drive_Zero"         pos="31"    access="rw" rst="1">
            <comment>Writing 1 change all the ouputs of the SPI interface to drive a logical '0'. This mode stops when a new command is requested to be send (by TCU) or when writting 0 to this register. This mode is useful when powering off the tranciever chip connected to the RF_SPI.
            </comment>
        </bits>
    </reg>
    <reg name="Cmd_Size" protect="w">
        <bits name="Cmd_Size"    pos="CMD_SIZE_BITS-1:0"   access="w"  rst="no">
            <comment>Write the size in bytes of the next command in the FIFO
            </comment>
        </bits>
        <bits name="Cmd_Mark"   pos="31"    access="w"  rst="no">
            <comment>Write 1 to mark the command.
                <br/>Marked commands are discarded if Enable_Rf_Spi_Marked_Cmd is low in the tcu register.
            </comment>
        </bits>
    </reg>
    <reg name="Cmd_Data" protect="w">
        <bits name="Cmd_Data"    pos="7:0"   access="w"  rst="no">
            <comment>Write in the Command data FIFO
            </comment>
        </bits>
    </reg>
    <reg name="Gain_Size" protect="rw">
        <bits name="Gain_Size"   pos="GAIN_SIZE_BITS-1:0"   access="rw"  rst="0">
            <comment>Size of a Gain command in bytes.
            </comment>
        </bits>
    </reg>
    <reg name="Gain_Data" protect="w">
        <bits name="Gain_Data"   pos="7:0"   access="w"  rst="no">
            <comment>Write in the Gain Table (the pointer auto increments)
            </comment>
        </bits>
    </reg>
    <reg name="IRQ" protect="rw">
        <bits name="Cmd_Data_DMA_Done_Cause"    pos="0" access="rc" rst="0">
            <comment>Cmd_Data_DMA_Done IRQ Cause bit
                <br/> 1 = the IRQ was triggered by the end of the DMA transfer to the cmd FIFO.
                <br/> To clear it write 1 in this bit or Cmd_Data_DMA_Done_Status bit.
            </comment>
        </bits>
        <bits name="Cmd_FIFO_empty_Cause"       pos="2" access="r" rst="0">
            <comment>Cmd_FIFO_empty IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Cmd_FIFO is empty.
                <br/> To clear it, fill the FIFO.
            </comment>
        </bits>
        <bits name="Cmd_Threshold_Cause"        pos="3" access="r" rst="0">
            <comment>Cmd_Threshold IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Cmd_FIFO level is below the Cmd_Threshold.
                <br/> To clear it, fill the FIFO.
            </comment>
        </bits>
        <bits name="Rx_FIFO_full_Cause"         pos="4" access="r" rst="0">
            <comment>Rx_FIFO_full IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Rx_Data_FIFO is full.
                <br/> To clear it, read from the FIFO.
            </comment>
        </bits>
        <bits name="Rx_Threshold_Cause"         pos="5" access="r" rst="0">
            <comment>Rx_Threshold IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Rx_Data_FIFO level is over the Rx_Threshold.
                <br/> To clear it, read from the FIFO.
            </comment>
        </bits>
        <bits name="Error_Cause"                pos="6" access="r" rst="0">
            <comment>Error IRQ Cause bit
                <br/> 1 = the IRQ was triggered because an error occured. Read the Status register to check the kind of error.
                <br/> To clear it, clear it in the Status register.
            </comment>
        </bits>
        <bitgroup name="All_Cause">
            <entry ref="Cmd_Data_DMA_Done_Cause"/>
            <entry ref="Cmd_FIFO_empty_Cause"/>
            <entry ref="Cmd_Threshold_Cause"/>
            <entry ref="Rx_FIFO_full_Cause"/>
            <entry ref="Rx_Threshold_Cause"/>
            <entry ref="Error_Cause"/>
        </bitgroup>
        <bits name="Cmd_Data_DMA_Done_Status"   pos="16"    access="rc" rst="0">
            <comment>Cmd_Data_DMA_Done IRQ Status bit
                <br/> 1 = the end of the DMA transfer to the cmd FIFO occured.
                <br/> To clear it write 1 in this bit or Cmd_Data_DMA_Done_Cause bit.
            </comment>
        </bits>
        <bits name="Cmd_FIFO_empty_Status"      pos="18"    access="r" rst="0">
            <comment>Cmd_FIFO_empty IRQ Status bit
                <br/> 1 = the Cmd_FIFO is empty.
            </comment>
        </bits>
        <bits name="Cmd_Threshold_Status"       pos="19"    access="r" rst="0">
            <comment>Cmd_Threshold IRQ Status bit
                <br/> 1 = the Cmd_FIFO level is bellow the Cmd_Threshold.
            </comment>
        </bits>
        <bits name="Rx_FIFO_full_Status"        pos="20"    access="r" rst="0">
            <comment>Rx_FIFO_full IRQ Status bit
                <br/> 1 = the Rx_Data_FIFO is full.
            </comment>
        </bits>
        <bits name="Rx_Threshold_Status"        pos="21"    access="r" rst="0">
            <comment>Rx_Threshold IRQ Status bit
                <br/> 1 = the Rx_Data_FIFO level is over the Rx_Threshold.
            </comment>
        </bits>
        <bits name="Error_Status"               pos="22"    access="r" rst="0">
            <comment>Error IRQ Status bit
                <br/> 1 = an error occured. Read the Status register to check the kind of error.
            </comment>
        </bits>
        <bitgroup name="All_Status">
            <entry ref="Cmd_Data_DMA_Done_Status"/>
            <entry ref="Cmd_FIFO_empty_Status"/>
            <entry ref="Cmd_Threshold_Status"/>
            <entry ref="Rx_FIFO_full_Status"/>
            <entry ref="Rx_Threshold_Status"/>
            <entry ref="Error_Status"/>
        </bitgroup>
    </reg>
    <reg name="IRQ_Mask" protect="rw">
        <bits name="Cmd_Data_DMA_Done_Mask"     pos="0" access="rw" rst="0">
            <comment>Cmd_Data_DMA_Done IRQ Mask bit
                <br/> 1 = the Cmd_Data_DMA_Done IRQ is enabled
                <br/> 0 = the Cmd_Data_DMA_Done IRQ is disabled
            </comment>
        </bits>
        <bits name="Cmd_FIFO_empty_Mask"        pos="2" access="rw" rst="0">
            <comment>Cmd_FIFO_empty IRQ Mask bit
                <br/> 1 = the Cmd_FIFO_empty IRQ is enabled
                <br/> 0 = the Cmd_FIFO_empty IRQ is disabled
            </comment>
        </bits>
        <bits name="Cmd_Threshold_Mask"         pos="3" access="rw" rst="0">
            <comment>Cmd_Threshold IRQ Mask bit
                <br/> 1 = the Cmd_Threshold IRQ is enabled
                <br/> 0 = the Cmd_Threshold IRQ is disabled
            </comment>
        </bits>
        <bits name="Rx_FIFO_full_Mask"          pos="4" access="rw" rst="0">
            <comment>Rx_FIFO_full IRQ Mask bit
                <br/> 1 = the Rx_FIFO_full IRQ is enabled
                <br/> 0 = the Rx_FIFO_full IRQ is disabled
            </comment>
        </bits>
        <bits name="Rx_Threshold_Mask"          pos="5" access="rw" rst="0">
            <comment>Rx_Threshold IRQ Mask bit
                <br/> 1 = the Rx_Threshold IRQ is enabled
                <br/> 0 = the Rx_Threshold IRQ is disabled
            </comment>
        </bits>
        <bits name="Error_Mask"                 pos="6" access="rw" rst="0">
            <comment>Error IRQ Mask bit
                <br/> 1 = the Error IRQ is enabled
                <br/> 0 = the Error IRQ is disabled
            </comment>
        </bits>
        <bitgroup name="All_Mask">
            <entry ref="Cmd_Data_DMA_Done_Mask"/>
            <entry ref="Cmd_FIFO_empty_Mask"/>
            <entry ref="Cmd_Threshold_Mask"/>
            <entry ref="Rx_FIFO_full_Mask"/>
            <entry ref="Rx_Threshold_Mask"/>
            <entry ref="Error_Mask"/>
        </bitgroup>
    </reg>
    <reg name="IRQ_Threshold" protect="rw">
        <bits name="Cmd_Threshold"      pos="CMD_FIFO_LEN_BITS+7:8" access="r" rst="all1">
            <comment>Command FIFO Threshold, number of command in the FIFO bellow which the Cmd_Threshold_IRQ is triggered.
            </comment>
        </bits>
        <bits name="Rx_Threshold"       pos="RX_DATA_FIFO_LEN_BITS+23:24"   access="r" rst="all1">
            <comment>Receive FIFO Threshold, number of bytes in the FIFO above which the Rx_Threshold_IRQ is triggered.
            </comment>
        </bits>
    </reg>
    <reg name="Divider" protect="rw">
        <bits name="Divider"    pos="6:1"   access="rw" rst="0">
            <comment>Clock Divider
                <br/>The state machine clock is generated by dividing the system clock by the value of this register + 1. So the output clock is divided by (register + 1)*2
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Clock_Limiter" pos="28" access="rw" rst="0">
            <comment>When enabled the clock input to the divider is not the system clock, but a limited version of it: It cannot be above 52MHz, so the output clock will never be above 26MHz.
                <br/> for system clock of 104Mhz the clock input to the divider is 52Mhz, for system clock of 78Mhz the clock input to the divider is 39Mhz, for lower system clock value, the input to the divider is the system clock.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
</module>
</archive>
<archive relative='sci.xml' >

<module name="sci" category="Modem">
    <reg name="Config" protect="rw">
        <bits name="Enable" pos="0" access="rw" rst="0">
            <comment>Enables the SIM Card IF module
            </comment>
        </bits>
        <bits name="Parity" pos="1" access="rw" rst="0">
            <comment>Selects the parity generation/detection
            </comment>
            <options>
                <option value="0" name="Even_parity"/>
                <option value="1" name="Odd_parity"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="PERF" pos="2" access="rw" rst="0">
            <comment>Parity Error Receive Feed-through
                <br/>0 = Don't store bytes with detected parity errors
                <br/>1 = Feed-through bytes with detected parity errors
            </comment>
        </bits>
        <bits name="Filter_Disable" pos="3" access="rw" rst="0">
            <comment>Enable or disable NULL (0x60) character filtering when SIM card sends NULL to reset WWT timer.
                <br/>0 = Enable NULL character filtering, NULL characters are not reported if not data.
                <br/>1 = Disable NULL character filtering.  NULL characters (0x60) are transferred to the SCI data buffer.
            </comment>
        </bits>
        <bits name="ClockStop" pos="4" access="rw" rst="1">
            <comment>Manual SCI Clock Stop control.  Manually starts and stops the SCI clock.  This bit must be set to '1' when Autostop mode is enabled.
                <br/>0 = Enable the SCI clock
                <br/>1 = Disable SCI clock
            </comment>
        </bits>
        <bits name="AutoStop_En_H" pos="5" access="rw" rst="0">
            <comment>Enables automatic clock shutdown when command is complete.  Enabling this will generate the necessary startup and shutdown delays required by the SIM protocol.
                <br/>0 = Auto clock control not enabled.  SCI clock controlled by SCI_Clockstop bit
                <br/>1 = Auto clock control enabled.
            </comment>
        </bits>
        <bits name="MSBH_LSBL" pos="6" access="rw" rst="1">
            <comment>Sets the transmission and reception bit order:
                <br/>0 = LSB is sent/recieved first (Direct convention)
                <br/>1 = MSB is sent/received first (Inverse convention)
            </comment>
        </bits>
        <bits name="LLI" pos="7" access="rw" rst="1">
            <comment>Logic Level Invert:
                <br/>0 = Logic level 0 data is sent/received as '0' or 'A' which is the same as the start bit.  (Direct convention)
                <br/>1 = Logic level 0 data is sent/received as '1' or 'Z' which is the opposite of the start bit.  (Inverse convention)
            </comment>
        </bits>
        <bits name="PEGen_Len" pos="8" access="rw" rst="0">
            <comment>Parity Error signal length.  This configuration bit can be used to extend the duration of the parity error signal generation from 1 ETU to 1.5 ETU
                <br/>0 = Parity Error signal duration is 1 ETU starting at 10.5 ETU
                <br/>1 = Parity Error signal duration is 1.5 ETU starting at 10.5 ETU
            </comment>
        </bits>
        <bits name="Parity_En" pos="9" access="rw" rst="0">
            <comment>Enable or disable parity error checking on the receive data
                <br/>0 = Disable parity error checking
                <br/>1 = Enable parity error checking
            </comment>
        </bits>
        <bits name="Stop_Level" pos="10" access="rw" rst="1">
            <comment>Logical value of the clock signal when SCI clock is stopped (either due to automatic shutdown or manual shutdown)
                <br/>0 = Stop clock at low level
                <br/>1 = Stop clock at high level
            </comment>
        </bits>
        <bits name="ARG_H" pos="16" access="rw" rst="0">
            <comment>Automatic Reset Generator.  Write a '1' to this bit to initiate an automatic reset procedure on the SIM.  Write '0' to switch back to SCI_Reset control (bit 20).  An ARG interrupt will be generated if the ARG process succeeded or failed.  The ARG status bit (ARG_Det) must be read to determine if a reset response from the card was detected.  This bit needs to be cleared between ARG attempts.
            </comment>
        </bits>
        <bits name="AFD_En_H" pos="17" access="rw" rst="0">
            <comment>Automatic format detection.  This bit is generally set in conjunction with the ARG_H bit to enable automatic detection of the data convention.
                <br/>1 = Enable TS detection and automatic convention settings programming
                <br/>0 = disable automatic settings and use the register bits (MSBH_LSBL and LLI) to control the convention
            </comment>
        </bits>
        <bits name="Tx_Resend_En_H" pos="18" access="rw" rst="1">
            <comment>1 = Enable automatic resend of characters when Tx parity error is detected
                <br/>0 = Disable automatic resend
            </comment>
        </bits>
        <bits name="Reset" pos="20" access="rw" rst="0">
            <comment>Direct connection to the SIM card reset pin.  This is overridden when ARG_H is enabled
                <br/>0 = SCI_Reset low voltage
                <br/>1 = SCI Reset high voltage
            </comment>
        </bits>
        <bits name="Dly_Sel" pos="21" access="rw" rst="0">
            <comment>This selects between two delay times for the automatic clock stop startup and shutdown:
                <br/>0 = short delay
                <br/>Startup/Shutdown : 744 SCI clocks / 1860 SCI clocks
                <br/>1 = long delay
                <br/>Startup/Shutdown : (2 x 744) SCI clocks / (2 x 1860) SCI clocks
            </comment>
        </bits>
        <bits name="Par_Chk_Offset" pos="29:24" access="rw" rst="0xe">
            <comment>Allows fine control of the parity check position during the parity error time period.
            </comment>
        </bits>
        <bits name="Reserved" pos="31:30" access="rw" rst="0">
            <comment>These bits are reserved and must be written as '00' for the SCI module to work properly:
                <br/>"11" = Ser In &lt;- Ser Out loopback
                <br/>"10" = Ser In &lt;- Ser In (unmasked)
                <br/>others = Ser In &lt;- Ser In masked with Txing_H (normal mode)
            </comment>
        </bits>
    </reg>
    <reg name="Status" protect="r">
        <bits name="RxData_Rdy" pos="0" access="r">
            <comment>Returns the status of the Rx FIFO:
                <br/>0 = Rx FIFO empty
                <br/>1 = There is at least 1 character in the Rx FIFO
            </comment>
        </bits>
        <bits name="Tx_FIFO_Rdy" pos="1" access="r">
            <comment>Returns the status of the Tx FIFO:
                <br/>0 = Tx FIFO is full
                <br/>1 = There is at least 1 free spot in the Tx FIFO
            </comment>
        </bits>
        <bits name="Format_Det" pos="2" access="r">
            <comment>Returns the status of the automatic format detection after reset:
                <br/>0 = TS character has not been detected in the ATR
                <br/>1 = TS character has been detected and SCI module is using the automatic convention settings
                <br/>
                <br/>This bit is cleared when the AFD_En bit is cleared
            </comment>
        </bits>
        <bits name="ARG_Det" pos="3" access="r">
            <comment>Returns the status of the automatic reset procedure:
                <br/>0 = ARG detection has failed
                <br/>1 = ARG detection has detected that the SIM has responded to the reset
                <br/>
                <br/>This bit is used in conjunction with the ARG interrupt.  The ARG interrupt will be generated at the successful or unsuccessful termination of the ARG process.  This bit can be used to determine the success or failure.
            </comment>
        </bits>
        <bits name="Reset_Det" pos="4" access="r">
            <comment>This is the status of the Reset pin when automatic reset generation is enabled.  This bit can be used to discover whether the SIM card that has successfully responded to an ARG procedure has an active high or active low reset. (Det means 'Detection')
            </comment>
        </bits>
        <bits name="Clk_Rdy_H" pos="5" access="r">
            <comment>Status of the control signal to the clock control module.  This bit respects the startup and shutdown phases, so during these times, the clock may actually be on, but it is not considered to be 'ready'
                <br/>0 = SCI clock may be on or off but is not ready for use
                <br/>1 = SCI clock is on and ready for use
            </comment>
        </bits>
        <bits name="Clk_Off" pos="6" access="r">
            <comment>Status bit of the Sci clock. 
                <br/>0 = Sci clock is ON
                <br/>1 = Sci clock is OFF
            </comment>
        </bits>
        <bits name="Rx_Err" pos="8" access="r">
            <comment>A receive parity error was detected. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name="Tx_Err" pos="9" access="r">
            <comment>A transmit parity error was detected. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name="RxOverflow" pos="10" access="r">
            <comment>The internal receive FIFO has reached an overflow condition. Reading this register clears the bit.
            </comment>
        </bits> 
        <bits name="TxOverflow" pos="11" access="r">
            <comment>The internal transmit FIFO has reached an overflow condition. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name="AutoStop_State" pos="31:30" access="r">
            <comment>Returns the state of the clock management state machine when AutoStop mode is enabled.  This value is '00' when manual mode is selected.
            </comment>
            <options>
                <option value="0" name="Startup_phase"><comment>Clock is on, but not ready to be used.</comment></option>
                <option value="1" name="Auto_on"><comment>Clock is on and ready to be used</comment></option>
                <option value="2" name="Shutdown_phase"><comment>Clock is still on, but should not be used.</comment></option>
                <option value="3" name="Clock_off"><comment>Clock is off.</comment></option>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name="Data" protect="--">
        <bits name="Data_IN" pos="7:0" access="w">
            <comment>Writing to this register will send the data to the SIM card. If automatic clock shutdown is enabled, the appropriate delay will be applied before the data is actually sent. 
            </comment>
        </bits>
        <bits name="Data_OUT" pos="7:0" access="r">
            <comment>Reading this register will read from the receive data FIFO.
            </comment>
        </bits>
    </reg>
    <reg name="ClkDiv" protect="rw">
        <bits name="ClkDiv" pos="8:0" access="rw" rst="0x174">
            <comment>Clock divider for generating the baud clock from the SCI clock.  This value must match the value used by the SIM card whose default value is 0x174.
            </comment>
        </bits>
        <bits name="ClkDiv_16" pos="23:16" access="rw" rst="0x18">
            <comment>Secondary clock divider for generating 16x baud clock.
            </comment>
        </bits>
        <bits name="MainDiv" pos="29:24" access="rw" rst="0x4">
            <comment>Main clock divider to generate the SCI clock.  This value should be calculated as follows:
                <br/>MainDiv = Clk_Sys/(2xSCI_Clk) - 1
                <br/>where SCI_Clk is in the range of 3-5 MHz as specified in the SIM specification.
            </comment>
            <options><mask/><default/></options>
        </bits>
        <bits name="Clk_Out_Inv" pos="30" access="rw" rst="0">
            <comment>Inverts the polarity of the SCI clock to the SIM card only.
                <br/>0 = No inversion
                <br/>1 = Invert external SCI clock
            </comment>
        </bits>
        <bits name="Clk_Inv" pos="31" access="rw" rst="0">
            <comment>Inverts the polarity of the SCI clock to the SIM card and internal.
                <br/>0 = No inversion
                <br/>1 = Invert external SCI clock
            </comment>
        </bits>
    </reg>
    <reg name="RxCnt" protect="rw">
        <bits name="RxCnt" pos="9:0" access="rw" rst="0">
            <comment>This value should be programmed with the number of expected characters to receive.  It will be decremented each time a character is <strong>actually</strong> received and should be 0 when the transfer is complete.  If a character is sent after the RxCnt reaches zero, the extra character flag will be set but this value will stay at zero.
            </comment>
        </bits>
        <bits name="Clk_Persist" pos="31" access="rw" rst="0">
            <comment>When in automatic clock shutdown mode, this bit can prevent the clock from entering shutdown mode when the transfer is complete.  This should be used for multi-transfer commands where the clock must not be shut down until the command is complete.  This bit must be programmed for each transfer.
                <br/>1 = Keep clock on
                <br/>0 = Allow clock shutdown when transfer is complete
            </comment>
        </bits>
    </reg>
    <reg name="Times" protect="rw">
        <bits name="ChGuard" pos="7:0" access="rw" rst="1">
            <comment>This is the extra guard time that can be added to the 2 ETU minimum (and default) guard time between successive transmitted characters.  This should be programmed depending on the SIM's ATR.  The total ETU guard time will be ChGuard + 1.
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="TurnaroundGuard" pos="11:8" access="rw" rst="0x6">
            <comment>Turnaround guard time configuration.  This value can be used to adjust the delay between the leading edge of a received character and the leading edge of the next transmitted character.  The minimum time specified in the SIM recommendation is 16 ETU.  The number of ETUs can be calculated using the following formula:
                <br/>Total Turnaround Time (in ETUs) = 11 + TurnaroundGuard
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="WI" pos="23:16" access="rw" rst="0x0A">
            <comment>Work Waiting Time factor.  A timeout will be generated when the WWT is exceeded.  The WWT is calculated by:
                <br/>       WWT = 960 x WI x (F/Fi)
                <br/>where Fi is the main SCI clock frequency (3-5 MHz) and F is 372 before an enhanced PPS and 512 after an enhanced PPS.
                <br/>The SCI_WI value must be calculated as follows:
                <br/>       SCI_WI = WI * D
                <br/>Thus, by default (WI = 10) this value needs to be set to 10 before an EPPS, but needs to be scaled to WI*D=80 after the EPPS procedure.
            
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="Tx_PERT" pos="31:24" access="rw" rst="0xFF">
            <comment>Number of times to try resending character when the SIM indicates a parity error.
            </comment>
        </bits>
    </reg>  
    <reg name="Ch_Filt" protect="rw">
        <bits name="Ch_Filt" pos="7:0" access="rw" rst="0x60">
            <comment>Value of the character to be filtered.  0x60 is the NULL character in the SIM protocol.  If character filtering is enabled, the <strong>first</strong> 0x60 character that is received by the SIM during a transfer will <strong>not</strong> be recorded.  The purpose of this character is to enable the SIM to reset the WWT counter when the SIM is not ready to send the data.  This filter has no effect on characters within the datastream.
            </comment>
        </bits>
    </reg>  
    
    <reg name="dbg" protect="rw">
        <comment>UNDOCUMENTED FEATURE</comment>
    </reg>  
    <reg name="Int_Cause" protect="r">
        <bits name="Rx_Done" pos="0" access="r" rst="0">
            <comment>Number of expected Rx characters, as programmed in the RxCnt register, has been received.
            </comment>
        </bits>
        <bits name="Rx_Half" pos="1" access="r" rst="0">
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name="WWT_Timeout" pos="2" access="r" rst="0">
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name="Extra_Rx" pos="3" access="r" rst="0">
            <comment>An extra character has been received after the number of characters in RxCnt has been received.
            </comment>
        </bits>
        <bits name="Resend_Ovfl" pos="4" access="r" rst="0">
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the Tx_PERT field.
            </comment>
        </bits>     
        <bits name="ARG_End" pos="5" access="r" rst="0">
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>     
        <comment>
            This register is a <b>READ ONLY</b> register that returns the logical <b>and</b> of the SCI_INT_STATUS register and the SCI_INT_MASK. If any of these bits is '1', the SCI module will generate an interrupt.  Bits 21:16 return the <u>status</u> of the interrupt which is the interrupt state before the mask is applied.  These bits should only be used for debugging.
        </comment>
    </reg>  
    <reg name="Int_Clr" protect="w">
        <bits name="Rx_Done" pos="0" access="c">
            <comment>Number of expected Rx characters, as programmed in the SCI_RxCnt register, has been received.
            </comment>
        </bits>
        <bits name="Rx_Half" pos="1" access="c">
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name="WWT_Timeout" pos="2" access="c">
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name="Extra_Rx" pos="3" access="c">
            <comment>An extra character has been received after the number of characters in SCI_RxCnt has been received.
            </comment>
        </bits>
        <bits name="Resend_Ovfl" pos="4" access="c">
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the SCI_Tx_PERT field.
            </comment>
        </bits>     
        <bits name="ARG_End" pos="5" access="c">
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>     
        <comment>
            This is a WRITE ONLY register that is used to clear an SCI interrupt. Write a '1' to the interrupt that is to be cleared. Writing '0' has no effect.
        </comment>
    </reg>  
    <reg name="Int_Mask" protect="rw">
        <bits name="Rx_Done" pos="0" access="rw" rst="0">
            <comment>Number of expected Rx characters, as programmed in the SCI_RxCnt register, has been received.
            </comment>
        </bits>
        <bits name="Rx_Half" pos="1" access="rw" rst="0">
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name="WWT_Timeout" pos="2" access="rw" rst="0">
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name="Extra_Rx" pos="3" access="rw" rst="0">
            <comment>An extra character has been received after the number of characters in SCI_RxCnt has been received.
            </comment>
        </bits>
        <bits name="Resend_Ovfl" pos="4" access="rw" rst="0">
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the SCI_Tx_PERT field.
            </comment>
        </bits>     
        <bits name="ARG_End" pos="5" access="rw" rst="0">
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>     
        <comment>
            This register is READ/WRITE register that enables the desired interrupt. A '1' in a bit position indicates that the corresponding interrupt is enabled and if the interrupt occurs, the SCI will generate a hardware interrupt.
        </comment>
    </reg>  
</module>
</archive>
<archive relative='spi.xml' >

<var name = "SPI_TX_FIFO_SIZE" value="16"/>
<var name = "SPI_RX_FIFO_SIZE" value="16"/>

<module name="spi" category="Periph">
    <reg name="ctrl" protect="rw">
        <bits name="Enable"  pos="0" access="rw">
            <comment>Enable the module and activate the chip select selected by CS_sel field.
            </comment>
        </bits>
        <bits name="CS_sel" pos="1:2" access="rw">
            <comment>Selects the active CS.
            </comment>
            <options>
                <option name="CS0" value="0"/>
                <option name="CS1" value="1"/>
                <option name="CS2" value="2"/>
                <option name="CS3" value="3"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="Input_mode" pos="4" access="rw"  rst="1">
            <comment>When set to 1 the inputs are activated, else only the output is driven and no data are stored in the receive FIFO.
                <br/>Notes: The Input_mode bit status is also readable onto the bit rxtx_buffer[31].
            </comment>
        </bits>
        <bits name="Clock_Polarity" pos="5" access="rw" rst="1">
            <comment>The spi clock polarity
                <br/>when '0' the clock disabled level is low, and the first edge is a rising edge.
                <br/>When '1' the clock disabled level is high, and the first edge is a falling edge.
            </comment>
        </bits>
        <bits name="Clock_Delay" pos="7:6" access="rw" rst="3">
            <comment>Transfer start to first edge delay value from 0 to 2 is the number of spi clock half period between the CS activation and the first clock edge.
            </comment>
        </bits>
        <bits name="DO_Delay" pos="9:8" access="rw" rst="3">
            <comment>Transfer start to first data out delay value from 0 to 2 is the number of spi clock half period between the CS activation and the first data out
            </comment>
        </bits>
        <bits name="DI_Delay" pos="11:10" access="rw" rst="3">
            <comment>Transfer start to first data in sample delay value from 0 to 3 is the number of spi clock half period between the CS activation and the first data in sampled.
                <br/>NOTE: DI_Delay must be less or equal to DO_Delay + CS_Delay + 2.
                <br/>In other words DI_Delay can be 3 only if DO_Delay and CS_Delay are not both equal to 0.
            </comment>
        </bits>
        <bits name="CS_Delay" pos="13:12" access="rw" rst="3">
            <comment>Transfer end to chip select deactivation delay value from 0 to 3 is the number of spi clock half period between the end of transfer and CS deactivation
            </comment>
        </bits>
        <bits name="CS_Pulse" pos="15:14" access="rw" rst="3">
            <comment>Chip select deactivation to reactivation minimum delay value from 0 to 3 is the number of spi clock half period between the CS deactivation and a new CS activation (CS will activate only if more data are available in the transmit FIFO)
            </comment>
        </bits>
        <bits name="Frame_Size" pos="20:16" access="rw" rst="31">
            <comment>Frame Size
                <br/>The frame size is the binary value of this register + 1 valid value are 3 to 31 (frame size 4 to 32bits)
            </comment>
        </bits>
        <bits name="tx_Sw_Shift" pos="21" access="rw" rst="0">
            <comment>If FIFO_DATA_SIZE=16 and frame size less than 16, TX FIFO data can be shift by hardware auto
                <br/>If frame size more than 16, must be software shift.
                <br/>if 1: Software shift
                <br/>if 0: Hardware shift
            </comment>
        </bits>
        <bits name="OE_delay" pos="28:24" access="rw" rst="31">
            <comment>OE delay
                <br/>When 0: regular mode, SPI_DO pin as output only.
                <br/>Value from 1 to 31 is the number of data out to transfert before the SPI_DO pin switch to input.
            </comment>
        </bits>
        <bits name="ctrl_data_mux_sel" pos="29" access="rw">
            <comment>Selects the active CS and Input_reg either from the ctrl or rxtx_buffer register.
                <br/>If SPI FIFO 8b or 32b, when set to "0": CS from CS_sel and INPUT from Input_mode in the register ctrl.
                <br/>Only if SPI FIFO 32b, when set to "1": CS and INPUT from SPI DATA.(Do not work for FIFO8b)
            </comment>
            <options>
                <option name="Ctrl_reg_sel"  value="0"/>
                <option name="Data_reg_sel"  value="1"/>
                <default/><shift/><mask/>
            </options>            
        </bits>
        
        <bits name="Input_sel" pos="31:30" access="rw">
            <comment>Selects the input line to be used as SPI data in.(Not used for SPI3)
                <br/>when "00" the SPI_DI_0 is used.
                <br/>When "01" the SPI_DI_1 is used.
                <br/>When "10" the SPI_DI_2 is used. 
                <br/>When "11" reserved.
            </comment>
        </bits>
        
    </reg>
        
    <reg name="status" protect="rw">

        <bits name="Active_Status" pos="0" access="r">
            <comment>'1' when a transfer is in progress.
            </comment>
        </bits>
        <bits name="Cause_Rx_Ovf_Irq" pos="3" access="rw">
            <comment>The receive FIFO overflow irq cause.
                <br/>Writing a '1' clear the receive overflow status and cause.
            </comment>
        </bits>
        <bits name="Cause_Tx_Th_Irq" pos="4" access="r">
            <comment>The transmit FIFO threshold irq cause.
            </comment>
        </bits>
        <bits name="Cause_Tx_Dma_Irq" pos="5" access="rw">
            <comment>The transmit Dma Done irq cause.
                <br/>Writing a '1' clear the transmit Dma Done status and cause.
            </comment>
        </bits>
        <bits name="Cause_Rx_Th_Irq" pos="6" access="r">
            <comment>The receive FIFO threshold irq cause.
            </comment>
        </bits>
        <bits name="Cause_Rx_Dma_Irq" pos="7" access="rw">
            <comment>The receive Dma Done irq cause.
                <br/>Writing a '1' clear the receive Dma Done status and cause.
            </comment>
        </bits>
        <bitgroup name="Irq_Cause">
            <entry ref="Cause_Rx_Ovf_Irq"/>
            <entry ref="Cause_Tx_Th_Irq"/>
            <entry ref="Cause_Tx_Dma_Irq"/>
            <entry ref="Cause_Rx_Th_Irq"/>
            <entry ref="Cause_Rx_Dma_Irq"/>
        </bitgroup>
        <bits name="Tx_Ovf" pos="9" access="rw">
            <comment>The transmit FIFO overflow status.
                <br/>Writing a '1' clear the transmit overflow status and cause.
            </comment>
        </bits>
        <bits name="Rx_Udf" pos="10" access="rw">
            <comment>The receive FIFO underflow status.
                <br/>Writing a '1' clear the receive underflow status and cause.
            </comment>
        </bits>
        <bits name="Rx_Ovf" pos="11" access="rw">
            <comment>The receive FIFO overflow status.
                <br/>Writing a '1' clear the receive overflow status and cause.
            </comment>
        </bits> 
        <bits name="Tx_Th" pos="12" access="r">
            <comment>The transmit FIFO threshold status.
            </comment>
        </bits> 
        <bits name="Tx_Dma_Done" pos="13" access="rw">
            <comment>The transmit Dma Done status.
                <br/>Writing a '1' clear the transmit Dma Done status and cause.
            </comment>
        </bits> 
        <bits name="Rx_Th" pos="14" access="r">
            <comment>The receive FIFO threshold status.
            </comment>
        </bits> 
        <bits name="Rx_Dma_Done" pos="15" access="rw">
            <comment>The receive Dma Done status.
                <br/>Writing a '1' clear the receive Dma Done status and cause.
            </comment>
        </bits> 
        <bits name="Tx_Space" pos="20:16" access="r" rst="16">
            <comment>Transmit FIFO Space
                <br/>Number of empty spot in the FIFO
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits> 
        <bits name="Rx_Level" pos="28:24" access="r">
            <comment>Receive FIFO level
                <br/>Number of DATA in the FIFO
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits> 
        <bits name="FIFO_Flush" pos="30" access="w">
            <comment>Writing '1' flush both FIFO, don't do it when SPI is active (transfer in progress)
            </comment>
        </bits>
    </reg>
    <reg name="rxtx_buffer" protect="--">
        <comment>Spi1 fifo size (rxtx_buffer): 8bits.<br/>
                 Spi2 fifo size (rxtx_buffer): 8bits.<br/>
                 Spi3 fifo size (rxtx_buffer): 32bits.<br/>
            <table border="1"> 
          <caption><big>32b FIFO only </big></caption>
<tr><th>rxtx_buffer: </th><th>Range [31]</th><th>Range [30:29]</th><th>Range [28:26]</th><th>Range [25]</th><th>Range [24:16]</th><th>Range [15:0]</th></tr>
<tr><td>DATA_IN: </td><td>READ_ENA</td><td>CS</td><td></td><td>R/W</td><td>ADDRESS</td><td>DATA</td></tr>
<tr><td>DATA_OUT: </td><td>READ_ENA</td><td>CS</td><td></td><td>R/W</td><td>ADDRESS</td><td>DATA</td></tr>
            </table>
        </comment>
        <bits name="DATA_IN" pos="31:0" access="w">
            <comment>Write to the transmit FIFO
            </comment>
        </bits>
        
        <bits name="DATA_OUT" pos="31:0" access="r">
            <comment>Read in the receive FIFO.
            </comment>
        </bits>
        
        <bits name="CS" pos="30:29" access="w">
            <comment>
                Chip Select on which write the data written in the
                Fifo.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

        <bits name="READ_ENA" pos="31" access="w">
            <comment>
                Set this bit to one when the data received while sending
                this peculiar data are expected to be kept in the FIFO,
                otherwise no data is recorded in the FIFO.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

    </reg>
    <reg name="cfg" protect="rw">
        <bits name="CS_Polarity" pos="3:0" access="rw" rst="all1" cut="1" cutprefix="CS_Polarity">
            <comment>Chip select polarity
            </comment>
            <options>
                <option name="active high" value="0"><comment>chip select is active high</comment></option>
                <option name="active low" value="1"><comment>chip select is active low</comment></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="Clock_Divider" pos="25:16" access="rw" rst="1023">
            <comment>Clock Divider
                <br/>The state machine clock is generated by dividing the system clock by the value of this register + 1.
                <br/>So the output clock is divided by (register + 1)*2
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Clock_Limiter" pos="28" access="rw" rst="0">
            <comment>When enabled the clock input to the divider is not the system clock, but a limited version of it: It cannot be above 52MHz, so the output clock will never be above 26MHz.
                <br/> for system clock of 104Mhz the clock input to the divider is 52Mhz, for system clock of 78Mhz the clock input to the divider is 39Mhz, for lower system clock value, the input to the divider is the system clock.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

    </reg>

    <reg name="pattern" protect="rw">
        <bits name="pattern" pos="7:0" access="rw">
            <comment>MMC Pattern value for RX pattern match mode.
            </comment>
        </bits>
        <bits name="pattern_mode" pos="8" access="rw" rst="0">
            <comment> Enable the pattern mode.
            </comment>
            <options>
                <option name="disabled" value="0"><comment>Spi Behaviour.</comment></option>
                <option name="enabled" value="1"><comment>Pattern matching.</comment></option>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="pattern_selector" pos="9" access="rw" rst="0">
            <comment> Select the RX pattern matching mode when the pattern_mode is enabled( set 1). Used for SD/MMC SPI mode.</comment>
            <options>
                <option name="UNTIL" value="0"><comment>No datas are written into the RX FIFO UNTIL the received data is equal to the pattern.</comment></option>
                <option name="WHILE" value="1"><comment>No datas are written into the RX FIFO WHILE the received data is equal to the pattern.</comment></option>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>
    
    <reg name="stream" protect="rw">
        <bits name="tx_stream_bit" pos="0" access="rw" rst="0">
            <comment>When TX stream mode is enabled, once the TX fifo is empty, all new bits send have the value of this bit.
            </comment>
            <options>
                <option name="zero" value="0"/>
                <option name="one" value="1"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="tx_stream_mode" pos="8" access="rw" rst="0">
            <comment>Enable the TX stream mode. Used for SD/MMC SPI mode.
                <br/>When enabled, this mode provide infinite bit stream for sending, after fifo is empty the extra bits generated all have the same value. The value is in tx_stream_bit.
            </comment>    
            <options>
                <option name="disabled" value="0"/>
                <option name="enabled" value="1"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="tx_stream_stop_with_rx_dma_done" pos="16" access="rw" rst="0">
            <comment>Allow to automatically clear the tx_stream_mode when Rx_Dma_Done is set.
            </comment>    
            <options>
                <option name="disabled" value="0"/>
                <option name="enabled" value="1"/>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>
    <reg name="pin_control" protect="rw">
        <bits name="clk_ctrl" pos="1:0" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_Clk pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_Clk pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_Clk pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_Clk pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="do_ctrl" pos="2:3" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_DO pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_DO pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_DO pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_DO pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>            
        </bits>
        <bits name="cs0_ctrl" pos="4:5" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_CSO pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_CSO pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_CSO pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_CSO pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>               
        </bits>        
        <bits name="cs1_ctrl" pos="6:7" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_CS1 pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_CS1 pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_CS1 pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_CS1 pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>   
        </bits>
        <bits name="cs2_ctrl" pos="8:9" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_CS2 pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_CS2 pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_CS2 pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_CS2 pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>   
        </bits> 
        <bits name="cs3_ctrl" pos="10:11" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_CS3 pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_CS3 pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_CS3 pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_CS3 pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>   
        </bits> 
    </reg>
    <reg name="irq" protect="rw">
        <bits name="Mask_Rx_ovf_Irq" pos="0" access="rw">
            <comment>Mask the receive FIFO overflow irq
            </comment>
        </bits>
        <bits name="Mask_Tx_Th_Irq" pos="1" access="rw">
            <comment>Mask the transmit FIFO threshold irq
            </comment>
        </bits>
        <bits name="Mask_Tx_Dma_Irq" pos="2" access="rw">
            <comment>Mask the transmit Dma Done irq
            </comment>
        </bits>
        <bits name="Mask_Rx_Th_Irq" pos="3" access="rw">
            <comment>Mask the receive FIFO threshold irq
            </comment>
        </bits>
        <bits name="Mask_Rx_Dma_Irq" pos="4" access="rw">
            <comment>Mask the receive DMA Done irq
            </comment>
        </bits>
        <bitgroup name="Irq_Mask">
            <entry ref="Mask_Rx_ovf_Irq"/>
            <entry ref="Mask_Tx_Th_Irq"/>
            <entry ref="Mask_Tx_Dma_Irq"/>
            <entry ref="Mask_Rx_Th_Irq"/>
            <entry ref="Mask_Rx_Dma_Irq"/>
        </bitgroup>
        <bits name="Tx_Threshold" pos="6:5" access="rw" rst="3">
            <comment>Transmit FIFO threshold this threshold is used to generate the irq.
            </comment>
            <options>
                <option name="1 Empty Slot" value="0"/>
                <option name="4 Empty Slots" value="1"/>
                <option name="8 Empty Slots" value="2"/>
                <option name="12 Empty Slots" value="3"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="Rx_Threshold" pos="8:7" access="rw" rst="3">
            <comment>Receive FIFO threshold this threshold is used to generate the irq.
            </comment>
            <options>
                <option name="1 Valid Data" value="0"/>
                <option name="4 Valid Data" value="1"/>
                <option name="8 Valid Data" value="2"/>
                <option name="12 Valid Data" value="3"/>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>

</module>
</archive>
<archive relative='sys_ahb_monitor.xml' >

<module name="sys_ahb_monitor" category="Debug">
    <reg name="Control" protect="rw">
        <bits name="Enable" pos="0" access="rw" rst="0">
            <comment>Enable (start) the Monitor.
            </comment>
        </bits>
        <bits name="Record" pos="4" access="rw" rst="1">
            <options>
                <option name="Single_Shot" value="0"><comment>Monitor disable itself after the time window expires.</comment></option>
                <option name="Multi_Shot" value="1"/>
            </options>
        </bits>
        <bits name="Accumulation_Mode" pos="5" access="rw" rst="1">
            <options>
                <option name="Mean" value="0"><comment>get use counter value in the read register, sum the latency and count the number of access</comment></option>
                <option name="Max" value="1"><comment>get maximum of use counter and read register per time window, get maximum of latency per access.</comment></option>
            </options>
        </bits>
        <bits name="Target" pos="11:8" access="rw" rst="0">
            <comment>Define the element to monitor, it can be the BUS, a master, a slave or a special signal from Debug_Port: Signal_Select0 or Signal_Select1.</comment>
            <options>
                <option name="Sys_BUS" value="0"/>
                <option name="Sys_IFC" value="1"><comment>Masters</comment></option>
                <option name="DMA" value="2"/>
                <option name="XCPU" value="3"/>
                <option name="Sys_AHB2AHB" value="4"/>
                <option name="Sys_Mem_Ext" value="5"><comment>Slaves</comment></option>
                <option name="Sys_Mem_Int" value="6"/>
                <option name="Sys_AHB2AHB_Slave" value="7"/>
                <option name="Sys_IFC" value="8"/>
                <option name="Signal_Select0" value="10"><comment>Signal (counted as Slaves, the signal is used as a select signal)</comment></option>
                <option name="Signal_Select1" value="11"/>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="Time_Window" pos="18:16" access="rw" rst="1">
            <comment>Define the duration af a Time Window</comment>
            <options>
                <option name="TW_1kC" value="0"><comment>1024 System clock cycle</comment></option>
                <option name="TW_32kC" value="1"><comment>32768 System clock cycle</comment></option>
                <option name="TW_1MC" value="2"><comment>1048576 System clock cycle</comment></option>
                <option name="TW_16MC" value="3"><comment>16777216 System clock cycle</comment></option>
                <option name="TW_1F" value="4"><comment>1 Frame (TCU must be running)</comment></option>
                <option name="TW_26F" value="5"><comment>26 Frames (TCU must be running)</comment></option>
                <option name="TW_52F" value="6"><comment>52 Frames (TCU must be running)</comment></option>
                <option name="TW_104F" value="7"><comment>104 Frames (TCU must be running)</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name="Access_Count" protect="rw">
        <bits name="Access_Count" pos="23:0" access="r" rst="0">
            <comment>Access counter reader (full 24bits view, 8 lower bit are also readable in latency register).
                <br/>
                <br/>For masters: count the number of access
                <br/>For slaves: count the number of access by checking the falling edge of select signal.
            </comment>
        </bits>
    </reg>
    <reg name="Use" protect="rw">
        <bits name="Use" pos="23:0" access="r" rst="0">
            <comment>Bus usage counter reader.
                <br/>
                <br/>For the bus: Count the cycles when the bus is used (by any master)
                <br/>For masters: Count cycles when selected master is granted
                <br/>For slaves: Count cycles when select signal is high.
            </comment>
        </bits>
    </reg>
    <reg name="Latency" protect="rw">
        <bits name="Latency" pos="23:0" access="r" rst="0">
            <comment>Latency counter reader (0xffffff means overflow)
                <br/>In Max mode, it's updated after each access, else it's adding the latency from all access in the time window
                <br/>For slaves it counts the duration of each access (in mean mode, it will give the same value as Use)
                <br/>
                <br/>For masters: count cycles between rise of request and first access.
                <br/>For slaves: count the duration of access by counting the high cycles. In that case it is equivalent to the use counter except in max mode where it counts the max by access not by time window.
            </comment>
        </bits>
        <bits name="Access_Cnt" pos="31:24" access="r" rst="0">
            <comment>Number of access (0xff means overflow)
                <br/>In max mode: 0 if no access, 1 if at least 1 access.
                <br/>In mean mode: it counts the number of access during the time window.
                <br/>
                <br/>For masters: count the number of access
                <br/>For slaves: count the number of access by checking the falling edge of select signal.
                <br/>
                <br/>It is the same as the Access_Count register except that the value is saturated on 8 bits. It's repeated here to garanty coherence with Latency to enable calculs of Mean Latency by doing the following operation:
                <br/> Mean_Latency = Latency/Access_Cnt .
            </comment>
        </bits>
    </reg>
</module>
</archive>
<archive relative='sys_ctrl.xml' >


<include file="globals.xml"/>

<module name="sys_ctrl" category="System">
    
    <enum name="Cpu_Id">
        <entry name="XCPU"><comment>CPU IDs</comment></entry>
        <entry name="BCPU"/>
    </enum>

    
    <enum name="Sys_Clks">
    
        <entry name="SYS_XCPU"><comment>System side System clocks</comment></entry>
        <entry name="SYS_XCPU_int"/>
        <bound name="NB_SYS_CLK_XCPU"/>
        <entry name="SYS_PCLK_CONF"/>
        <entry name="SYS_PCLK_DATA"/>
        <entry name="SYS_AMBA"/>
        <entry name="SYS_DMA"/>
        <entry name="SYS_EBC"/>
        <entry name="SYS_IFC_CH0"/>
        <entry name="SYS_IFC_CH1"/>
        <entry name="SYS_IFC_CH2"/>
        <entry name="SYS_IFC_CH3"/>
        <entry name="SYS_IFC_DBG"/>
        <entry name="SYS_A2A"/>
        <entry name="SYS_AXI2AHB"/>
        <entry name="SYS_AHB2AXI"/>
        <entry name="SYS_EXT_AHB"/>
        <entry name="SYS_DEBUG_UART"/>
        <entry name="SYS_DBGHST"/>
    
        <entry name="SYSD_SCI1"><comment>System side divided clock (either divided by module or by sys_ctrl)</comment></entry>
        <entry name="SYSD_SCI2"/>
        <entry name="SYSD_SCI3"/>
        <entry name="SYSD_RF_SPI"/>
        <entry name="SYSD_OSC"/>
        <bound name="NB_SYS_CLK_AEN"/>
    
        <entry name="SYS_GPIO"><comment>the following don't have an auto enable</comment></entry>
        <entry name="SYS_IRQ"/>
        <entry name="SYS_TCU"/>
        <entry name="SYS_TIMER"/>
        <entry name="SYS_COM_REGS"/>
        <entry name="SYS_DP_AP"/>
        <bound name="NB_SYS_CLK_EN"/>
    
        <entry name="SYS_SCI1"><comment>the following are sharing their enable</comment></entry>
        <entry name="SYS_SCI2"/>
        <entry name="SYS_SCI3"/>
        <entry name="SYS_NOGATE"><comment>keep last</comment></entry>
        <bound name="NB_SYS_CLK"/>
    </enum>
    
    <enum name="Per_Clks">
    
    
        <entry name="PERD_SPI1"><comment>System side divided clock (either divided by module or by sys_ctrl)</comment></entry>
        <entry name="PERD_SPI2"><comment>System side divided clock (either divided by module or by sys_ctrl)</comment></entry>
        <bound name="NB_PER_CLK_AEN"/>
    
        <entry name="PER_SPY"/>
        <entry name="PER_TEST"/>
        <bound name="NB_PER_CLK_EN"/>
    
        <bound name="NB_PER_CLK"/>
    </enum>
    
    <enum name="BB_Clks">
    
        <entry name="BB_BCPU"><comment>Baseband side System clocks</comment></entry>
        <entry name="BB_BCPU_int"/>
        <entry name="BB_AMBA"/>
        <entry name="BB_PCLK_CONF"/>
        <entry name="BB_PCLK_DATA"/>
        <entry name="BB_EXCOR"/>
        <entry name="BB_IFC_CH2"/>
        <entry name="BB_IFC_CH3"/>
        <entry name="BB_SRAM"/>
        <entry name="BB_A2A"/>
        <entry name="BB_ITLV"/>
        <entry name="BB_VITERBI"/>
        <entry name="BB_CIPHER"/>
        <entry name="BB_RF_IF"/>
        <entry name="BB_COPRO"/>
        <entry name="BB_CP2_REG"/>
        <entry name="BB_XCOR"/>
        <entry name="BB_EVITAC"/>
    
        <bound name="NB_BB_CLK_AEN"/>
    
        <entry name="BB_IRQ"><comment>the following don't have an auto enable</comment></entry>
        <entry name="BB_COM_REGS"/>
        <entry name="BB_CORDIC"/>
        <bound name="NB_BB_CLK_EN"/>
        <bound name="NB_BB_CLK"/>
    </enum>
    
    <enum name="Other_Clks">
        
        
        
        <bound name="OC_HOST_UART"><comment>Other clocks<br/>clocks with auto enble<br/>the debug host clock auto enable is not used in host mode, only in uart mode</comment></bound>
        <entry name="OC_DEBUG_UART"/>
        <entry name="OC_RF_RX"/>
        <entry name="OC_RF_TX"/>
        <entry name="OC_MEM_BRIDGE"/>
        <bound name="NB_OTHER_CLK_AEN"/>
        
        <entry name="OC_LPS"><comment>the following don't have an auto enable</comment></entry>
        <entry name="OC_GPIO"/>
        <entry name="OC_CLK_OUT"/>
        <entry name="OC_MEM_CLK_OUT"/>
        <entry name="OC_TCU"/>
        <bound name="NB_OTHER_CLK_EN"/>
        
        <bound name="NB_OTHER_CLK"/>
    </enum>

    
    <enum name="Resets">
        
        <entry name="RST_XCPU"><comment>System side resets</comment></entry>
        <entry name="RST_SYS_IRQ"/>
        <entry name="RST_SYS_A2A"/>
        <entry name="RST_SYS_AHB2AXI"/>
        <entry name="RST_SYS_AXI2AHB"/>
        <entry name="RST_DMA"/>
        <entry name="RST_TIMER"/>
        <entry name="RST_TCU"/>
        <entry name="RST_GPIO"/>
        <entry name="RST_CFG"/>
        <entry name="RST_SPI1"/>
        <entry name="RST_SPI2"/>
        <entry name="RST_RF_SPI"/>
        <entry name="RST_SCI1"/>
        <entry name="RST_SCI2"/>
        <entry name="RST_SCI3"/>
        <entry name="RST_SPY"/>
        <entry name="RST_MEM_BRIDGE"/>
        <entry name="RST_EXT_AHB"/>
        <entry name="RST_DP_AP"/>
        <entry name="RST_COMREGS"/>
        <entry name="RST_COMREGS_AP"/>
        <entry name="RST_AP_CLKEN"/>
        <entry name="RST_AP_RST"/>
        <entry name="RST_MEM_CHK"/>
        <bound name="NB_SRST"/>
        
        <bound name="BOUND_BRST_FIRST"><comment>Baseband side resets</comment></bound>
        <entry name="RST_BCPU"/>
        <entry name="RST_BB_IRQ"/>
        <entry name="RST_BB_A2A"/>
        <entry name="RST_BB_IFC"/>
        <entry name="RST_BB_SRAM"/>
        <entry name="RST_ITLV"/>
        <entry name="RST_VITERBI"/>
        <entry name="RST_CIPHER"/>
        <entry name="RST_XCOR"/>
        <entry name="RST_COPRO"/>
        <entry name="RST_RF_IF"/>
        <entry name="RST_EXCOR"/>
        <entry name="RST_EVITAC"/>
        <entry name="RST_CORDIC"/>
        <entry name="RST_TCU_BB"/>
        <bound name="BOUND_BRST_AFTER"/>
        <entry name="RST_BB_FULL"/>
        <bound name="NR_RST_REG"><comment>The following reset does not have register</comment></bound>
        <entry name="RST_SYS_FULL"/> 
        <bound name="NB_RST"/>
    </enum>
    <var name="NB_BRST" value="BOUND_BRST_AFTER-BOUND_BRST_FIRST"/>

    
    <enum name="Reset_Others">
        <entry name="RSTO_DBG_HOST"><comment>Reset Other : resync on corresponding clock other</comment></entry>
        <bound name="BOUND_RSTO_RF_FIRST"/>
        <entry name="RSTO_RF_RX"/>
        <entry name="RSTO_RF_TX"/>
        <bound name="BOUND_RSTO_RF_AFTER"/>
        <entry name="RSTO_MEM_BRIDGE"/>
        <entry name="RSTO_LPS"/>
        <entry name="RSTO_GPIO"/>
        <entry name="RSTO_WDTIMER"/>
        <entry name="RSTO_TCU"/>
        <bound name="NB_RSTO"/>
    </enum>


    <range name="p_Reset_BB_L" left="BOUND_BRST_AFTER-1" right="BOUND_BRST_FIRST" ><comment>Range for Reset register generation</comment></range>

    <range name="range_Reset_Sys_Reg_L" left="NR_RST_REG-1" right="0" />
    <range name="range_Reset_Sys_L" left="NB_RST-1" right="0" />
    <range name="range_Reset_Other_L" left="NB_RSTO-1" right="0" />

    <range name="range_Clock_SysXcpu_H" left="NB_SYS_CLK_XCPU-1" right="0" ><comment>Range for XCPU clock_ctrl generation</comment></range>
    <range name="range_Clock_Sys_H" left="NB_SYS_CLK-1" right="0" ><comment>Range for clock_ctrl generation</comment></range>
    <range name="range_Mode_Clock_Sys_H" left="NB_SYS_CLK_AEN-1" right="1" />
    <range name="range_Enable_Clock_Sys_H" left="NB_SYS_CLK_EN-1" right="0" />

    <range name="range_Clock_Per_H" left="NB_PER_CLK-1" right="0" />
    <range name="range_Mode_Clock_Per_H" left="NB_PER_CLK_AEN-1" right="0" />
    <range name="range_Enable_Clock_Per_H" left="NB_PER_CLK_EN-1" right="0" />

    <range name="range_Clock_BB_H" left="NB_BB_CLK-1" right="0" />
    <range name="range_Mode_Clock_BB_H" left="NB_BB_CLK_AEN-1" right="1" />
    <range name="range_Enable_Clock_BB_H" left="NB_BB_CLK_EN-1" right="0" />

    <range name="range_Clock_Other_H" left="NB_OTHER_CLK-1" right="0" />
    <range name="range_Mode_Clock_Other_H" left="NB_OTHER_CLK_AEN-1" right="0" />
    <range name="range_Enable_Clock_Other_H" left="NB_OTHER_CLK_EN-1" right="0" />

    <range name="range_Cfg_Clk_Host" left="5" right="0" ><comment>Range for clock_ctrl generation, as there is no config register for this clock in sys_ctrl</comment></range>


    <var name="SYS_CTRL_PROTECT_LOCK" value="0xa50000" ><comment>For REG_DBG protect lock/unlock value</comment></var>
    <var name="SYS_CTRL_PROTECT_UNLOCK" value="0xa50001" />




    <reg name="REG_DBG" protect="rw">
        <comment><strong>This register is used to Lock and Unlock the protected registers.</strong>
        </comment>
        <bits name="Scratch"    pos="15:0"  access="rw"  rst="no">
            <comment>Scratch register: used for debug
            </comment>
        </bits>
        <bits name="Write Unlock Status"    pos="30"  access="r"  rst="0">
            <comment>Is set to 1 when a write attempt has been done on a protected register
                <br/>Can be reset by writing 0xa50000 or 0xa50001 to the debug register (With the LSB at 1 to unlock the protected registers, with the LSB at 0 to lock them)
            </comment>
        </bits>
        <bits name="Write Unlock"           pos="31"  access="r"  rst="1">
            <comment>When this bit is set to 1, the protected registers are accessible
                <br/>When this bit is set to 0, the protected registers can not be written
                <br/>Write 0xa50000 to the debug register to set this bit to 0
                <br/>Write 0xa50001 to the debug register to set this bit to 1
            </comment>
        </bits>
    </reg>

    <reg name="Sys_Rst_Set" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Set_Sys_Rst"    pos="NB_SRST-1:0"  access="rs" rst="1" cut="1" cutprefix="Set" cutenum="Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name="Set_Rst_Out"    pos="30"    access="rs" rst="0">
            <comment>Writing a 1 to this bit will output a 0 on the RST_OUT pin
                <br/>Reading this bit will return the RST_OUT line state.
            </comment>
        </bits>
        <bits name="Soft_Rst"   pos="31"    access="s" rst="0">
            <comment>Writing a 1 to this bit will reset the entire chip.
            </comment>
        </bits>
    </reg>
    <reg name="Sys_Rst_Clr" protect="rw">
        <bits name="Clr_Sys_Rst"    pos="NB_SRST-1:0"  access="rc" rst="1" cut="1" cutprefix="Clr" cutenum="Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name="Clr_Rst_Out"    pos="30"    access="rc" rst="0">
            <comment>Writing a 1 to this bit will output a 1 on the RST_OUT pin
                <br/>Reading this bit will return the RST_OUT line state.
            </comment>
        </bits>
    </reg>
    <reg name="BB_Rst_Set" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Set_BB_Rst"    pos="NB_BRST-1:0"  access="rs" rst="1" cut="1" cutprefix="Set" cutenum="Resets" cutstart="BOUND_BRST_FIRST">
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name="Set_RST_BB_FULL" pos="31"    access="rs" rst="1">
            <comment>Writing a 1 to this reset bit will reset the all  modules on the baseband  and leave them in reset state. (this resets more modules than all lower bits of this register)
                <br/>Reading this register returns the reset state of the full baseband side.
                <br/>0 : in reset
                <br/>1 : out of reset

            </comment>
        </bits>
    </reg>
    <reg name="BB_Rst_Clr" protect="rw">
        <bits name="Clr_BB_Rst"    pos="NB_BRST-1:0"  access="rc" rst="1" cut="1" cutprefix="Clr" cutenum="Resets" cutstart="BOUND_BRST_FIRST">
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name="Clr_RST_BB_FULL" pos="31"    access="rc" rst="1">
            <comment>Writing a 1 to this reset bit will take all the modules on the baseband   out of reset state. (modules can be kept in reset if the corresponding bit in lower bits of this register is still forcing it's reset)
                <br/>Reading this register returns the reset state of the full baseband side.
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="Clk_Sys_Mode" protect="rw">
        <bits name="Mode_SYS_XCPU"   pos="0" access="r"  rst="1">
            <comment> fixed to '1'. This clock is gated only by manual mode or xcpu_sleep from irq module.
            </comment>
        </bits>
        <bits name="Mode_Clk_Sys"   pos="NB_SYS_CLK_AEN-1:1"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="Sys_Clks" cutstart="1">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_Sys_Enable" protect="rw">
        <bits name="Enable_Clk_Sys"     pos="NB_SYS_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="Sys_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_Sys_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_Sys"    pos="NB_SYS_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="Sys_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_Per_Mode" protect="rw">
        <bits name="Mode_Clk_Per"   pos="NB_PER_CLK_AEN-1:0"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="Per_Clks" cutstart="0">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_Per_Enable" protect="rw">
        <bits name="Enable_Clk_Per"     pos="NB_PER_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="Per_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_Per_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_Per"    pos="NB_PER_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="Per_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_BB_Mode" protect="rw">
       <bits name="Mode_BB_BCPU"   pos="0" access="r"  rst="1">
            <comment> fixed to '1'. This clock is gated only by manual mode or bcpu_sleep from irq module.
            </comment>
        </bits>
        <bits name="Mode_Clk_BB"   pos="NB_BB_CLK_AEN-1:1"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="BB_Clks" cutstart="1">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_BB_Enable" protect="rw">
        <bits name="Enable_Clk_BB"     pos="NB_BB_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="BB_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_BB_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_BB"    pos="NB_BB_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="BB_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_Other_Mode" protect="rw">
        <bits name="Mode_Clk_Other"   pos="NB_OTHER_CLK_AEN-1:0"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="Other_Clks" cutstart="0">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_Other_Enable" protect="rw">
        <bits name="Enable_Clk_Other"     pos="NB_OTHER_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="Other_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_Other_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_Other"    pos="NB_OTHER_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="Other_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Pll_Ctrl" protect="rw">
        <comment>Register protected by Write_Unlocked_H.</comment>
        <bits name="Pll_Enable" pos="0" access="rw" rst="0">
            <comment>Mode of the Pll. This register is set to enable by the LPS_start_ExtPll_pulse_H.</comment>
            <options>
                <option name="Power_Down" value="0"></option>
                <option name="Enable" value="1"></option>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="Pll_Lock_Reset" pos="4" access="rw" rst="0">
            <comment>Used to reset the PLL Lock Detector.</comment>
            <options>
                <option name="Reset"    value="0"></option>
                <option name="No_Reset" value="1"></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="Pll_Bypass" pos="8" access="rw" rst="0">
            <options>
                <option name="Pass" value="0"><comment>In this mode the output of the PLL is its input clock divided by the proper dividers</comment></option>
                <option name="Bypass" value="1"><comment>In this mode the output of the PLL is its input clock</comment></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="Pll_Clk_Fast_Enable" pos="12" access="rw" rst="0">
            <comment>Enables the Fast Clock from the ExtPll (Clock Gate Reg Resync).</comment>
            <options>
                <option name="Enable" value="1"></option>
                <option name="Disable" value="0"></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bitgroup name="Pll_xp_cfg">
            <entry ref="Pll_Enable"/>
            <entry ref="Pll_Lock_Reset"/>
            <entry ref="Pll_Bypass"/>
            <entry ref="Pll_Clk_Fast_Enable"/>
        </bitgroup>
    </reg>
    <reg name="Sel_Clock" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Slow_sel_RF"    pos="0"  access="rw" rst="1">
            <comment>PreSelects between RF clock and Oscillator clock for Clock Slow
            </comment>
            <options>
                <option name="Oscillator"   value="1"/>
                <option name="RF"           value="0"/>
            </options>
        </bits>
        <bits name="Sys_sel_Fast"    pos="4"  access="rw" rst="1">
            <comment>Selects between the Slow clock and the Fast Clock (Pll clock) and Selects between the Slow clock and the Xcpu Clock
            </comment>
            <options>
                <option name="Slow"         value="1"/>
                <option name="Fast"         value="0"/>
            </options>
        </bits>
        <bits name="TCU_13M_L"    pos="5"  access="rw" rst="0">
            <comment>Selects TCU Clock 13M or 26M
            </comment>
            <options>
                <option name="26M"         value="1"/>
                <option name="13M"         value="0"/>
            </options>
        </bits>
        <bits name="Pll_disable_lps"    pos="6"  access="rw" rst="0">
            <comment>Disable PLL when LPS power up.
            </comment>
            <options>
                <option name="Disable"      value="1"/>
                <option name="Enable"       value="0"/>
            </options>
        </bits>
        <bits name="DigEn_H"    pos="7"  access="rw" rst="0">
            <comment>Enable digital 52M clock.
            </comment>
            <options>
                <option name="Enable"       value="1"/>
                <option name="disable"      value="0"/>
            </options>
        </bits>
        <bits name="RF_detected" pos="20" access="r" rst="no">
            <options>
                <option name="Ok" value="1"><comment>When 1, the clock from the XCver is detected.</comment></option>
                <option name="No" value="0"><comment>When 0, the clock from the XCver is not detected.</comment></option>
            </options>
        </bits>
        <bits name="RF_Detect_Bypass" pos="21" access="rw" rst="0">
            <comment>If RF_Detect_Bypass = 0, RF clock is selected when she is detected.
                <br/>If RF_Detect_Bypass = 1, RF clock is selected even she is not detected.
            </comment>
        </bits>

        <bits name="RF_Detect_Reset" pos="22" access="rw" rst="0">
            <comment>When 1, The RF clock detection counter is force reseted.
                <br/>When 0, The RF clock detection counter is enabled.
            </comment>
        </bits>
        <bits name="RF_selected_L"    pos="23"    access="r" rst="1">
            <comment>0 when RF clock is effectively selected for Slow Clock. RF clock selection is not done until the clock has been detected.
            </comment>
        </bits>
        <bits name="PLL_Locked" pos="24" access="r" rst="0">
            <options>
                <option name="Locked"     value="1"><comment></comment></option>
                <option name="Not_Locked" value="0"><comment></comment></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="PLL_bypass_Lock" pos="27" access="rw" rst="0">
            <comment>When set to 1, the system clock will switch to the fast clock even if the pll is not locked.
                <br/>When set to 0, the system clock is only allowed to switch to the fast clock if the pll is locked
            </comment>
        </bits>
        <bits name="Fast_Selected_L"    pos="31"    access="r" rst="1">
            <comment>0 when Fast clock is effectively selected. Fast clock selection is not done until the PLL has locked.
            </comment>
            <options>
            <mask/><shift/><default/>
            </options>
        </bits>
    </reg>
    <reg name="Cfg_Clk_Sys" protect="rw">
       <bits name="Freq"   pos="3:0"  access="rw" rst="all0">
            <comment>Bit force_div_update in this register is protected.
            </comment>
            <options>
                <option name="312M" value="13"/>
                <option name="250M" value="12"/>
                <option name="208M" value="11"/>
                <option name="178M" value="10"/>
                <option name="156M" value="9"/>
                <option name="139M" value="8"/>
                <option name="125M" value="7"/>
                <option name="113M" value="6"/>
                <option name="104M" value="5"/>
                <option name="89M"  value="4"/>
                <option name="78M"  value="3"/>
                <option name="52M"  value="2"/>
                <option name="39M"  value="1"/>
                <option name="26M"  value="0"/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values the system will run at 26MHz
                <br/>any writing to this register will trigger an update request. The update will be effective when the gsm clocks are in the proper phase to avoid schronization loss unless bit force_div_update is written '1'.
            </comment>
        </bits>
        <bits name="force_div_update"   pos="4"    access="rw" rst="1">
            <comment>Allows to switch the system clock divider without taking care of the gsm clocks
                <br/>1 : update is immediate
                <br/>0 : update is dependent of the gsm clocks phase to avoid loosing synchronization
            </comment>
        </bits>
        <bits name="req_div_update"     pos="8"    access="r" rst="1">
            <comment>Status to check if a request to update the pll divider is pending.
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_Mem_Bridge" protect="rw">
       <bits name="Mem_Freq"   pos="3:0"  access="rw" rst="all0">
            <options>
                <option name="312M" value="13"/>
                <option name="250M" value="12"/>
                <option name="208M" value="11"/>
                <option name="178M" value="10"/>
                <option name="156M" value="9"/>
                <option name="139M" value="8"/>
                <option name="125M" value="7"/>
                <option name="113M" value="6"/>
                <option name="104M" value="5"/>
                <option name="89M"  value="4"/>
                <option name="78M"  value="3"/>
                <option name="52M"  value="2"/>
                <option name="39M"  value="1"/>
                <option name="26M"  value="0"/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values the memory interface will run at 26MHz
            </comment>
        </bits>
        <bits name="DDR_mode_en"     pos="6"    access="rw" rst="0">
            <comment>DDR Mode Enable with DDR PSRAM.
                <br/>0 : Normal mode.
                <br/>1 : DDR mode.
            </comment>
            <options>
                <option name="Normal mode"  value="0"/>
                <option name="DDR mode"     value="1"/>
            </options>
        </bits>
        <bits name="DDR_fast_clk_pol"     pos="7"    access="rw" rst="0">
            <comment>Select Clk_Mem_Bridge_fast Pol
                <br/>1 : Invert
                <br/>0 : Normal
            </comment>
            <options>
                <option name="Invert"   value="1"/>
                <option name="Normal"   value="0"/>
            </options>
        </bits>
        <bits name="DDR_DQSL_i"     pos="9:8"    access="rw" rst="01">
            <comment>Input DQSL delay select.
                <br/>If DDR_PLL_OFF=1, number of DELAY CELL;
                <br/>If DDR_PLL_OFF=0, 624MHz PLL Clk Sample.
            </comment>
        </bits>
        <bits name="DDR_DQSU_i"     pos="11:10"    access="rw" rst="01">
            <comment>Input DQSU delay select.
                <br/>If DDR_PLL_OFF=1, number of DELAY CELL;
                <br/>If DDR_PLL_OFF=0, 624MHz PLL Clk Sample.
            </comment>
        </bits>
        <bits name="DDR_DQSL_o"     pos="13:12"    access="rw" rst="01">
            <comment>Output DQSL delay select.
                <br/>If DDR_PLL_OFF=1, number of DELAY CELL;
                <br/>If DDR_PLL_OFF=0, 624MHz PLL Clk Sample.
            </comment>
        </bits>
        <bits name="DDR_DQSU_o"     pos="15:14"    access="rw" rst="01">
            <comment>Output DQSL delay select.
                <br/>If DDR_PLL_OFF=1, number of DELAY CELL;
                <br/>If DDR_PLL_OFF=0, 624MHz PLL Clk Sample.
            </comment>
        </bits>
        <bits name="DDR_PLL_OFF"     pos="16"    access="rw" rst="1">
            <comment>Select delay mode.
                <br/>If 1, DELAY CELL;
                <br/>If 0, 624MHz PLL Clk Sample.
            </comment>
        </bits>
        <bits name="Mem_req_div_update"     pos="31"    access="r" rst="1">
            <comment>Status to check if a request to update the pll divider is pending.
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_Out" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="ClkOut_Divider"    pos="4:0"   access="rw" rst="all0">
            <comment>The generated clock frequency is equal to the 156MHz divided by this value + 2. The 156MHz clock comes from a PLL.
            </comment>
        </bits>
        <bits name="ClkOut_Sel"    pos="9:8" access="rw" rst="0">
            <comment>Selects between the Slow clock and the Pll clock
            </comment>
            <options>
                <option name="Osc"      value="0"/>
                <option name="RF"       value="1"/>
                <option name="Divider"  value="2"/>
            </options>
        </bits>
    </reg>
    <reg name="Cfg_Clk_Host_Uart"    protect="rw">
        <bits name="Host_Uart_Divider"    pos="9:0"   access="rw" rst="5">
            <comment>The generated clock frequency is equal to the selected source frequency divided by this value + 2 (see bit 12 clock select for source selection).
                <br/>The generated clock must be 4 or 16 times the expected baud rate depending on the Uart settings (see Uart section for details).
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Host_Uart_Sel_PLL"   pos="12"    access="rw" rst="0">
            <options>
                <option name="Slow" value="0"><comment>The Uart clock is generated from the Slow clock divided by the divider value + 2</comment></option>
                <option name="PLL"  value="1"><comment>The Uart clock is generated from a 156MHz clock generated by the PLL.</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Cfg_Clk_Auxclk"  protect="rw">
        <bits name="AUXCLK_EN"    pos="0"   access="rw" rst="0">
            <comment>AUXCLK out enable. (26MHz coming from Xcver) </comment>
           <options>
               <option name="disable" value="0"></option>
               <option name="enable" value="1"></option>
           </options>
        </bits>
    </reg>
    <reg name="Cfg_AHB" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Sys_New_Arbitration" pos="0" access="rw" rst="1">
            <comment>Used to solve the possible AHBC arbitration bug. The new arbitration scheme will give the priority to a unsplitted master over a new comer who was not splitted before. To use this feature please enable the AHB_Cmd_Full_Shift fix in the Membridge FIFO Control as well.</comment>
            <options>
                <option name="Enable" value="1"></option>
                <option name="Disable" value="0"></option>
            </options>
        </bits>
        <bits name="Sys_Enable" pos="SYS_NB_MASTERS:1" access="rw" rst="1" cut="1" cutprefix="Enable" cutenum="Sys_Master_Id" cutstart="1">
            <options>
                <option name="Enable" value="1"><comment>Normal configuration</comment></option>
                <option name="Disable" value="0"><comment>The master is never granted on the System AHB</comment></option>
            </options>
        </bits>
        <bits name="BB_New_Arbitration" pos="16" access="rw" rst="1">
            <comment>The new arbitration scheme will give the priority to a unsplitted master over a new comer who was not splitted before.</comment>
            <options>
                <option name="Enable" value="1"></option>
                <option name="Disable" value="0"></option>
            </options>
        </bits>
        <bits name="BB_Enable" pos="BB_NB_MASTERS+16:17" access="rw" rst="1" cut="1" cutprefix="Enable" cutenum="BB_Master_Id" cutstart="1">
            <options>
                <option name="Enable" value="1"><comment>Normal configuration</comment></option>
                <option name="Disable" value="0"><comment>The master is never granted on the Baseband AHB</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Ctrl_AHB" protect="rw">
        <comment>This register is protected. Used to unsplit masters manualy.
        </comment>
        <bits name="Sys_Force_HSPLIT" pos="SYS_NB_MASTERS-1:0" access="rw" rst="1" cut="1" cutprefix="SPLIT" cutenum="Sys_Master_Id" cutstart="1">
            <options>
                <option name="Normal" value="1"><comment>Normal configuration</comment></option>
                <option name="Force" value="0"><comment>The master is Unsplitted</comment></option>
            </options>
        </bits>
        <bits name="BB_Force_HSPLIT" pos="BB_NB_MASTERS+15:16" access="rw" rst="1" cut="1" cutprefix="SPLIT" cutenum="BB_Master_Id" cutstart="1">
            <options>
                <option name="Normal" value="1"><comment>Normal configuration</comment></option>
                <option name="Force" value="0"><comment>The master is Unsplitted</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="XCpu_Dbg_BKP" protect="rw">
        <bits name="BKPT_En" pos="0" access="rw" rst="0">
            <comment>Enable XCPU hardware breakpoint.
            </comment>
        </bits>
        <bits name="BKPT_Mode" pos="5:4" access="rw" rst="all1" display="bin">
            <options>
                <option name="I" value="0"><comment>Breakpoint is triggered when an instruction is fetched at XCpu_Dbg_Addr</comment></option>
                <option name="R" value="1"><comment>Breakpoint triggered when a data is read at XCpu_Dbg_Addr</comment></option>
                <option name="W" value="2"><comment>Breakpoint triggered when a data is written at XCpu_Dbg_Addr</comment></option>
                <option name="RW" value="3"><comment>Breakpoint triggered when a data is read OR written at XCpu_Dbg_Addr</comment></option>
                <default/>
            </options>
        </bits>
        <bits name="Stalled"    pos="8" access="rw" rst="0">
            <comment>When 1 the cpu is stalled and stays stalled until this bit is set to 0, when 0 the stall condition depends on the breakpoint trigger. If the breakpoint is triggered, the cpu stalls. It can be released by writing a 0 to this bit.
            </comment>
        </bits>
    </reg>
    <reg name="XCpu_Dbg_Addr" protect="rw">
        <bits name="Breakpoint address" pos="NB_BITS_ADDR-1:0" access="rw" rst="no" display="hex">
            <comment>Physical address of breakpoint
            </comment>
        </bits>
    </reg>
    <reg name="BCpu_Dbg_BKP" protect="rw">
        <bits name="BKPT_En" pos="0" access="rw" rst="0">
            <comment>Enable BCPU hardware breakpoint.
            </comment>
        </bits>
        <bits name="BKPT_Mode" pos="5:4" access="rw" rst="all1" display="bin">
            <options>
                <option name="I" value="0"><comment>Breakpoint is triggered when an instruction is fetched at BCpu_Dbg_Addr</comment></option>
                <option name="R" value="1"><comment>Breakpoint triggered when a data is read at BCpu_Dbg_Addr</comment></option>
                <option name="W" value="2"><comment>Breakpoint triggered when a data is written at BCpu_Dbg_Addr</comment></option>
                <option name="RW" value="3"><comment>Breakpoint triggered when a data is read OR written at BCpu_Dbg_Addr</comment></option>
                <default/>
            </options>
        </bits>
        <bits name="Stalled"    pos="8" access="rw" rst="0">
            <comment>When 1 the cpu is stalled and stays stalled until this bit is set to 0, when 0 the stall condition depends on the breakpoint trigger. If the breakpoint is triggered, the cpu stalls. It can be released by writing a 0 to this bit.
            </comment>
        </bits>
    </reg>
    <reg name="BCpu_Dbg_Addr" protect="rw">
        <bits name="Breakpoint address" pos="NB_BITS_ADDR-1:0" access="rw" rst="no" display="hex">
            <comment>Physical address of breakpoint
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Cpus_Cache_Ram_Disable" protect="rw">
        <bits name="XCpu_Use_Mode"  pos="0" access="rw" rst="0">
            <comment>When 1 the XCPU deselects its cache rams automatically when not in use, when 0 this feature is disabled.
            </comment>
        </bits>
        <bits name="XCpu_Clk_Off_Mode" pos="1" access="rw" rst="0">
            <comment>When 1 the cache rams are automatically deselected  when the XCPU clock is shutdown, when 0 this feature is disabled.
            </comment>
        </bits>
        <bitgroup name="XCpu_Cache_Ram_Disable">
            <entry ref="XCpu_Use_Mode"/>
            <entry ref="XCpu_Clk_Off_Mode"/>
        </bitgroup>
        <bits name="BCpu_Use_Mode"  pos="16" access="rw" rst="0">
            <comment>When 1 the BCPU deselects its cache rams automatically when not in use, when 0 this feature is disabled.
            </comment>
        </bits>
        <bits name="BCpu_Clk_Off_Mode" pos="17" access="rw" rst="0">
            <comment>When 1 the cache rams are automatically deselected  when the BCPU clock is shutdown, when 0 this feature is disabled.
            </comment>
        </bits>
        <bitgroup name="BCpu_Cache_Ram_Disable">
            <entry ref="BCpu_Use_Mode"/>
            <entry ref="BCpu_Clk_Off_Mode"/>
        </bitgroup>
    </reg>
    <reg name="Reset_Cause" protect="rw">
        
        <bits name="WatchDog_Reset" pos="0" access="rw" rst="no">
            <options>
                <option name="Happened" value="1"><comment>A watchdog reset has happened</comment></option>
                <option name="No" value="0"><comment>No watchdog reset happened since the last HW reset or power on.</comment></option>
            </options>
            <comment>Writing a 1 to this bit will reset the bits watchdog_Reset cause, GlobalSoft_Reset cause and HostDebug_Reset cause to 0.
            </comment>
        </bits>
        <bits name="APSoft_Reset" pos="1" access="r" rst="no">
            <options>
                <option name="Happened" value="1"><comment>A reset was initiated from AP soft reset register</comment></option>
                <option name="No" value="0"><comment>The reset was not from AP reset register.</comment></option>
            </options>
        </bits>
        <bits name="GlobalSoft_Reset" pos="4" access="r" rst="no">
            <options>
                <option name="Happened" value="1"><comment>A reset was initiated from Global soft reset register</comment></option>
                <option name="No" value="0"><comment>The reset was not from the soft reset register.</comment></option>
            </options>
        </bits>
        <bits name="HostDebug_Reset" pos="5" access="r" rst="no">
            <options>
                <option name="Happened" value="1"><comment>A reset was initiated from the Host interface</comment></option>
                <option name="No" value="0"><comment>The reset was not from the debug interface.</comment></option>
            </options>
        </bits>
        <bits name="AlarmCause" pos="6" access="r" rst="no">
            <options>
                <option name="Happened" value="1"><comment>An Alarm occur from the calendar</comment></option>
                <option name="No" value="0"><comment>No Alarm occur.</comment></option>
            </options>
        </bits>
        <bits name="MemCheckDone" pos="7" access="r" rst="no">
            <options>
                <option name="Done" value="1"><comment>Memory selfcheck done</comment></option>
                <option name="Running" value="0"><comment>Memory selfcheck running</comment></option>
            </options>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Boot_Mode" pos="23:8" access="rw" rst="no">
            <comment>This contains the state of boot mode pins latched during Reset.
                <br/> see BootSequence for details.
                <br/> This register is not reseted by a software or host reset.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="SW_Boot_Mode" pos="30:24" access="rw" rst="no">
            <comment> Software boot mode (Reseted at zero by external reset pin)
                <br/> This register is not reseted by a software or host reset.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Fonctional_Test_Mode" pos="31" access="r" rst="no">
            <comment>When 1 the chip has booted in fonctional test mode (for chip production tests).
            </comment>
        </bits>
    </reg>
    <reg name="WakeUp" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="force_Wakeup" pos="0" access="rw" rst="0">
            <comment>When 1, the wake up is set. When 0, the wake up is clear. This register is protected.
            </comment>
        </bits>
    </reg>
    <reg name="AP_Ctrl" protect="rw">
        <bits name="AP_Int_Status" pos="0" access="r" rst="0">
            <comment>AP interrupt status.
            </comment>
        </bits>
        <bits name="AP_Int_Mask" pos="16" access="rw" rst="0">
            <comment>AP interrupt mask.
            </comment>
        </bits>
        <bits name="AP_DeepSleep_En" pos="24" access="rw" rst="0">
            <comment>When 1, AP in Deepsleep status. This register is protected.
            </comment>
        </bits>
    </reg>
    <reg name="Ignore_Charger" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Ignore_Charger" pos="0" access="rw" rst="0">
            <comment>When 1, the CHG_MASK line to PMU is set. When 0, it is cleared.
            </comment>
        </bits>
    </reg>


    <hole size="896"/>
    <reg name="Cfg_Reserve" protect="rw">
        <comment>This register is reserved.
        </comment>
        <bits name="Reserve" pos="15:0" access="rw" rst="1111000011110000">
            <comment>This register is reserved.
            </comment>
        </bits>
    </reg>
</module>

</archive>

<archive relative='sys_ifc.xml' >


<include file="globals.xml"/>

<include file="bb2g_generic_config.xml"/>

<var name="SYS_IFC_ADDR_ALIGN" value="0" />

<var name="SYS_IFC_TC_LEN" value="23" />

<var name="SYS_IFC_STD_CHAN_NB" value="SYS_IFC_NB_STD_CHANNEL" /> 

<var name="SYS_IFC_RFSPI_CHAN" value="1" />

<module name="sys_ifc" category="System">
  

  <reg protect="w" name="get_ch">
    <bits access="rw" name="ch_to_use" pos="3:0" rst="0">
      <comment>This field indicates which standard channel to use.
      <br /> Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
      <br /> After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
      <br />0000 = use Channel0
      <br />0001 = use Channel1
      <br />0010 = use Channel2 
      <br /> ...
      <br />0111 = use Channel7
      <br />1111 = all channels are busy</comment>
      <options><mask/><shift/><default/></options>
    </bits>
  </reg>

  <reg protect="r" name="dma_status">
    <bits access="r" name="ch_enable" pos="SYS_IFC_STD_CHAN_NB+SYS_IFC_RFSPI_CHAN-1:0" rst="0">
      <comment>This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
      <br />0000_0000 = All channels disabled 
      <br />0000_0001 = Ch0 enabled 
      <br />0000_0010 = Ch1 enabled 
      <br />0000_0100 = Ch2 enabled 
      <br />0000_0101 = Ch0 and Ch2 enabled 
      <br />0000_0111 = Ch0, Ch1 and Ch2 enabled 
      <br />1111_1111 = all channels enabled</comment>
    </bits>

    <bits access="r" name="ch_busy" pos="SYS_IFC_STD_CHAN_NB-1+16:16" rst="0">
      <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
    </bits>
  </reg>

  <reg protect="r" name="debug_status">
    <bits access="r" name="dbg_status" pos="0" rst="0">
      <comment>Debug Channel Status .<br />0= The debug channel is running
      (not idle) <br />1= The debug channel is in idle mode</comment>
    </bits>
  </reg>

  <hole size="32" />

  

  <struct count="SYS_IFC_STD_CHAN_NB" name="std_ch">
    <reg protect="rw" name="control">
      <bits access="w" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer. </comment>
      </bits>

      <bits access="w" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit disable the channel.
        <br />When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled. </comment>
      </bits>

      <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
        <comment>Read FIFO data exchange high 8-bit and low 8-bit.
        <br />0: Exchange;
        <br />1: No exchange. </comment>
      </bits>

      <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
        <comment>Write FIFO data exchange high 8-bit and low 8-bit.
        <br />0: No exchange;
        <br />1: Exchange. </comment>
      </bits>

      <bits access="rw" name="autodisable" pos="4" rst="1">
        <comment>Set Auto-disable mode<br /> 0 = when TC reach zero the
        channel is not automatically released.<br /> 1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.</comment>
      </bits>
      
      <bits access="rw" name="Size" pos="6:5" rst="all0">
        <comment>Peripheral Size
            <br /> 0= 8-bit peripheral
            <br /> 1= 16-bit peripheral
            <br /> 2= 32-bit peripheral
        </comment>
        <options>
            <option name="Byte"      value="0"></option>
            <option name="Half_Word" value="1"></option>
            <option name="Word"      value="2"></option>
            <mask/><shift/><default/>
        </options>
      </bits>

      <bits access="rw" name="req_src" pos="12:8" rst="0xf" display="hex">
        <options linkenum="Sys_Ifc_Request_IDs"> 
          <shift/><mask/><default/>
        </options>

        <comment>Select DMA Request source</comment>
      </bits>

        <bits access="rw" name="flush" pos="16" rst="0">
        <comment>When one, flush the internal FIFO channel. 
        <br />This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel. 
        <br /> Before writting back this bit to zero the internal fifo must empty.
        </comment>
        
      </bits>
    </reg>

    <reg protect="r" name="status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>Enable bit, when '1' the channel is running  </comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>The internal channel fifo is empty </comment>
      </bits>
    </reg>

    <reg protect="rw" name="start_addr">
      <bits access="rw" name="start_addr"
            pos="NB_BITS_ADDR-1:SYS_IFC_ADDR_ALIGN" rst="0xFFFFFFFF" display="hex">
        <comment>AHB Address. This field represent the start address of the
        transfer.
        <br />For a 32-bit peripheral, this address must be aligned 32-bit.
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="tc">
      <bits access="rw" name="tc" pos="SYS_IFC_TC_LEN-1:0" rst="0xFFFFFFFF" display="hex">
        <comment>Transfer Count, this field indicated the transfer size in bytes to perform.
        <br />During a transfer a write in this register add the new value to the current TC. 
        <br />A read of this register return the current current transfer count.
        </comment>
      </bits>
    </reg>
  </struct>
  
  <hole size="32*4*(7-SYS_IFC_STD_CHAN_NB)" />

  <reg protect="w" name="ch_rfspi_control">
      <bits access="s" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />This channel works only in fifo mode. </comment>
      </bits>

      <bits access="c" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit to disable the channel.
        </comment>
      </bits>
    </reg>

    <reg protect="r" name="ch_rfspi_status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>Enable bit, when '1' the channel is running  </comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>The internal channel fifo is empty </comment>
      </bits>
      
      <bits access="r" name="fifo_level" pos="12:8">
        <comment>Internal fifo level </comment>
      </bits>
    </reg>

    <reg protect="rw" name="ch_rfspi_start_addr">
      <bits access="rw" name="start_AHB_addr"
            pos="NB_BITS_ADDR-1:SYS_IFC_ADDR_ALIGN" rst="0xFFFFFFFF" display="hex">
        <comment>AHB Start Address. <br />This field represent the start address of the fifo.
                 The start address must 32-bit aligned.
        </comment>
      </bits>
    </reg>
    
    <reg protect="rw" name="ch_rfspi_end_addr">
      <bits access="rw" name="end_AHB_addr"
            pos="NB_BITS_ADDR-1:SYS_IFC_ADDR_ALIGN" rst="0xFFFFFFFF" display="hex">
        <comment>AHB End Address. <br />This field represent the last address of the fifo (it is the first address not used in the fifo). <br />The end address must 32-bit aligned.
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="ch_rfspi_tc">
      <bits access="rw" name="tc" pos="13:0" rst="0xFFFFFFFF" display="hex">
        <comment>Transfer Count, transfer size in bytes. <br />This bit
        indicated the transfer size in bytes to perform. Up to 16kbytes per
        transfer. <br />During a transfer a write in this register add the new
        value to the current TC. A read of this register return the current
        current transfer count.</comment>
      </bits>
    </reg>
</module>

</archive>
<archive relative='sys_irq.xml' >


<include file="globals.xml"/>

<module name="sys_irq" category="System">
    
    
    <enum name="XCPU_Irq_Lines">
        <entry name="XCpu_Main_Irq_Line"><comment>XCPU Irq Lines</comment></entry>
        
        <entry name="XCpu_Page_Spy_Irq_Line" value="3"/>
        <entry name="XCpu_Debug_Irq_Line" value="4"/>
        <entry name="XCpu_Host_Irq_Line"/>
    </enum>


    <reg name="Cause" protect="rw">
        <comment>If cause is not null and interrupt are enabled then the interrupt line 0 is driven on the system CPU.
            <br/>The cause for the Irq sources, one bit for each module's irq source.
            <br/>The cause is the actual Irq source masked by the mask register.
        </comment>
        <bits name="Cause" pos="SYS_NB_IRQ-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Status" protect="rw">
        <comment>The status for the level Irq sources, one bit for each module's irq source.
            <br/>The status reflect the actual Irq source.
        </comment>
        <bits name="Status" pos="SYS_NB_IRQ-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Mask_Set" protect="rw">
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Set" pos="SYS_NB_IRQ-1:0" access="rs" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Mask_Clear" protect="rw">
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Clr" pos="SYS_NB_IRQ-1:0" access="rc" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="NonMaskable" protect="rw">
        <bits name="Main_IRQ" pos="10" access="r" rst="0">
            <comment>This is the Main Irq source it drive the system CPU interrupt line 0.
                <br/>This bit comes from the modules irq and is masked by the Mask and SC registers.
            </comment>
        </bits>
        <bits name="Page_Spy_IRQ" pos="13" access="r" rst="0">
            <comment>This is the Page Spy Irq source it drive the system CPU interrupt line 3.
                <br/>This bit is controlled by the page spy module.
            </comment>
        </bits>
        <bits name="Debug_IRQ" pos="14" access="rw" rst="0">
            <comment>This is the debug Irq source, the value written here drives the system CPU interrupt line 4.
            </comment>
        </bits>
        <bits name="Host_IRQ" pos="15" access="r" rst="0">
            <comment>This is the Host Irq source it drive the system CPU interrupt line 5.
                <br/>This bit is controlled by the host internal register.
            </comment>
        </bits>
        <bits name="IntEnable_Status" pos="31" access="r" rst="1">
            <comment>Status of the Interrupt enable semaphore bit.
            </comment>
        </bits>
   </reg>
    <reg name="SC" protect="">
        <bits name="IntEnable" pos="0" access="rw" rst="1">
            <comment>Interrupt enable semaphore, used for critical section.
                <br/>Read returns its value and then clears it to '0' disabling interrupts.
                <br/>Write the read value to restore the previous state, this will exit the critical section.
            </comment>
        </bits>
    </reg>
    <reg name="WakeUp_Mask" protect="rw">
        <comment>Each bit to '1' in that registers allows the correcponding interrupt to wake up the System CPU (i.e.: Reenable it's clock, see CLOCK_SYS_ENABLE and CLOCK_SYS_DISABLE registers in sys_ctrl registers section)
        </comment>
        <bits name="WakeUp_Mask" pos="SYS_NB_IRQ-1:0" access="rw" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Cpu_Sleep" protect="rw">
        <bits name="Sleep" pos="0" access="w" rst="0">
            <comment>Writing '1' to this bit will put the XCPU to sleep (i.e.: Disable it's clock, see CLOCK_SYS_ENABLE and CLOCK_SYS_DISABLE registers in sys_ctrl registers section)
            </comment>
        </bits>
    </reg>
    <reg name="Pulse_Mask_Set" protect="rw">
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Pulse_Mask_Set" pos="SYS_NB_IRQ_PULSE-1:0" access="rs" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Mask_Clr" protect="rw">
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Pulse_Mask_Clr" pos="SYS_NB_IRQ_PULSE-1:0" access="rc" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Clear" protect="rw">
        <comment>Writing '1' clears the corresponding Pulse IRQ.
            <br/>Pulse IRQ are set by the modules and cleared here.
        </comment>
        <bits name="Pulse_Clr" pos="SYS_NB_IRQ_PULSE-1:0" access="c" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Status" protect="rw">
        <comment>The status for the Pulse Irq sources, one bit for each module's irq source.
            <br/>The status reflect the actual Irq source.
        </comment>
        <bits name="Status" pos="SYS_NB_IRQ_PULSE-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="Sys_Irq_Id" cutstart="0"/>
    </reg>

</module>

</archive>
<archive relative='tcu.xml' >


<module name="tcu" category="Modem">

    
    <var name="NB_TCO" value="12"/> 
    <var name="NB_TCU_PROG_EVENTS" value="60"/>

    <enum name="Internal_TCO_mapping">
        <entry name="TCO_GMSK_ON" value="6"><comment>Internal TCO mapping</comment></entry>
        <entry name="TCO_TX_OEN"/>
        <entry name="TCO_TX_ON"/>
        <entry name="TCO_RX_ON"/>
        <entry name="TCO_RX_DEC_ON"/>
        <entry name="TCO_PDN"/>
    </enum>

    <enum name="TCU_Event">
        
        <entry name="Clr_TCO_0" value="0"><comment>Clear TCO 0 : set the TCO 0 to the inactive state<br/>To clear TCO n, use event 2*n</comment></entry>
        <entry name="Set_TCO_0" value="1"><comment>Set TCO 0 : set the TCO 0 to the active state<br/>To set TCO n, use event 2*n+1</comment></entry>
        <entry name="Clr_TCO_1"><comment>...</comment></entry>
        
        
        <entry name="Stop_GMSK" value="TCO_GMSK_ON*2"><comment>stop modulation</comment></entry>
        <entry name="Start_GMSK" value="TCO_GMSK_ON*2+1"><comment>starts modulation and output on IQ DAC</comment></entry>
        <entry name="HighZ_IQ_DAC" value="TCO_TX_OEN*2"/>
        <entry name="Drive_IQ_DAC" value="TCO_TX_OEN*2+1"/>
        <entry name="disable_IQ_DAC" value="TCO_TX_ON*2"/>
        <entry name="enable_IQ_DAC" value="TCO_TX_ON*2+1"/>
        <entry name="disable_IQ_ADC" value="TCO_RX_ON*2"><comment>disable IQ ADC</comment></entry>
        <entry name="enable_IQ_ADC" value="TCO_RX_ON*2+1"><comment>enable IQ ADC</comment></entry>
        <entry name="stop_RFin_record" value="TCO_RX_DEC_ON*2"><comment>stop recording IQ samples</comment></entry>
        <entry name="start_RFin_record" value="TCO_RX_DEC_ON*2+1"><comment>start recording IQ samples</comment></entry>
        <entry name="Clr_PDN" value="TCO_PDN*2"><comment>Clear RF_PDN</comment></entry>
        <entry name="Set_PDN" value="TCO_PDN*2+1"><comment>Set RF_PDN</comment></entry>
        
        <entry name="SEND_SPI_CMD" value="NB_TCO*2"><comment>Send RF spi command</comment></entry>
        <entry name="NEXT_GAIN"/>
        <entry name="FIRST_GAIN"/>
        
        <entry name="NEXT_FC"/>
        
        <entry name="PA_RAMP0"><comment>Start Ramp 0</comment></entry>
        <entry name="PA_RAMP1"><comment>Start Ramp 1</comment></entry>
        <entry name="PA_RAMP2"><comment>Start Ramp 2</comment></entry>
        <entry name="PA_RAMP3"><comment>Start Ramp 3</comment></entry>
        <entry name="PA_RAMP4"><comment>Start Ramp 4</comment></entry>
        <entry name="RX_SOC"/>
        <entry name="DIGRF_STB"/>
        
        <entry name="BCPU_TCU_IRQ0"><comment>Trigger BCPU TCU irq 0</comment></entry>
        <entry name="BCPU_TCU_IRQ1"><comment>Trigger BCPU TCU irq 1</comment></entry>
        
        <entry name="XCPU_TCU_IRQ0"><comment>Trigger XCPU TCU irq 0</comment></entry>
        <entry name="XCPU_TCU_IRQ1"><comment>Trigger XCPU TCU irq 1</comment></entry>
        
        <entry name="WAKEUP_DONE"><comment>End of the WakeUp Mode</comment></entry>
        <entry name="NO_EVENT" value="63"/> 
    </enum>

    
    
	<var name="LP_FRAC_NB_BITS" value="16"/>
	<var name="LP_COUNT_INT_NB_BITS" value="19"/>
	<var name="LP_COUNT_NB_BITS" value="LP_COUNT_INT_NB_BITS + LP_FRAC_NB_BITS"/>
	<var name="LP_RATE_INT_NB_BITS" value="12"/>
	<var name="LP_RATE_NB_BITS" value="LP_RATE_INT_NB_BITS + LP_FRAC_NB_BITS"/>
	<var name="SYS_COUNT_NB_BITS" value="29"/>
	<var name="FRAME_COUNT_NB_BITS" value="10"/>
    
	<var name="PU_COUNT_NB_BITS" value="12"/>


    
    
    <reg name="Ctrl" protect="rw">
        <bits name="Load_Val" pos="13:0" access="rw" rst="all1" display="hex">
            <comment>Value loaded into the TCU counter when the Load bit is set to 1
            </comment>
        </bits>
        <bits name="Enable" pos="16" access="rw" rst="0">
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="Load" pos="20" access="w" rst="0">
            <comment>Writing a 1 to this bit will load the TCU with the TCU loadval value
                <br/>Writing a 0 has no effect
            </comment>
        </bits>
        <bits name="NoLatch" pos="28" access="rw" rst="0">
            <options>
                <option name="Normal" value="0"><comment>Normal Behavior, The programmation area is copied to the active area when the tcu wraps</comment></option>
                <option name="Force_Only" value="1"><comment>The programmation area is copied into the active area only when force latch is used</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Wrap_Val" protect="rw">
        <bits name="Wrap_Val" pos="13:0" access="rw" rst="all1" display="hex">
            <comment>TCU counter wrap value.
                <br/>The TCU counter returns to 0 when this value is reached
            </comment>
        </bits>
    </reg>
    <reg name="Cur_Val" protect="rw">
        <bits name="Cur_Val" pos="13:0" access="r" display="hex">
            <comment>TCU counter current value
            </comment>
        </bits>
    </reg>
    <reg name="Latch" protect="rw">
        <bits name="ForceLatch" pos="7:0" access="w" cut="1" cutprefix="ForceLatch_Area">
            <comment>Writing 1 transfer the programmed events to the active area.
            </comment>
        </bits>
        <bits name="Force_NoEvent" pos="16" access="w">
            <comment>Writing 1 to this bit with one of the ForceLatch bit will force the corresponding Active Area to receive no events (i.e. clear it) instead of transfering the programmed area.
            </comment>
        </bits>
        <bits name="ClearProgArea" pos="31" access="w">
            <comment>Writing 1 clears the Program Area
            </comment>
        </bits>
    </reg>
    <reg name="Setup" protect="rw">
        <bits name="TCO_Polarity" pos="NB_TCO-1:0" access="rw" rst="0" cut="1" cutprefix="POL_TCO">
            <comment>Configure the TCO polarity
            </comment>
            <options>
                <option name="Active High" value="0"/>
                <option name="Active Low" value="1"/>
            </options>
        </bits>
        <bits name="Write_Error" pos="28" access="rc" rst="0">
            <comment>Error Status: become 1 when writing to Program Area while the TCU is coping the Program Area to the Active Area. In this case the write is ignored.
                <br/>Write 1 to clear it.
            </comment>
        </bits>
        <bits name="Debug_Active" pos="31" access="rw" rst="0">
            <comment>This bit allows to access directly the active area for debug purposes
            </comment>
            <options>
                <option name="Normal" value="0"/>
                <option name="Debug" value="1"><comment>the active area is directly mapped instead of the program area.</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Disable_Event" protect="rw">
        <bits name="Disable_TCO" pos="9:0" access="rc" rst="all1" cut='1' cutprefix="Disable_TCO">
            <comment>Writing 1 disable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Internal_TCO" pos="14:10" access="rc" rst="all1" cut='1' cutprefix="Disable" cutenum="Internal_TCO_mapping">
            <comment>Writing 1 disable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Send_Spi_Cmd" pos="15" access="rc" rst="1">
            <comment>Writing 1 disable the events SEND_SPI_CMD.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Next_Gain" pos="16" access="rc" rst="1">
            <comment>Writing 1 disable the events NEXT_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_First_Gain" pos="17" access="rc" rst="1">
            <comment>Writing 1 disable the events FIRST_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Next_Fc" pos="18" access="rc" rst="1">
            <comment>Writing 1 disable the events NEXT_FC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Ramp" pos="23:19" access="rc" rst="all1" cut='1' cutprefix="Disable_Ramp">
            <comment>Writing 1 disable the corresponding Ramp event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Rx_SOC" pos="24" access="rc" rst="1">
            <comment>Writing 1 disable the events RX_SOC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_DigRF_Strobe" pos="25" access="rc" rst="1">
            <comment>Writing 1 disable the events DIGRF_STB.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Bcpu_Irq" pos="27:26" access="rc" rst="all1" cut='1' cutprefix="Disable_Bcpu_Irq">
            <comment>Writing 1 disable the corresponding BCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Xcpu_Irq" pos="29:28" access="rc" rst="all1" cut='1' cutprefix="Disable_Xcpu_Irq">
            <comment>Writing 1 disable the corresponding XCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Rf_Spi_Marked_Cmd" pos="31" access="rc" rst="1">
            <comment>Writing 1 disable the marked rf spi commands (cf RF SPI).
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
    </reg>
    <reg name="Enable_Event" protect="rw">
        <bits name="Enable_TCO" pos="9:0" access="rs" rst="all1" cut='1' cutprefix="Enable_TCO">
            <comment>Writing 1 enable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Internal_TCO" pos="14:10" access="rs" rst="all1" cut='1' cutprefix="Enable" cutenum="Internal_TCO_mapping">
            <comment>Writing 1 enable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Send_Spi_Cmd" pos="15" access="rs" rst="1">
            <comment>Writing 1 enable the events SEND_SPI_CMD.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Next_Gain" pos="16" access="rs" rst="1">
            <comment>Writing 1 enable the events NEXT_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_First_Gain" pos="17" access="rs" rst="1">
            <comment>Writing 1 enable the events FIRST_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Next_Fc" pos="18" access="rs" rst="1">
            <comment>Writing 1 enable the events NEXT_FC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Ramp" pos="23:19" access="rs" rst="all1" cut='1' cutprefix="Enable_Ramp">
            <comment>Writing 1 enable the corresponding Ramp event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Rx_SOC" pos="24" access="rs" rst="1">
            <comment>Writing 1 enable the events RX_SOC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_DigRF_Strobe" pos="25" access="rs" rst="1">
            <comment>Writing 1 enable the events DIGRF_STB.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Bcpu_Irq" pos="27:26" access="rs" rst="all1" cut='1' cutprefix="Enable_Bcpu_Irq">
            <comment>Writing 1 enable the corresponding BCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Xcpu_Irq" pos="29:28" access="rs" rst="all1" cut='1' cutprefix="Enable_Xcpu_Irq">
            <comment>Writing 1 enable the corresponding XCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Rf_Spi_Marked_Cmd" pos="31" access="rs" rst="1">
            <comment>Writing 1 enable the marked rf spi commands (cf RF SPI).
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
    </reg>
    <reg name="Set_TCO" protect="rw">
        <bits name="Set_TCO" pos="NB_TCO-1:0" access="s" cut='1' cutprefix="Set_TCO">
            <comment>Writing 1 set corresponding TCO to the active state (The actual line state also depends on TCO_Polarity).
                <br/>Reading returns the actual state of all TCOs.
            </comment>
        </bits>
    </reg>
    <reg name="Clr_TCO" protect="rw">
        <bits name="Clr_TCO" pos="NB_TCO-1:0" access="c" cut='1' cutprefix="Clr_TCO">
            <comment>Writing 1 set corresponding TCO to the inactive state (The actual line state also depends on TCO_Polarity).
                <br/>Reading returns the actual state of all TCOs.
            </comment>
        </bits>
    </reg>

    <reg name="Cfg_Clk_Div" protect="rw">
        <bits name="TCU_Clk_Same_Sys" pos="29" access="rw" rst="0">
            <comment>Enable Clk_TCU same with Clk_Sys.
            </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="Enable_DAI_Simple_208K" pos="30" access="rw" rst="0">
            <comment>Enable the 208kHz pulse generation for DAI Simple. (!) When enabling the clock field Enable_Qbit should also be enabled.
            </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="Enable_Qbit" pos="31" access="rw" rst="0">
            <comment>Enable the Quarter bit generation (required for normal TCU operation)
            </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
    </reg>
    <reg name="LPS_SF_Ctrl" protect="rw">
        <bits name="LPS_SF_Enable" pos="0" access="rw" rst="0">
            <comment>Lps Skip Frame Enable.
                <br/>When enabled the frame interrupt are masked until the programmed number of frames are elapsed.
                <br/>This is done by masking the frame interrupt line from the regular TCU counter, and counting the frames. Also when activating the LowPower SkipFrame the frame counter is tranfered to the low power counter that will update it based on the 32kHz Clock.
            </comment>
        </bits>
        <bits name="LPS_SF_LowPower" pos="5:4" access="rw" rst="0">
            <comment>Controls the Lps Low Power Counters (counters at 32kHz) usage.
            </comment>
            <options>
                <option name="Stop" value="0"><comment>Disable the Low Power Counters.</comment></option>
                <option name="SkipFrame" value="1"><comment>The Low Power Counters are started in Skip Frame Mode. In this mode the Low Power Counter are used to maintain the Time base, The Skip Frame Must be enabled as this is the Low Power extention of the Skip Frame feature.</comment></option>
                <option name="Calib" value="3"><comment>Start the calibration. The Low Power Counters are used to Calibrate the 32kHz clock against the System Clock, The Calibration is required to compensate from temperature variation. Note that the Skip Frame can also be enabled during calibration (but not with low power).</comment></option>
                <mask/>
                <shift/>
                <default/>
            </options>
        </bits>
        <bits name="LPS_SF_Wakeup0_en" pos="8" access="rw" rst="0">
            <comment>Enable fake Fint used with wakeupNumber=0. </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="LPS_SF_Wakeup0_cfg" pos="9" access="rw" rst="0">
            <comment>Enable fake Fint when sys_sf_frame_count>=cfg_sf_frame. 
                <br/>Default sys_sf_frame_count>cfg_sf_frame.
            </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
    </reg>
    <reg name="LPS_SF_Status" protect="rw">
        <bits name="LPS_SF_Ready" pos="0" access="r" rst="0">
            <comment>Lps Skip Frame Ready, status of the state machines to keep valid state between system clock and 32Khz clock.
                <br/>Must read as '1' before entering Low Power Skip Frame or Calibration mode.
            </comment>
        </bits>
        <bits name="LPS_SF_SlowRunning" pos="4" access="r" rst="0">
            <comment>'1' when Lps Skip Frame Low Power Counters are Running.
                <br/>When entering Low Power Skip Frame, the counters are not immediately started, they wait for the nextFrame interrupt. Reading this status allow to know if the counters are running, and the System Clock can be safely disabled.
            </comment>
        </bits>
        <bits name="LPS_SF_CalibrationDone" pos="8" access="r" rst="0">
            <comment>'1' when the Lps Skip Frame Calibration is Done.
            </comment>
        </bits>
        <bits name="LPS_SF_PU_Reached" pos="31" access="r" rst="0">
            <comment>'1' when the Lps Skip Frame Power-up sequence frame is reached.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Frames" protect="rw">
        <bits name="LPS_SF_Frame" pos="FRAME_COUNT_NB_BITS-1:0" access="rw">
            <comment>Number of frames to Skip.
                <br/>If the power up sequence is enabled, frames are skipped until both this number is reached and the powerup sequence has finished.
                <br/>Note: The power up sequence must be <b>Done</b> before the the frame LPS_SF_Frame ends.
            </comment>
        </bits>
        <bits name="LPS_SF_PU_Frame" pos="FRAME_COUNT_NB_BITS+15:16" access="rw">
            <comment>Number of frames before activating the Power-up sequence.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Restart_Time" protect="rw">
        <bits name="LPS_SF_Restart_Time" pos="LP_COUNT_INT_NB_BITS-1:0" access="rw">
            <comment>For LowPower SkipFrame mode: Value to restart TCU (and frame interrupt generation) on the system clock counter after a low power phase.
                <br/>For Calibration mode: number of 32k cycles for the calibration.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Frame_Period" protect="rw">
        <bits name="LPS_SF_Frame_Period" pos="LP_COUNT_INT_NB_BITS-1:0" access="rw">
            <comment>Value of the frame period in system clock count.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Rate" protect="rw">
        <comment>The rate is the number of System Clocks per 32kHz Clocks.
        </comment>
        <bits name="LPS_SF_Rate_Int" pos="LP_RATE_NB_BITS-1:LP_FRAC_NB_BITS" access="rw">
            <comment>Integer part of the rate.
            </comment>
        </bits>
        <bits name="LPS_SF_Rate_Frac" pos="LP_FRAC_NB_BITS-1:0" access="rw">
            <comment>Fractional part of the rate.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Elapsed_Frames" protect="rw">
        <bits name="LPS_SF_Elapsed_Frames" pos="FRAME_COUNT_NB_BITS-1:0" access="r" rst="0">
            <comment>Current number of elapsed frames.
                <br/>Valid when Skip Frame is Enabled.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Sys_Count" protect="rw">
        <bits name="LPS_SF_Sys_Count" pos="SYS_COUNT_NB_BITS-1:0" access="r" rst="0">
            <comment>Value of the system clock counter at the end of calibration (when CalibrationDone is '1' in LPS_SF_Status register).
                <br/>The hardware behind it is reused during other operation, reading that register at any other time will return an undefined value.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_PU_Ctrl" protect="rw">
        <bits name="LPS_PU_Enable" pos="0" access="rw" rst="1">
            <comment>Enable the Power-Up Sequence.
                <br/>This bit is automatically cleared when the sequence is <b>Done</b>.
            </comment>
            <options>
                <option name="ENABLE"  value="1"/>
                <option name="DISABLE" value="0"/>
                <default/>
            </options>
        </bits>
        <bits name="LPS_PU_ForceStart" pos="4" access="rw" rst="1">
            <comment>When '1' forces the Power-up sequence to start.
                <br/>This bit is automatically cleared when the sequence is <b>Done</b>.
            </comment>
            <options>
                <option name="ENABLE"  value="1"/>
                <option name="DISABLE" value="0"/>
                <default/>
            </options>
        </bits>
        <bits name="LPS_PU_CO0_On" pos="8" access="rw" rst="0">
            <comment>This force the Controlled Output 0 (LPSCO[0]) to be Active (See polarity for actual line state).
            </comment>
        </bits>
        <bits name="LPS_PU_CO1_On" pos="9" access="rw" rst="0">
            <comment>This force the Controlled Output 1 (LPSCO[1]) to be Active (See polarity for actual line state).
            </comment>
        </bits>
        <bitgroup name="LPS_PU_CO_On">
            <entry ref="LPS_PU_CO0_On"/>
            <entry ref="LPS_PU_CO1_On"/>
        </bitgroup>
        <bits name="LPS_PU_CLK_RF_On" pos="10" access="rw" rst="0">
            <comment>This force the Clock RF control line (CLK_RF_26M_EN) to be on.
            </comment>
        </bits>
        <bits name="LPS_PU_SPI_On" pos="11" access="rw" rst="0">
            <comment>This force the SPI to be on.
            </comment>
        </bits>
        <bits name="LPS_PU_CO0_Pol" pos="12" access="rw" rst="0">
            <comment>This sets the Controlled Output 0 (LPSCO[0]) polarity.
                <br/>Set to '1' if the line is active low.
            </comment>
        </bits>
        <bits name="LPS_PU_CO1_Pol" pos="13" access="rw" rst="0">
            <comment>This sets the Controlled Output 1 (LPSCO[1]) polarity.
                <br/>Set to '1' if the line is active low.
            </comment>
        </bits>
        <bitgroup name="LPS_PU_CO_Pol">
            <entry ref="LPS_PU_CO0_Pol"/>
            <entry ref="LPS_PU_CO1_Pol"/>
        </bitgroup>
        <bits name="LPS_PU_CLK_RF_Pol" pos="14" access="rw" rst="0">
            <comment>This sets the Clock RF control line (CLK_RF_26M_EN) polarity.
                <br/>Set to '1' if the line is active low.
            </comment>
        </bits>
        <bits name="LPS_PU_SPI_Step" pos="18:16" access="rw" rst="2">
            <comment>This selects the step where the SPI is switched on during the power up sequence.
            </comment>
            <options>
                <option name="CO_S1" value="0"><comment>The SPI is switched on at state <b>Controlled Output step 1</b>.</comment></option>
                <option name="RFClkReady" value="1"><comment>The SPI is switched on at state <b>RF Clock Ready</b>.</comment></option>
                <option name="Ready" value="2"><comment>The Analog SPI is switched on at state <b>Ready</b>.</comment></option>
                <option name="Done" value="3"><comment>The Analog SPI is switched on at state <b>Done</b>.</comment></option>
            </options>
        </bits>
        <bits name="LPS_PU_Mask_CO0_S1" pos="20" access="rw" rst="0">
            <comment>This selects the action to take on Controlled Output 0 (LPSCO[0]) during the state <b>Controlled Output step 1</b>.
            </comment>
            <options>
                <option name="Enable" value="1"><comment>The Controlled Output 0 (LPSCO[0]) is switched on during the state <b>Controlled Output step 1</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The Controlled Output 0 (LPSCO[0]) is not changed during the state <b>Controlled Output step 1</b>.</comment></option>
            </options>
        </bits>
        <bits name="LPS_PU_Mask_CO1_S1" pos="21" access="rw" rst="0">
            <comment>This selects the action to take on Controlled Output 1 (LPSCO[1]) during the state <b>Controlled Output step 1</b>.
            </comment>
            <options>
                <option name="Enable" value="1"><comment>The Controlled Output 1 (LPSCO[1]) is switched on during the state <b>Controlled Output step 1</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The Controlled Output 1 (LPSCO[1]) is not changed during the state <b>Controlled Output step 1</b>.</comment></option>
            </options>
        </bits>
        <bitgroup name="LPS_PU_Mask_CO_S1">
            <entry ref="LPS_PU_Mask_CO0_S1"/>
            <entry ref="LPS_PU_Mask_CO1_S1"/>
        </bitgroup>
        <bits name="LPS_PU_Mask_CO0_S2" pos="22" access="rw" rst="0">
            <comment>This selects the action to take on Controlled Output 0 (LPSCO[0]) during the state <b>Controlled Output step 2</b>.
            </comment>
            <options>
                <option name="Enable" value="1"><comment>The Controlled Output 0 (LPSCO[0]) is switched on during the state <b>Controlled Output step 2</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The Controlled Output 0 (LPSCO[0]) is not changed during the state <b>Controlled Output step 2</b>.</comment></option>
            </options>
        </bits>
        <bits name="LPS_PU_Mask_CO1_S2" pos="23" access="rw" rst="0">
            <comment>This selects the action to take on Controlled Output 1 (LPSCO[1]) during the state <b>Controlled Output step 2</b>.
            </comment>
            <options>
                <option name="Enable" value="1"><comment>The Controlled Output 1 (LPSCO[1]) is switched on during the state <b>Controlled Output step 2</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The Controlled Output 1 (LPSCO[1]) is not changed during the state <b>Controlled Output step 2</b>.</comment></option>
            </options>
        </bits>
        <bitgroup name="LPS_PU_Mask_CO_S2">
            <entry ref="LPS_PU_Mask_CO0_S2"/>
            <entry ref="LPS_PU_Mask_CO1_S2"/>
        </bitgroup>
        
        <bits name="LPS_PU_Mask_CLK_RF" pos="24" access="rw" rst="1">
            <comment>Mask Start Clock RF: When set to '1' the Clock RF is not started during the power up sequence.
            </comment>
            <options>
                <option name="Enable" value="1"><comment>The Clock RF is started during the state <b>RF Clock Enable</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The Clock RF is not started.</comment></option>
            </options>
        </bits>

        <bits name="LPS_PU_Mask_St_PLL" pos="25" access="rw" rst="0">
            <comment>Mask Start Pll: When set to '1' the Pll is not started during the power up sequence.
            </comment>
            <options>
                <option name="Enable" value="1"><comment>The Pll is started during the state <b>RF Clock Ready</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The Pll is not started.</comment></option>
            </options>
        </bits>
        <bits name="LPS_PU_Mask_Sw_RF" pos="26" access="rw" rst="1">
            <comment>Mask Switch to RF clock: When set to '1' the slow clock is not switched to the RF clock during the power up sequence.
            </comment>
            <options>
                <option name="Switch" value="1"><comment>The System Clock is switched to Clock RF during the state <b>RF Clock Ready</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The System Clock is not switched.</comment></option>
            </options>
        </bits>
        <bits name="LPS_PU_Mask_Sw_Fast" pos="27" access="rw" rst="0">
            <comment>Mask Switch to Fast clock: When set to '1' the system clock is not switched to the Fast clock during the power up sequence.
            </comment>
            <options>
                <option name="Switch" value="1"><comment>The System Clock is switched to Clock Pll during the state <b>Pll Clock Ready</b>.</comment></option>
                <option name="Ignore" value="0"><comment>The System Clock is not switched.</comment></option>
            </options>
        </bits>
        <bits name="LPS_PU_CPU_Done" pos="28" access="rw" rst="0">
            <comment>When set to '1' Ready step is done for the CPU.
                <br/>When both the CPU and the TCU are done, the state <b>Ready</b> ends and the state machine goes to state <b>Done</b>.
                <br/>This bit is automatically cleared when the sequence is <b>Done</b>.
            </comment>
        </bits>
        <bits name="LPS_PU_Run_TCU_WakeUp" pos="29" access="rw" rst="0">
            <comment>Run the TCU in WakeUp mode:
                <br/>In WakeUp mode, the TCU is started at time 0, process the TCU events until it reaches the Event WAKEUP_DONE.
                <br/>The WakeUp mode is started during the state <b>Ready</b>, the state <b>Ready</b> ends when both the CPU and the TCU are done.
                <br/>If the TCU is not started in WakeUp mode, it is considered Done for the <b>Ready</b> end.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_PU_Status" protect="rw">
        <bits name="LPS_PU_Done" pos="0" access="r" rst="0">
            <comment>The Power-Up Sequence is done (or idle).
            </comment>
        </bits>
        <bits name="LPS_PU_Ready" pos="4" access="r" rst="0">
            <comment>The Power-Up Sequence is in state <b>Ready</b>.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_PU_Times" protect="rw">
        <bits name="LPS_PU_tCO_S2" pos="4:0" access="rw" rst="0">
            <comment>Time in 32Khz clocks to wait between the states <b>Controlled Output step 1</b> and <b>Controlled Output step 2</b>.
            </comment>
        </bits>
        <bits name="LPS_PU_tCLK_RF_EN" pos="10:6" access="rw" rst="0">
            <comment>Time in 32Khz clocks to wait between the states <b>Controlled Output step 2</b> and <b>RF Clock Enable</b>.
            </comment>
        </bits>
        <bits name="LPS_PU_tCLK_RF" pos="23:12" access="rw" rst="all1">
            <comment>Time in 32Khz clocks to wait between the states <b>RF Clock Enable</b> and <b>RF Clock Ready</b>.
                <br/>This is the time to wait after VCO enable before switching to RF and starting the PLL.
            </comment>
        </bits>
        <bits name="LPS_PU_tCLK_PLL" pos="28:24" access="rw" rst="0">
            <comment>Time in 32Khz clocks to wait between the states <b>RF Clock Ready</b> and <b>Pll Clock Ready</b>.
                <br/>This is the time to wait after starting the PLL before switching to the Fast clock or checking if the PLL is locked.
            </comment>
        </bits>
        <bits name="LPS_PU_PLL_Lock" pos="31" access="rw" rst="0">
            <comment>If set waits for the lock status of the PLL after the LPS_PU_PLL time is elapsed before switching to the Fast Clock (in Fast step), else switch immediately after the expiration of the time.
            </comment>
            <options>
                <option name="Bypass" value="0"><comment>After expiration of the time LPS_PU_tClk_PLL go directly to the state <b>Pll Clock Ready</b>.</comment></option>
                <option name="Check" value="1"><comment>After expiration of the time LPS_PU_tClk_PLL, wait for the PLL to be locked before going to the state <b>Pll Clock Ready</b>.</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="LPS_PU_IRQ" protect="rw">
        <bits name="LPS_IRQ_Calibration_Done_Cause" pos="0" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the calibration is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_Slow_Running_Cause" pos="1" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the Slow Counter started.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Done_Cause" pos="2" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the Power-Up sequence is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Ready_Cause" pos="3" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the Power-Up sequence reached the state <b>Ready</b>.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Reached_Cause" pos="4" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the Power-Up frame was reached.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bitgroup name="LPS_PU_IRQ_Cause">
            <entry ref="LPS_IRQ_Calibration_Done_Cause"/>
            <entry ref="LPS_IRQ_Slow_Running_Cause"/>
            <entry ref="LPS_IRQ_PU_Done_Cause"/>
            <entry ref="LPS_IRQ_PU_Ready_Cause"/>
            <entry ref="LPS_IRQ_PU_Reached_Cause"/>
        </bitgroup>

        <bits name="LPS_IRQ_Calibration_Done_Status" pos="16" access="rc" rst="0">
            <comment>1 when the calibration is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_Slow_Running_Status" pos="17" access="rc" rst="0">
            <comment>1 when the Slow Counter started.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Done_Status" pos="18" access="rc" rst="0">
            <comment>1 when the Power-Up sequence is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Ready_Status" pos="19" access="rc" rst="0">
            <comment>1 when the Power-Up sequence reached the state <b>Ready</b>.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Reached_Status" pos="20" access="rc" rst="0">
            <comment>1 when the Power-Up frame was reached.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bitgroup name="LPS_PU_IRQ_Status">
            <entry ref="LPS_IRQ_Calibration_Done_Status"/>
            <entry ref="LPS_IRQ_Slow_Running_Status"/>
            <entry ref="LPS_IRQ_PU_Done_Status"/>
            <entry ref="LPS_IRQ_PU_Ready_Status"/>
            <entry ref="LPS_IRQ_PU_Reached_Status"/>
        </bitgroup>
    </reg>
    <reg name="LPS_PU_IRQ_Mask" protect="rw">
        <bits name="LPS_IRQ_Calibration_Done_Mask" pos="0" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_Calibration_Done is enabled.
            </comment>
        </bits>
        <bits name="LPS_IRQ_Slow_Running_Mask" pos="1" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_Slow_Running is enabled.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Done_Mask" pos="2" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_PU_Done is enabled.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Ready_Mask" pos="3" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_PU_Ready is enabled.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Reached_Mask" pos="4" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_PU_Reached is enabled.
            </comment>
        </bits>
        <bitgroup name="LPS_PU_IRQ_Mask">
            <entry ref="LPS_IRQ_Calibration_Done_Mask"/>
            <entry ref="LPS_IRQ_Slow_Running_Mask"/>
            <entry ref="LPS_IRQ_PU_Done_Mask"/>
            <entry ref="LPS_IRQ_PU_Ready_Mask"/>
            <entry ref="LPS_IRQ_PU_Reached_Mask"/>
        </bitgroup>
    </reg>
    <reg name="RX_GAIN_INTERVAL" protect="rw">
        <bits name="RX_GAIN_interval" pos="9:0" access="rw" rst="1001110000">
            <comment>New RX gain active period from TCU_EVENT(TCO_RX_DEC_ON) = 625 Qbit.
            </comment>
        </bits>
        <bits name="RX_GAIN_offset" pos="16:10" access="rw" rst="0">
            <comment>RX gain active time offset, -127 bits to 0 bits.
            </comment>
        </bits>
    </reg>
    <hole size="1280"/>
    <reg name="Event" protect="rw" count="NB_TCU_PROG_EVENTS">
        <bits name="Event_Time" pos="13:0" access="rw" rst="all1">
            <comment>The event Id will be executed when the TCU counter reaches the value programmed in Event time field of this register.
            </comment>
        </bits>
        <bits name="Event_Id" pos="21:16" access="rw" rst="all1">
            <comment>Event to be executed when the TCU counter reaches the programmed event time.
                <br/>
            </comment>
            <options linkenum="TCU_Event">
                <default />
            </options>
        </bits>
    </reg>

</module>

</archive>
<archive relative='timer.xml' >


<module name="timer" category="System">
    <var name = "NB_INTERVAL" value="1"/>
    <var name = "INT_TIMER_NB_BITS" value="24"/>
    <var name = "WD_TIMER_NB_BITS" value="24"/>
    <var name = "HW_TIMER_NB_BITS" value="32"/>
    <var name = "TIM_MAXVAL" value="0xffffff"/>

    <reg name="OSTimer_Ctrl" protect="rw">
        <bits name="LoadVal" pos="23:0" access="rw" rst="0">
            <comment>Value loaded to OS timer.
            </comment>
            <options>
            <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="Enable" pos="24" access="rw" rst="0">
            <comment>Write '1' to this bit will enable OS timer.
                <br/>When read, the value is what we have written to this bit, it changes immediately  after been written.
            </comment>
        </bits>
        <bits name="Enabled" pos="25" access="r" rst="0">
            <comment>Read this bit will get the information if OS timer is really enabled or not. This bit will change only after the next front of 16 KHz system clock.
                <br/>
                <br/>'1' indicates OS timer enabled.
                <br/>'0' indicates OS timer not enabled.
            </comment>
        </bits>
        <bits name="Cleared" pos="26" access="r" rst="0">
            <comment>Read this bit will get the information if OS timer interruption clear operation is finished or not.
                <br/>
                <br/>'1' indicates OS timer interruption clear operation is on going.
                <br/>'0' indicates no OS timer interruption clear operation is on going.
            </comment>
        </bits>
        <bits name="Repeat" pos="28" access="rw" rst="0">
            <comment>Write '1' to this bit will set OS timer to repeat mode.
                <br/>When read, get the information if OS timer is in repeat mode.
                <br/>
                <br/>'1' indicates OS timer in repeat mode.
                <br/>'0' indicates OS timer not in repeat mode.
            </comment>
        </bits>
        <bits name="Wrap" pos="29" access="rw" rst="0">
            <comment>Write '1' to this bit will set OS timer to wrap mode.
                <br/>When read, get the information if OS timer is in wrap mode.
                <br/>
                <br/>'1' indicates OS timer in wrap mode.
                <br/>'0' indicates OS timer not in wrap mode.
            </comment>
        </bits>
        <bits name="Load" pos="30" access="rw" rst="0">
            <comment>Write '1' to this bit will load the initial value to OS timer.
            </comment>
        </bits>
    </reg>
    <reg name="OSTimer_CurVal" protect="rw">
        <bits name="CurVal" pos="31:0" access="r" rst="-">
            <comment>Current value of OS timer. The value is 24 bits and the first 8 bits are sign extension of the most important bit. A negative value indicates that the timer has wraped.
            </comment>
        </bits>
    </reg>
    <reg name="WDTimer_Ctrl" protect="rw">
        <bits name="Start" pos="0" access="s" rst="0">
            <comment>Write '1' to this bit will enable watchdog timer and Load it with WDTimer_LoadVal.
            </comment>
        </bits>
        <bits name="WDEnabled" pos="3" access="r" rst="0">
            <comment>Read this bit will get the information if watchdog timer is really enabled or not. This bit will change only after the next front of 32 KHz system clock.
                <br/>
                <br/>'1' indicates watchdog timer is enabled, if current watchdog timer value reaches 0, the system will be reseted.
                <br/>'0' indicates watchdog timer is not enabled.
            </comment>
        </bits>
        <bits name="Stop" pos="4" access="c" rst="0">
            <comment>Write '1' to this bit will stop watchdog timer.
            </comment>
        </bits>
        <bits name="ReLoad" pos="16" access="w" rst="0">
            <comment>Write '1' to this bit will load WDTimer_LoadVal value to watchdog timer.
                <br/>Use this bit to implement the watchog keep alive.
            </comment>
        </bits>
    </reg>
    <reg name="WDTimer_LoadVal" protect="rw">
        <bits name="LoadVal" pos="WD_TIMER_NB_BITS-1:0" access="r" rst="-">
            <comment>Load value of watchdog timer. Number of 32kHz Clock before Reset.
                <br/>
            </comment>
            <options>
            <mask/><shift/><default/>
            </options>
        </bits>
    </reg>
    <reg name="HWTimer_Ctrl" protect="rw">
        <bits name="Interval_En" pos="8" access="rw" rst="0">
            <comment>This bit enables interval IRQ mode.
                <br/>
                <br/>'0': hw delay timer does not generate interval IRQ.
                <br/>'1': hw delay timer generate an IRQ each interval.
            </comment>
        </bits>
        <bits name="Interval" pos="1:0" access="rw" rst="00">
            <comment> interval of generating an HwTimer IRQ. 
                <br/>
                <br/>"00": interval of 1/8 second.
                <br/>"01": interval of 1/4 second.
                <br/>"10": interval of 1/2 second.
                <br/>"11": interval of 1 second.
            </comment>
        </bits>
    </reg>
    <reg name="HWTimer_CurVal" protect="rw">
        <bits name="CurVal" pos="31:0" access="r" rst="0">
            <comment>Current value of the hardware delay timer. The value is incremented every 61 us. This timer is running all the time and wrap at value 0xFFFFFFFF.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Mask_Set" protect="rw">
        <bits name="OSTimer_Mask" pos="0" access="rs" rst="0">
            <comment>Set mask for OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Mask" pos="1" access="rs" rst="0">
            <comment>Set mask for hardwre delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Mask" pos="2" access="rs" rst="0">
            <comment>Set mask for hardwre delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Mask_Clr" protect="rw">
        <bits name="OSTimer_Mask" pos="0" access="rc" rst="0">
            <comment>Clear mask for OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Mask" pos="1" access="rc" rst="0">
            <comment>Clear mask for hardwre delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Mask" pos="2" access="rc" rst="0">
            <comment>Clear mask for hardwre delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Clr" protect="rw">
        <bits name="OSTimer_Clr" pos="0" access="c">
            <comment>Clear OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Clr" pos="1" access="c">
            <comment>Clear hardware delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Clr" pos="2" access="c">
            <comment>Clear hardware delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Cause" protect="rw">
        <bits name="OSTimer_Cause" pos="0" access="r" rst="0">
            <comment>OS timer IRQ cause.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Cause" pos="1" access="r" rst="0">
            <comment>hardware delay timer wrap IRQ cause.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Cause" pos="2" access="r" rst="0">
            <comment>hardware delay timer interval IRQ cause.
            </comment>
        </bits>
        <bits name="OSTimer_Status" pos="16" access="r" rst="0">
            <comment>OS timer IRQ status.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Status" pos="17" access="r" rst="0">
            <comment>hardware delay timer wrap IRQ status.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Status" pos="18" access="r" rst="0">
            <comment>hardware delay timer interval IRQ status.
            </comment>
        </bits>
        <bitgroup name="Other_Tims_irq">
            <entry ref="HWTimer_Wrap_Cause"/>
            <entry ref="HWTimer_Itv_Cause"/>
        </bitgroup>
    </reg>
    <reg name="WD_Addr_cfg" protect="rw">
        <bits name="WD_Address" pos="25:0" access="rw" rst="no">
            <comment>
                Loaded during WatchDog reset with the XCPU current execution address.
            </comment>
        </bits>
    </reg>

</module>

</archive>


<archive relative='vitac.xml' >


<include file="globals.xml"/>

<module name="vitac" category="Baseband">
  <reg protect="rw" name="command">
    <bits access="rw" name="start_equ" pos="0" rst="0x0">
      <comment>Writing a '1' in this register triggers a Viterbi Equalization
      process. Ignored if any Viterbi process is already ongoing. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="start_dec" pos="1" rst="0x0">
      <comment>Writing a '1' in this register triggers a Viterbi Decoding
      process. Ignored if any Viterbi process is already ongoing. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="start_tb" pos="2" rst="0x0">
      <comment>Writing a '1' in this register triggers the TraceBack process.
      Ignored if any Viterbi process is already ongoing. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="int_mask" pos="3" rst="0x0">
      <comment>When this bit is set, it enables the generation of the
      VITAC_DONE_H interrupt. </comment>
    </bits>

    <bits access="rw" name="punctured" pos="4" rst="0x0">
      <comment>Indicates whether a puncturing scheme has to be used during
      decoding. If this bit is set to '0', the code is assumed unpunctured and
      no puncturing matrix is needed. </comment>
    </bits>

    <bits access="rw" name="nb_states" pos="6:5" rst="0x0">
      <comment>This field sets the number of states of the Trellis:
      <br />"00": 16 states <br />"01": 32 states <br />"10": 64 states
      <br />"11": reserved </comment>
    </bits>

    <bits access="rw" name="bkwd_trellis" pos="7" rst="0x0">
      <comment>When this bit is set, the channel symbols are treated in the
      reverse order, i.e. CH_SYMB_ADDR represents the end of the buffer and
      the symbols are read out backward. </comment>
    </bits>

    <bits access="rw" name="code_rate" pos="10:8" rst="0x0">
      <comment>This field sets the convolutional code rate for decoding:
      <br />"010": 1/2 rate <br />"011": 1/3 rate <br />"100": 1/4 rate
      <br />"101": 1/5 rate <br />"110": 1/6 rate <br />others: reserved
      </comment>
    </bits>

    <bits access="rw" name="bm_shift_lev" pos="14:11" rst="0x0">
      <comment>This field sets the amount of shift right applied at the output
      of the equalizer BM calculation: <br />"0000": BM = OUT[30:19]
      <br />"0001": BM = OUT[29:18] <br />... <br />"1111": BM = OUT[15:4]
      </comment>
    </bits>

    <bits access="rw" name="sv_shift_lev" pos="18:15" rst="0x0">
      <comment>This field sets the amount of shift right applied to the
      difference of the two metrics arriving at a node to create a Softvalue:
      <br />"0000": SoftVal = DELTA[15:9] <br />"0001": SoftVal =
      DELTA[14:8] <br />... <br />"1101": SoftVal = DELTA[2:0]&amp;"0000" <br />others:
      reserved </comment>
    </bits>

    <bits access="rw" name="nb_symbols" pos="28:20" rst="0x0">
      <comment>Number of symbols to be Equalized / Decoded. Auto decrement.
      </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="equ_pending" pos="0" rst="0x0">
      <comment>This bit is high when an equalization process is ongoing. It
      stays high when the module is stalled during operation. </comment>
    </bits>

    <bits access="r" name="dec pending" pos="1" rst="0x0">
      <comment>This bit is high when an decoding process is ongoing. It stays
      high when the module is stalled during operation. </comment>
    </bits>

    <bits access="r" name="tb_pending" pos="2" rst="0x0">
      <comment>This bit is high when an traceback process is ongoing. It stays
      high when the module is stalled during operation. </comment>
    </bits>

    <bits access="r" name="nb_rescales" pos="7:4" rst="0x0">
      <comment>After a Viterbi process, this field reports the number of
      rescaling operations that have been performed along the trellis.
      <br />This field is reset at every new Viterbi process. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch_symb_addr">
    <bits access="rw" name="addr" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>This is the start address of the channel symbols buffer in
      SRAM. For Equalization channel symbols are the sampled RF samples
      (2x12-bits packed complex values), and for Decoding channel symbols are
      a frame of softvalues (4x8-bits packed). <br />This address must be
      4-bytes aligned, bits[1:0] will be ignored. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="exp_symb_addr">
    <bits access="rw" name="addr" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>For Equalization, this is the base address of the partial sum
      terms buffer in SRAM. (2x12-bits packed complex values) <br />For
      Decoding, this is the base address of the puncturing matrix. <br />This
      address must be 4-bytes aligned, bits[1:0] will be ignored. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="pm_base_addr">
    <bits access="rw" name="addr" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>This is the base address in SRAM of the Path Metrics buffer.
      The VITAC will read and update PMs according to the scheme given in
      1.2.1.2. (2x16-bits packed values). <br />This address must be 4-bytes
      aligned, bits[1:0] will be ignored. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="out_base_addr">
    <bits access="rw" name="addr" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>This is the start address of the output buffer in SRAM. When in
      Equalizer mode, the VITAC will output the calculated Softvalues
      according to the scheme given in 1.2.1.7. When in Decoder mode, the
      VITAC will output the trace words according to the scheme given in
      1.2.2.4. <br />This address must be 4-bytes aligned, bits[1:0] will be
      ignored. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="H0_param">
    <bits access="rw" name="H0_I_part" pos="BB_SYMBOL_SIZE-1:0" rst="0x0">
      <comment>Real part of the h0 parameter of the estimated channel
      response. </comment>
    </bits>

    <bits access="rw" name="H0_Q_part" pos="BB_SYMBOL_SIZE+15:16" rst="0x0">
      <comment>Imaginary part of the h0 parameter of the estimated channel
      response. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="HL_param">
    <bits access="rw" name="HL_I_part" pos="BB_SYMBOL_SIZE-1:0" rst="0x0">
      <comment>Real part of the hL parameter of the estimated channel
      response. </comment>
    </bits>

    <bits access="rw" name="HL_Q_part" pos="BB_SYMBOL_SIZE+15:16" rst="0x0">
      <comment>Imaginary part of the hL parameter of the estimated channel
      response. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="rescale">
    <bits access="rw" name="threshold" pos="15:0" rst="0x0">
      <comment>This field indicates the threshold value to be reach by every
      PMs for triggering a rescale operation. The rescale operation consist in
      subtracting the threshold value to every PMs to avoid overflow during PM
      update. </comment>
    </bits>
  </reg>

  <reg protect="rw" count="3" name="res_poly">
    <comment>This register bank stores the less significant bit of the output
    from the coder for a particular code (see 1.2.2.1). The kth butterfly uses
    the bit k of this register. </comment>

    <bits access="rw" name="res_poly" pos="31:0" rst="0x0">
      <comment>This register stores the less significant bit of the output
      from the coder for a particular code (see 1.2.2.1). The kth butterfly
      uses the bit k of this register. </comment>
    </bits>
  </reg>

  <reg protect="r" name="int_status">
    <bits access="r" name="it_cause" pos="0" rst="0x0">
      <comment>This bit is set when the VITAC module finishes an ongoing
      operation. It can be masked by setting VITAC_CMD(IT_MASK) to '1'.
      <br />Resetting this bit is done by writing in IT_CLEAR register.
      <br />IT_CAUSE is the image of the VITAC_DONE_H interrupt line to the
      CPU. </comment>
    </bits>

    <bits access="r" name="it_status" pos="16" rst="0x0">
      <comment>This bit is the unmasked version of the IT_CAUSE bit.
      </comment>
    </bits>
  </reg>

  <reg protect="w" name="int_clear">
    <bits access="w" name="it_clear" pos="0" rst="0x0">
      <comment>Setting this bit to '1' resets the VITAC interrupt. </comment>
    </bits>
  </reg>
</module>

</archive>


<archive relative='xcor.xml' >


<include file="globals.xml"/>

<module name="xcor" category="Baseband">
  <var name="XCOR_SYMBOL_SIZE" value="VITAC_MULT_SIZE" />

  <var name="XCOR_SADDER_SIZE" value="XCOR_SYMBOL_SIZE+1 +6" />

  <reg name="command" protect="rw">
    <bits access="rw" name="biterr_en" pos="0" rst="0x0">
      <comment>Enables the Biterror calculation mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="dco1p_en" pos="1" rst="0x0">
      <comment>Enables the DC Offset Correction (1st pass) mode. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="dco2p_en" pos="2" rst="0x0">
      <comment>Enables the DC Offset Correction (2nd pass) mode. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="dco3p_en" pos="3" rst="0x0">
      <comment>Enables the DC Offset Correction (3rd pass) mode. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="tscxc_en" pos="4" rst="0x0">
      <comment>Enables the Training Sequence Cross-Correlation mode.
      Auto-reset. </comment>
    </bits>

    <bits access="rw" name="srec_en" pos="5" rst="0x0">
      <comment>Enables the Symbol Re-Construction mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="bext_en" pos="6" rst="0x0">
      <comment>Enables the Bit Extraction mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="sproc_en" pos="7" rst="0x0">
      <comment>Enables the Sum Of PROduCt mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="chest_en" pos="8" rst="0x0">
      <comment>Enables the Channel Estimation mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="fchxc_en" pos="9" rst="0x0">
      <comment>Enables the FCH Xcorrelation mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="sldwin_en" pos="10" rst="0x0">
      <comment>Enables the Sliding window mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="it_mask" pos="11" rst="0x0">
      <comment>Mask of the end of processing interrupt.</comment>
    </bits>

    <bits access="rw" name="pack_IQ" pos="12" rst="0x0">
      <comment>Data path setting. Pack I and Q on a single 32-bits word.
      </comment>
    </bits>

    <bits access="rw" name="derotation_en" pos="13" rst="0x0">
      <comment>Data path setting. Enables derotation for DCOC 3pass.
      </comment>
    </bits>

    <bits access="rw" name="nb_iloop" pos="23:16" rst="0x0">
      <comment>Control setting. Number of internal loop iteration. </comment>
    </bits>

    <bits access="rw" name="nb_symb" pos="31:24" rst="0x0">
      <comment>Control setting. Number of symbols to process. </comment>
    </bits>
  </reg>

  <reg name="status" protect="rw">
    <bits access="r" name="op_pending" pos="0" rst="0x0">
      <comment>This bit is high when an operation is ongoing.</comment>
    </bits>
    <bits access="r" name="it_cause" pos="16" rst="0x0">
      <comment>Masked version of it_status that goes to Interrupt controller.</comment>
    </bits>
    <bits access="rw" name="it_status" pos="31" rst="0x0">
        <comment>This bit is set high when an operation is finished. It must be reset before lauching a new operation if Xcor interrupt is enabled.</comment>
    </bits>
  </reg>

  <reg name="hv0" protect="rw">
    <comment>Multipurpose Data Register. <br /> Store Training Sequence in
    TSXC mode. <br /> Store SUM in DCOC 3rd pass mode. <br /> Store bit
    sequence in SREC mode. <br /> Store SUM in SPROC mode. <br /> Store I SUM
    in CHEST mode. <br /> Store R(k-1) in FCHXC mode. </comment>

    <bits access="rw" name="hv0" pos="31:0" rst="0x0">
      <comment>Multipurpose. </comment>
    </bits>
  </reg>

  <reg name="hv1" protect="rw">
    <comment>Multipurpose Data Register. <br /> Store Training Sequence in
    TSXC mode. <br /> Store bit sequence in SREC mode. <br /> Store Q SUM in
    CHEST mode. </comment>

    <bits access="rw" name="hv1" pos="31:0" rst="0x0">
      <comment>Multipurpose. </comment>
    </bits>
  </reg>

  <reg count="6" name="data" protect="rw">
    <comment>Multipurpose Data Registers. <br />D0 stores
    symbols/softvalues/channel taps depending on mode. Not readable. <br />D1
    stores decoded bits/IQ threshols/IQ Offsets/A terms depending on mode. Not
    readable. <br />D2 (aka A1) serves as Rd address (decoded bits, A or B
    terms) / Wr address register (I or packed IQ results, Symbols) / event
    counter depending on mode. <br />D3 (aka A2) serves as Wr address (Q
    results) / event counter depending on mode. <br />D4 stores results from
    VITAC / extracted HardValues depending on mode. Not readable.<br />D5 (aka
    A3) serves as Wr address (CQ results) Not readable. </comment>

    <bits access="rw" name="data" pos="31:0" rst="0x0">
      <comment>Multipurpose. </comment>
    </bits>
  </reg>

  <reg name="accuI" protect="r">
    <bits access="r" name="accuI" pos="XCOR_SADDER_SIZE-1:0" rst="0x0">
      <comment>I part accumulator register.</comment>
    </bits>
  </reg>

  <reg name="accuQ" protect="r">
    <bits access="r" name="accuQ" pos="XCOR_SADDER_SIZE-1:0" rst="0x0">
      <comment>I part accumulator register.</comment>
    </bits>
  </reg>

  <reg name="addr0" protect="rw">
    <comment>Address 0 Register. <br />Stores Rd address for symbols /
    SoftValues / A terms depending on mode. <br /> Auto
    increment/decrement/reset. </comment>

    <bits access="rw" name="addr0" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>32-bit word address (bits 0 and 1 disregarded). </comment>
    </bits>
  </reg>
  
  <reg count="6" name="data_e" protect="rw">
    <comment>Multipurpose Data Edge Registers. </comment>

    <bits access="rw" name="data" pos="31:0" rst="0x0">
      <comment>Multipurpose. </comment>
    </bits>
  </reg>
  
</module>

</archive>
<archive relative='cp0.xml'  asm="no">

<cjoker>

/* Cause register exception codes */

#define ExcCode(x)      ((x)&lt;&lt;2)

/* Hardware exception codes */
#define ExcCode_INT     ExcCode(0)      /* interrupt */
#define ExcCode_MOD     ExcCode(1)      /* TLB modification */
#define ExcCode_TLBL    ExcCode(2)      /* TLB miss, load or fetch */
#define ExcCode_TLBS    ExcCode(3)      /* TLB miss, store */
#define ExcCode_AdEL    ExcCode(4)      /* Read Address Error */
#define ExcCode_AdES    ExcCode(5)      /* Write Address Error */
#define ExcCode_IBE     ExcCode(6)      /* Instruction Bus Error */
#define ExcCode_DBE     ExcCode(7)      /* Data Bus Error */
#define ExcCode_SYSCALL ExcCode(8)      /* SYSCALL */
#define ExcCode_BREAK   ExcCode(9)      /* BREAKpoint */
#define ExcCode_RI      ExcCode(10)     /* Illegal Instruction */
#define ExcCode_CpU     ExcCode(11)     /* CoProcessor Unusable */
#define ExcCode_Ovf     ExcCode(12)     /* OVerflow */

/*
 * cp0 registers
 */
#define Index           $0
#define Random          $1
#define EntryLo         $2
#define Context         $4
#define BadVAddr        $8
#define EntryHi         $10
#define Status          $12
#define Cause           $13
#define EPC             $14
#define PRId            $15


/*
 * Mask for Index Register
 */
#define Index_P         0x80000000      /* Probe Failure bit */
#define Index_Index     0x00003f00      /* Index field */

/*
 * Random register 
 */
#define Random_Index    0x00003f00      /* Random field */

/*
 * Entry Low
 */
#define EntryLo_PFN     0xfffff000      /* page frame number field */
#define EntryLo_N       0x00000800      /* non cachable */
#define EntryLo_D       0x00000400      /* dirty */
#define EntryLo_V       0x00000200      /* valid bit */
#define EntryLo_G       0x00000100      /* global bit */

/*
 * Context register 
 */
#define Context_PTEBase 0xffe00000      /* base for page table entry */
#define Context_BadVPN  0x001ffffc      /* failing virtual page number */

/*
 * Entry High Register
 */
#define EntryHi_VPN     0xfffff000      /* virtual page number field */
#define EntryHi_PID     0x00000fc0      /* process ID field */

/*
 * PRId Register
 */
#define PRID_Imp        0x0000ff00      /* implementation ID */
#define PRID_Rev        0x000000ff      /* revision ID */

/*
 * Status register
 */
#define Status_CUMASK   0xf0000000      /* coproc usable bits */
#define Status_RE       0x02000000      /* Bootstrap exception vector */
#define Status_BEV      0x00400000      /* Bootstrap exception vector */
#define Status_TS       0x200000        /* TLB Shutdown bit */
#define Status_IntMASK  0xff00          /* Interrupt mask */
#define Status_KUo      0x0020          /* old kernel/user, 0 =&gt; k, 1 =&gt; u */
#define Status_IEo      0x0010          /* old interrupt enable, 1 =&gt; ena */
#define Status_KUp      0x0008          /* prev kernel/user, 0 =&gt; k, 1 =&gt; u */
#define Status_IEp      0x0004          /* prev interrupt enable, 1 =&gt; ena */
#define Status_KUc      0x0002          /* cur kernel/user, 0 =&gt; k, 1 =&gt; u */
#define Status_IEc      0x0001          /* cur interrupt enable, 1 =&gt; enable*/

/*
 * Cause Register
 */
#define Cause_BD        0x80000000      /* Branch delay slot */
#define Cause_CE        0x30000000      /* coprocessor error */
#define Cause_IP        0xff00          /* Pending interrupt mask */
#define Cause_SIP       0x0300          /* Pending software interrupt mask */
#define Cause_HIP       0xfc00          /* Pending hardware interrupt mask */
#define Cause_ExcCode   0x003C          /* Exception code bits */

#define DRAM_HANDLER    0x80c00200      /* address of exception handler */
#define EPROM_HANDLER   0xa0e00180      /* address of exception handler BEV */

</cjoker>
</archive>
<archive relative='regdef.xml'  asm="no">

<cjoker>
/* Set or not mips16 */
#ifdef CT_ASM_MIPS16
#define SET_P_MIPS16 .set mips16
#else
#define SET_P_MIPS16 .set nomips16
#endif 

#define zero    $0
#define AT      $at
#define v0      $2
#define v1      $3
#define a0      $4
#define a1      $5
#define a2      $6
#define a3      $7
#define t0      $8
#define t1      $9
#define t2      $10
#define t3      $11
#define t4      $12
#define t5      $13
#define t6      $14
#define t7      $15
#define s0      $16
#define s1      $17
#define s2      $18
#define s3      $19
#define s4      $20
#define s5      $21
#define s6      $22
#define s7      $23
#define t8      $24
#define t9      $25
#define k0      $26
#define k1      $27
#define gp      $28
#define sp      $29
#define fp      $30
#define ra      $31

#define r0      $0
#define r1      $1
#define r2      $2
#define r3      $3
#define r4      $4
#define r5      $5
#define r6      $6
#define r7      $7
#define r8      $8
#define r9      $9
#define r10     $10
#define r11     $11
#define r12     $12
#define r13     $13
#define r14     $14
#define r15     $15
#define r16     $16
#define r17     $17
#define r18     $18
#define r19     $19
#define r20     $20
#define r21     $21
#define r22     $22
#define r23     $23
#define r24     $24
#define r25     $25
#define r26     $26
#define r27     $27
#define r28     $28
#define r29     $29
#define r30     $30
#define r31     $31

#define fp0     $f0
#define fp1     $f1
#define fp2     $f2
#define fp3     $f3
#define fp4     $f4
#define fp5     $f5
#define fp6     $f6
#define fp7     $f7
#define fp8     $f8
#define fp9     $f9
#define fp10    $f10
#define fp11    $f11
#define fp12    $f12
#define fp13    $f13
#define fp14    $f14
#define fp15    $f15
#define fp16    $f16
#define fp17    $f17
#define fp18    $f18
#define fp19    $f19
#define fp20    $f20
#define fp21    $f21
#define fp22    $f22
#define fp23    $f23
#define fp24    $f24
#define fp25    $f25
#define fp26    $f26
#define fp27    $f27
#define fp28    $f28
#define fp29    $f29
#define fp30    $f30
#define fp31    $f31

#define fpucntl $31

</cjoker>
</archive>
<archive relative='xcpu_cache.xml' >

<module name="xcpu_cache" category="Debug">

    <struct name="Line" count="exp2(8)">
        <reg name="Data" protect="rw" count="4">
        <comment>The XCpu cache is accessible only when it is disabled or the cpu is stalled.
            <br/>The bits "3:0" of the address select the Data in the line.
            <br/>The bits "13:4" of the address select the line.
            <br/>If the Tag at the corresponding line is valid, the bits "25:14" of the tag are the corresponding address bits.
        </comment>
            <bits name="data" pos="31:0" access="rw">
            </bits>
        </reg>
    </struct>
</module>
</archive>
<archive relative='xcpu_tag.xml' >

<module name="xcpu_tag" category="Debug">

    <reg name="Line" protect="rw" count="exp2(8)">
        <comment>The XCpu tags are accessible only when the corresponding cache is disabled or the cpu is stalled.
            <br/>The bits "13:4" of the address select the line
        </comment>
        <bits name="Tag" pos="25:14" access="rw">
            <comment>The Tag represents the bits "25:14" of the address present in the corresponding cache Line.
            </comment>
            <options><default/><shift/><mask/></options>
        </bits>
        <bits name="Valid" pos="29" access="rw">
            <comment>When 1 the Tag is valid
            </comment>
            <options><default/><shift/><mask/></options>
        </bits>
    </reg>
</module>
</archive>
<archive relative='xcpu.xml' >

<module name="xcpu" category="Debug">
    <hole size="32"/>
    <reg name="rf0_addr" protect="r">
        <bits name="rf0_addr" pos="31:0" access="r" rst="0">
            <comment>program counter for the RF stage.
            </comment>
        </bits>
    </reg>
    <hole size="3104"/>
    <reg name="cp0_adr_BadVAddr" protect="r">
        <bits name="cp0_adr_BadVAddr" pos="31:0" access="r" rst="0"/>
    </reg>
    <reg name="cp0_Cause" protect="r">
        <bits name="cp0_Cause_ExcCode" pos="5:2" access="r" rst="0">
            <options>
                <option value="0" name="Int"><comment>Interrupt</comment></option>
                <option value="1" name="Mod"><comment>TLB modification exception</comment></option>
                <option value="2" name="TLBL"><comment>TLB exception (load or instruction fetch)</comment></option>
                <option value="3" name="TLBS"><comment>TLB exception (store)</comment></option>
                <option value="4" name="AdEL"><comment>Address error exception (load or instruction fetch)</comment></option>
                <option value="5" name="AdES"><comment>Address error exception (store)</comment></option>
                <option value="6" name="IBE"><comment>Bus error exception (instruction fetch)</comment></option>
                <option value="7" name="DBE"><comment>Bus error exception (data reference: load or store)</comment></option>
                <option value="8" name="Sys"><comment>Syscall exception</comment></option>
                <option value="9" name="Pb"><comment>Breakpoint exception</comment></option>
                <option value="10" name="Ri"><comment>Reserved instruction exception</comment></option>
                <option value="11" name="CpU"><comment>Coprocessor Unusable exception</comment></option>
                <option value="12" name="Ov"><comment>Arithmetic Overflow exception</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Cause_IP_soft" pos="9:8" access="r" rst="0">
            <comment>Theses interrupt lines are software interrupts (the cpu can write in the CP0 bits to trigger and clear them).
            </comment>
            <options>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Cause_IP_ext" pos="15:10" access="r" rst="0">
            <comment>Theses interrupt lines maps to the hardware interrupt lines from the corresponding irq module.
            </comment>
            <options>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bitgroup name="cp0_Cause_IP">
            <entry ref="cp0_Cause_IP_soft"/>
            <entry ref="cp0_Cause_IP_ext"/>
        </bitgroup>
        <bits name="cp0_Cause_CE" pos="29:28" access="r" rst="0">
            <comment>The Coprocessor Error (CE) field indicate the coprocessor unit number referenced when a Coprocessor Unusable exception is taken.
            </comment>
            <options>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Cause_BD" pos="31" access="r" rst="0">
            <comment>The Branch Delay (BD) bit indicate whether the last exception was taken while executing in a branch delay slot.
            </comment>
            <options>
                <option value="0" name="Normal"/>
                <option value="1" name="Delay_slot"/>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name="cp0_Status" protect="r">
        <bits name="cp0_Status_IEc" pos="0" access="r" rst="0">
            <comment>Current Interrupt Enable
            </comment>
            <options>
                <option value="0" name="disable"/>
                <option value="1" name="enable"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Status_KUc" pos="1" access="r" rst="0">
            <comment>Current Kernel/User mode
            </comment>
            <options>
                <option value="0" name="kernel"/>
                <option value="1" name="user"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Status_IEp" pos="2" access="r" rst="0">
            <comment>Previous Interrupt Enable
            </comment>
            <options>
                <option value="0" name="disable"/>
                <option value="1" name="enable"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Status_KUp" pos="3" access="r" rst="0">
            <comment>Previous Kernel/User mode
            </comment>
            <options>
                <option value="0" name="kernel"/>
                <option value="1" name="user"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Status_IEo" pos="4" access="r" rst="0">
            <comment>Old Interrupt Enable
            </comment>
            <options>
                <option value="0" name="disable"/>
                <option value="1" name="enable"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Status_KUo" pos="5" access="r" rst="0">
            <comment>Old Kernel/User mode
            </comment>
            <options>
                <option value="0" name="kernel"/>
                <option value="1" name="user"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="cp0_Status_KUi" pos="6" access="r" rst="0">
        </bits>
        <bits name="cp0_Status_IntMask" pos="15:8" access="r" rst="0">
            <comment>Interrupt Mask control the enabling of each of the external and software interrupts. (See Cause for more information on interruptions).
            </comment>
        </bits>
        <bits name="cp0_Streaming_Disable" pos="16" access="r" rst="0">
            <comment>This bit control handling of non-cached instruction fetch requests. By default, the system block reads multiple words of data from the AMBA bus in burst transactions and saves them in the Streaming Buffer. Non cached instruction fetch requests get their data directly from the Streaming Buffer.
            When "1" the cpu does not use the streaming buffer and does not ask for burst requests on the AMBA bus for non-cache instruction fetch requests.
            </comment>
        </bits>
        <bits name="cp0_Status_CM" pos="19" access="r" rst="0">
            <comment>Cache Miss
            <br/>Signals that the most recent access to the cachable space resulted in cache miss.
            </comment>
        </bits>
        <bits name="cp0_Status_TS" pos="21" access="r" rst="0">
            <comment>Signals that 2 entries in the TLB matched the virtual address. This is an error condition but the processor takes no action other than signalling it via this bit in the Status Register.
            </comment>
        </bits>
        <bits name="cp0_Status_BEV" pos="22" access="r" rst="1">
            <comment>Select the location of the exception vectors in ROM or in DRAM.
            </comment>
        </bits>
        <bits name="cp0_Status_RE" pos="25" access="r" rst="0">
            <comment>Reverse Endian in User mode. <font color="red">(probably unused in xcpu)</font></comment>
        </bits>
        <bits name="cp0_Status_CU_0" pos="28" access="r" rst="0" cut="1">
            <comment>Control the Usability of the corresponding Coprocessor Unit. (CP0 is always usable when in Kernel mode, regardless of the setting of the CU_0 bit.
            </comment>
        </bits>
        <bits name="cp0_Status_CU_123" pos="31:29" access="r" rst="0" cut="1" cutprefix="cp0_Status_CU" cutstart="1">
            <comment>Control the Usability of the corresponding Coprocessor Unit.
            </comment>
        </bits>
        <bitgroup name="cp0_Status_CU">
            <entry ref="cp0_Status_CU_0"/>
            <entry ref="cp0_Status_CU_123"/>
        </bitgroup>
    </reg>
    <reg name="cp0_EPC" protect="r">
        <bits name="cp0_EPC" pos="31:0" access="r" rst="0">
            <comment>Exception Program Counter. Saves the value of the program counter for the instruction
                that caused the exception.
            </comment>
        </bits>
    </reg>
    <hole size="160"/>
    <reg name="cp0_BadVAddr" protect="r">
        <bits name="cp0_BadVAddr" pos="31:0" access="r" rst="0">
            <comment>Bad virtual address. Saves the address that caused the address exception.
            </comment>
        </bits>
    </reg>
    <hole size="608"/>
    <reg name="rf0_data" protect="r">
        <bits name="rf0_data" pos="31:0" access="r" rst="0"/>
    </reg>
    <hole size="160"/>
    <reg name="dc0_result" protect="r">
        <bits name="dc0_result" pos="31:0" access="r" rst="0"/>
    </reg>
    <hole size="2848"/>
    
    <hole size="32"/> 

    <reg name="Regfile_AT" protect="r">
        <bits name="AT" pos="31:0" access="r" rst="no">
            <comment>assembler temporary register;
                their values are not preserved across procedure calls.
            </comment>  
        </bits>    
    </reg>
    <reg name="Regfile_V0" protect="r">
        <bits name="V0" pos="31:0" access="r" rst="no">
            <comment>Used for expression evaluations and for hold integer function results.
            <br/> Also used to pass the statuc link when calling nested procedure.
            </comment>
        </bits>    
    </reg>
    <reg name="Regfile_V1" protect="r">
        <bits name="V1" pos="31:0" access="r" rst="no">
            <comment>Used for expression evaluations and for hold integer function results.
            <br/> Also used to pass the statuc link when calling nested procedure.
            </comment>      
        </bits>    
    </reg>
    <reg name="Regfile_A0" protect="r">
        <bits name="A0" pos="31:0" access="r" rst="no">
            <comment>register A0 to A3 is used to pass the first 4 words of integer type actual arguments;
                their values are not preserved across procedure calls.
            </comment>      
        </bits>              
    </reg>
    <reg name="Regfile_A1" protect="r">
        <bits name="A1" pos="31:0" access="r" rst="no">
            <comment>register A0 to A3 is used to pass the first 4 words of integer type actual arguments;
                their values are not preserved across procedure calls.
            </comment>             
        </bits>              
    </reg>
    <reg name="Regfile_A2" protect="r">
        <bits name="A2" pos="31:0" access="r" rst="no">
            <comment>register A0 to A3 is used to pass the first 4 words of integer type actual arguments;
                their values are not preserved across procedure calls.
            </comment> 
        </bits>              
    </reg>
    <reg name="Regfile_A3" protect="r">
        <bits name="A3" pos="31:0" access="r" rst="no">
            <comment>register A0 to A3 is used to pass the first 4 words of integer type actual arguments;
                their values are not preserved across procedure calls.
            </comment>         
        </bits>              
    </reg>
    <reg name="Regfile_T0" protect="r">
        <bits name="T0" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>             
        </bits>              
    </reg>
    <reg name="Regfile_T1" protect="r">
        <bits name="T1" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_T2" protect="r">
        <bits name="T2" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_T3" protect="r">
        <bits name="T3" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_T4" protect="r">
        <bits name="T4" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_T5" protect="r">
        <bits name="T5" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_T6" protect="r">
        <bits name="T6" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_T7" protect="r">
        <bits name="T7" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_S0" protect="r">
        <bits name="S0" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name="Regfile_S1" protect="r">
        <bits name="S1" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name="Regfile_S2" protect="r">
        <bits name="S2" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name="Regfile_S3" protect="r">
        <bits name="S3" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name="Regfile_S4" protect="r">
        <bits name="S4" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name="Regfile_S5" protect="r">
        <bits name="S5" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name="Regfile_S6" protect="r">
        <bits name="S6" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name="Regfile_S7" protect="r">
        <bits name="S7" pos="31:0" access="r" rst="no">
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name="Regfile_T8" protect="r">
        <bits name="T8" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>             
        </bits>              
    </reg>
    <reg name="Regfile_T9" protect="r">
        <bits name="T9" pos="31:0" access="r" rst="no">
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>             
        </bits>              
    </reg>
    <reg name="Regfile_K0" protect="r">
        <bits name="K0" pos="31:0" access="r" rst="no">
            <comment>reserved for the operating system kernal.
            </comment>             
        </bits>              
    </reg>
    <reg name="Regfile_K1" protect="r">
        <bits name="K1" pos="31:0" access="r" rst="no">
            <comment>reserved for the operating system kernal.
            </comment>         
        </bits>              
    </reg>
    <reg name="Regfile_GP" protect="r">
        <bits name="GP" pos="31:0" access="r" rst="no">
            <comment>contains the global pointer.
            </comment>         
        </bits>              
    </reg>
    <reg name="Regfile_SP" protect="r">
        <bits name="SP" pos="31:0" access="r" rst="no">
            <comment>contains the stack pointer.
            </comment>             
        </bits>              
    </reg>
    <reg name="Regfile_S8" protect="r">
        <bits name="S8" pos="31:0" access="r" rst="no">
            <comment>a saved register (like s0-s7).
            </comment>             
        </bits>              
    </reg>
    <reg name="Regfile_RA" protect="r">
        <bits name="RA" pos="31:0" access="r" rst="no">
            <comment>contains the return address; used for expression evaluation.
            </comment>             
        </bits>              
    </reg>
    <hole size="512"/>
    <reg name="Debug_Page_Address" protect="rw">
        <bits name="Debug_Page_Address" pos="3:0" access="rw" rst="0">
            <comment>Debug Page Address Register Is a 4 bit register used for extending the address of
the debug to enable full access to the cache RAMs.
                <br/>bit 3 is used when accessing the TAGs to select between Instruction TAG (0) or Data TAG (1).
            </comment>
            <options>
                <option name="ITag" value="0"/>
                <option name="DTag" value="8"/>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>
    <reg name="Cache_Control" protect="rw">
        <bits name="Dcache_Inhibit" pos="0" access="rw" rst="no">
            <comment>when "ON" all accesses for data are treated as non cache. Data is fetched directly from main memory. The content of the Data Cache is not altered.
            </comment>
        </bits>
        <bits name="Icache_Inhibit" pos="1" access="rw" rst="no">
            <comment>when "ON" all accesses for instructions are treated as non cache. Data is fetched directly from main memory. The content of the cache is not altered.
            </comment>
        </bits>
        <bits name="Cache Hit Disable" pos="2" access="rw" rst="no">
            <comment>when "ON" all accesses to either Instruction or data caches result in a cache miss and a cache refill. This is a quick way to initialize the caches.
            </comment>
        </bits>
    </reg>
</module>
</archive>
<archive relative='calendar.xml' >

<module name="calendar" category="System">

    <reg name="Ctrl" protect="wr">

        <bits name="Interval" pos="1:0" access="wr" rst="0">
            <options>
                <default/>
                <option name="DISABLE" value="0"/>
                <option name="PER SEC" value="1"/>
                <option name="PER MIN" value="2"/>
                <option name="PER HOUR" value="3"/>
            </options>
            <comment>These 2 bits configure the interval of generating an IRQ status.
            </comment>
        </bits>
    </reg>
    
    <reg name="Cmd" protect="rw">
        <bits name="Calendar_Load" pos="0" access="rs" rst="0">
            <comment>When write, command to program calendar with a new value (sec, min, hour, day, month, year, day of week) previously written in registers Calendar_LoadVal_H and Calendar_LoadVal_L. This bit is auto cleared.
                <br/>'1' = load calendar timer.  
                <br/>
                <br/>When read, Calendar timer load status.
                <br/>'1' = Calendar load has not finished.
                <br/>'0' = Calendar load has finished.
            </comment>
        </bits>
        <bits name="Alarm_Load" pos="4" access="rs" rst="0">
            <comment>When write, command to program alarm with a new value (sec, min, hour, day, month, year, day of week) prviously written in registers AlarmVal_H and AlarmVal_L. This bit is auto cleared. 
                <br/>'1' = load alarm.
                <br/>
                <br/>When read, alarm load status.
                <br/>'1' = alarm load has not finished.
                <br/>'0' = alarm load has finished.
            </comment>
        </bits>
        <bits name="Alarm_Enable_Set" pos="5" access="rs" rst="0">
            <comment>command to enable alarm. When alarm is triggered, it will generate a wakup.
                <br/>'1' = enable alarm.
                <br/>
                <br/>When read, alarm enable status.
                <br/>'1' = alarm enable operation is on going, not finished.
                <br/>'0' = alarm is enabled.                  
            </comment>
        </bits>
        <bits name="Alarm_Enable_Clr" pos="6" access="rc" rst="0">
            <comment>command to disable alarm.
                <br/>'1' = disable alarm.
                <br/>
                <br/>When read, alarm enable status.
                <br/>'1' = alarm disable operation is on going, not finished.
                <br/>'0' = alarm is disabled.                  
            </comment>
        </bits>
        <bits name="Alarm_Clr" pos="8" access="rc" rst="0">
            <comment>writing '1', clear Alarm triggered signal (connect to wakeup) and alarm triggered IRQ.
                <br/>
                <br/>When read, get alarm clear status.
                <br/>'1' = alarm clear operation is on going, not finished.
                <br/>'0' = alarm is cleared.                  
            </comment>
        </bits>
        <bits name="Itv_Irq_Clr" pos="9" access="c" rst="0">
            <comment>writing '1', clear interval IRQ.
            </comment>
        </bits>
        <bits name="Itv_Irq_Mask_Set" pos="16" access="rs" rst="0">
            <comment>When write '1', Set interval Irq Mask. 
                <br/>When read, get interval Irq mask.
            </comment>
        </bits>        
        <bits name="Itv_Irq_Mask_Clr" pos="17" access="rc" rst="0">
            <comment>When write '1', Clear interval Irq Mask. 
                <br/>When read, get inteval Irq mask.
            </comment>
        </bits>               
        <bits name="Calendar_Not_Valid" pos="31" access="rs" rst="0">
            <comment>When write '1', mark calendar value to be not valid.
                <br/>
                <br/>When read, Indicate if the Calendar value is valid or not.
                <br/>The calendar value is not valid in case of mismatch between the calendar counter and the APB register,
                    which is the case of wakeup the phone after shut down. This mismatch disappear after one RTC cycle or 
                    after re-porgramming a new calendar value. 
                <br/>'1' = not valid.
            </comment>
        </bits>        
    </reg>

    <reg name="Status" protect="r">
        
        <bits name="Itv_Irq_Cause" pos="0" access="r" rst="0">
            <comment>Interval Irq Cause. 
            </comment>
        </bits>    
        <bits name="Alarm_Irq_Cause" pos="1" access="r" rst="0">
            <comment>Alarm Irq Cause. 
            </comment>
        </bits> 
        <bits name="Force_Wakeup" pos="8" access="r" rst="0">
             <comment>Force Wakeup status. After set "Force_Wakeup" to '1' in sys_ctrl, the real
                 force_wakeup is not set immediatly, this bit indicates when the force wakeup is 
                 really set. This bits also indicates if the interface between Calendar domain and
                 Core domain is enabled. 
                <br/>'1': force wakeup set.
            </comment>
        </bits>           
        <bits name="Chg_Mask" pos="12" access="r" rst="0">
             <comment>Charger Mask status. After set "Chg_Mask" to '1' in sys_ctrl, the real
                 Chg_Mask line is not set immediatly, this bit indicates when the Chg_Mask line is
                 really set.                
                <br/>'1': Chg_Mask line set.
            </comment>
        </bits>           
        <bits name="Itv_Irq_Status" pos="16" access="r" rst="0">
            <comment>Interval Irq Status. 
            </comment>
        </bits>        
        <bits name="Alarm_Enable" pos="20" access="r" rst="0">
            <comment>Alarm Enable Status. 
                <br/> Note: When calendar is not programmed, Alarm can be enabled or not. 
                <br/> It is suggested to clear Alarm Enable when program RTC. 
            </comment>
        </bits>          
        <bits name="Calendar_Not_Prog" pos="31" access="r" rst="0">
            <comment>'1' = Calendar has not been programmed. 
                <br/>This bit keep value '0' after the calendar is programmed once.
            </comment>
        </bits>
    </reg>

    <reg name="Calendar_LoadVal_L" protect="rw">
        <bits name="Sec" pos="5:0" access="rw" rst="-">
            <comment>Second value loaded to calendar, ranged from 0 to 59. 
            </comment>
        </bits>         
        <bits name="Min" pos="13:8" access="rw" rst="-">
            <comment>Minute value loaded to calendar, ranged from 0 to 59. 
            </comment>
        </bits>          
        <bits name="Hour" pos="20:16" access="rw" rst="-">
            <comment>Hour value loaded to calendar, ranged from 0 to 23. 
            </comment>
        </bits>         
    </reg>

    <reg name="Calendar_LoadVal_H" protect="rw">
        <bits name="Day" pos="4:0" access="rw" rst="-">
            <comment>Day value loaded to calendar, ranged from 1 to 31. 
            </comment>
        </bits>         
        <bits name="Mon" pos="11:8" access="rw" rst="-">
            <comment>Month value loaded to calendar, ranged from 1 to 12. 
            </comment>
        </bits>          
        <bits name="Year" pos="22:16" access="rw" rst="-">
            <comment>Year value loaded to calendar, ranged from 0 to 127. 
                <br/>Represent year 2000 to 2127.
            </comment>
        </bits>
        <bits name="WeekDay" pos="26:24" access="rw" rst="-">
            <comment>Day of the week value loaded to calendar, ranged from 1 to 7.
                <br/>Represent Monday, Tuesday etc.
            </comment>
        </bits>
    </reg>

    <reg name="Calendar_CurVal_L" protect="r">
        <bits name="Sec" pos="5:0" access="r" rst="-">
            <comment>Current Second value of calendar, ranged from 0 to 59. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Min" pos="13:8" access="r" rst="-">
            <comment>Current Minute value of calendar, ranged from 0 to 59. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="Hour" pos="20:16" access="r" rst="-">
            <comment>Current Hour value of calendar, ranged from 0 to 23. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>         
    </reg>
    
    <reg name="Calendar_CurVal_H" protect="r">
        <bits name="Day" pos="4:0" access="r" rst="-">
            <comment>Current Day value of calendar, ranged from 1 to 31. 
                <br/>Maximum number of days in each month are stored in the module,
                and leap year is supported, so February can have 28 or 29 days.  
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>         
        <bits name="Mon" pos="11:8" access="r" rst="-">
            <comment>Current Month value of calendar, ranged from 1 to 12. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="Year" pos="22:16" access="r" rst="-">
            <comment>Current Year value of calendar, ranged from 0 to 127. 
                <br/>Represent year 2000 to 2127.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="WeekDay" pos="26:24" access="r" rst="-">
            <comment>Current Day of the week value of calendar, ranged from 1 to 7.
                <br/>Represent Monday, Tuesday etc.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
     
    <reg name="AlarmVal_L" protect="rw">
        <bits name="Sec" pos="5:0" access="rw" rst="-">
            <comment>Second value loaded to alarm, ranged from 0 to 59. 
            </comment>
        </bits>         
        <bits name="Min" pos="13:8" access="rw" rst="-">
            <comment>Minute value loaded to alarm, ranged from 0 to 59. 
            </comment>
        </bits>          
        <bits name="Hour" pos="20:16" access="rw" rst="-">
            <comment>Hour value loaded to alarm, ranged from 0 to 23. 
            </comment>
        </bits>         
    </reg>

    <reg name="AlarmVal_H" protect="rw">
        <bits name="Day" pos="4:0" access="rw" rst="-">
            <comment>Day value loaded to alarm, ranged from 1 to 31. 
            </comment>
        </bits>         
        <bits name="Mon" pos="11:8" access="rw" rst="-">
            <comment>Month value loaded to alarm, ranged from 1 to 12. 
            </comment>
        </bits>          
        <bits name="Year" pos="22:16" access="rw" rst="-">
            <comment>Year value loaded to alarm, ranged from 0 to 127. 
                <br/>Represent year 2000 to 2127.
            </comment>
        </bits>
    </reg>
    
    
</module>



</archive>

<archive relative='cfg_regs.xml' >


<var name="PROD_ID" value="0x8810"/>

<module name="cfg_regs">
    
    <enum name="BB_GPIO_mapping">
        <entry name="BB_PIN_NONE_0"><comment>BB GPIO Map</comment></entry>
        <entry name="BB_PIN_1"/>
        <entry name="BB_PIN_2"/>
        <entry name="BB_PIN_3"/>
        <entry name="BB_PIN_4"/>
        <entry name="BB_PIN_5"/>
        <entry name="BB_PIN_UART1_RXD"/>
        <entry name="BB_PIN_UART2_RXD"/>
        <entry name="BB_PIN_UART2_TXD"/>
        <entry name="BB_PIN_SSD1_CLK"/>
        <entry name="BB_PIN_SSD1_CMD"/>
        <entry name="BB_PIN_SDAT1_0"/>
        <entry name="BB_PIN_SDAT1_1"/>
        <entry name="BB_PIN_SDAT1_2"/>
        <entry name="BB_PIN_SDAT1_3"/>
        <entry name="BB_PIN_SSD2_CLK"/>
        <entry name="BB_PIN_SSD2_CMD"/>
        <entry name="BB_PIN_SDAT2_0"/>
        <entry name="BB_PIN_SDAT2_1"/>
        <entry name="BB_PIN_SDAT2_2"/>
        <entry name="BB_PIN_SDAT2_3"/>
        <entry name="BB_PIN_SPI1_CLK"/>
        <entry name="BB_PIN_SPI1_CS_0"/>
        <entry name="BB_PIN_SPI1_DIO"/>
        <entry name="BB_PIN_SPI1_DI"/>
        <entry name="BB_PIN_SIM2_RST"/>
        <entry name="BB_PIN_SIM2_CLK"/>
        <entry name="BB_PIN_SIM2_DIO"/>
        <entry name="BB_PIN_SIM3_RST"/>
        <entry name="BB_PIN_SIM3_CLK"/>
        <entry name="BB_PIN_SIM3_DIO"/>
        <bound name="BB_GPIO_NB"/>
    </enum>
    <enum name="AP_GPIO_A_mapping">
        <entry name="AP_PIN_I2C2_SCL"><comment>AP GPIO A Map</comment></entry>
        <entry name="AP_PIN_I2C2_SDA"/>
        <entry name="AP_PIN_SPI2_CLK"/>
        <entry name="AP_PIN_SPI2_DIO"/>
        <entry name="AP_PIN_SPI2_DI"/>
        <entry name="AP_PIN_SPI2_CS_0"/>
        <entry name="AP_PIN_SPI2_CS_1"/>
        <entry name="AP_PIN_KEYIN_4"/>
        <entry name="AP_PIN_CLK_OUT"/>
        <entry name="AP_PIN_I2S_BCK"/>
        <entry name="AP_PIN_I2S_LRCK"/>
        <entry name="AP_PIN_I2S_DI_0"/>
        <entry name="AP_PIN_I2S_DI_1"/>
        <entry name="AP_PIN_I2S_DO"/>
        <entry name="AP_PIN_UART1_TXD"/>
        <entry name="AP_PIN_UART1_CTS"/>
        <entry name="AP_PIN_UART1_RTS"/>
        <entry name="AP_PIN_SPI1_CS_1"/>
        <entry name="AP_PIN_LCD_DATA_6"/>
        <entry name="AP_PIN_LCD_DATA_7"/>
        <entry name="AP_PIN_LCD_WR"/>
        <entry name="AP_PIN_LCD_RS"/>
        <entry name="AP_PIN_LCD_RD"/>
        <entry name="AP_PIN_LCD_FMARK"/>
        <entry name="AP_PIN_LCD_DATA_8"/>
        <entry name="AP_PIN_LCD_DATA_9"/>
        <entry name="AP_PIN_LCD_DATA_10"/>
        <entry name="AP_PIN_LCD_DATA_11"/>
        <entry name="AP_PIN_LCD_DATA_12"/>
        <entry name="AP_PIN_LCD_DATA_13"/>
        <entry name="AP_PIN_LCD_DATA_14"/>
        <entry name="AP_PIN_LCD_DATA_15"/>
        <bound name="AP_GPIO_A_NB"/>
    </enum>
    <enum name="AP_GPIO_B_mapping">
        <entry name="AP_PIN_KEYIN_0"><comment>AP GPIO B Map</comment></entry>
        <entry name="AP_PIN_KEYIN_1"/>
        <entry name="AP_PIN_KEYIN_2"/>
        <entry name="AP_PIN_KEYOUT_0"/>
        <entry name="AP_PIN_KEYOUT_1"/>
        <entry name="AP_PIN_KEYOUT_2"/>
        <entry name="AP_PIN_I2C3_SCL"/>
        <entry name="AP_PIN_I2C3_SDA"/>
        <entry name="AP_PIN_UART2_CTS"/>
        <entry name="AP_PIN_UART2_RTS"/>
        <entry name="AP_PIN_CAM_RST"/>
        <entry name="AP_PIN_CAM_PDN"/>
        <entry name="AP_PIN_CAM_CLK"/>
        <entry name="AP_PIN_CAM_VSYNC"/>
        <entry name="AP_PIN_CAM_HREF"/>
        <entry name="AP_PIN_CAM_PCLK"/>
        <entry name="AP_PIN_CAM_DATA_0"/>
        <entry name="AP_PIN_CAM_DATA_1"/>
        <entry name="AP_PIN_CAM_DATA_2"/>
        <entry name="AP_PIN_CAM_DATA_3"/>
        <entry name="AP_PIN_CAM_DATA_4"/>
        <entry name="AP_PIN_CAM_DATA_5"/>
        <entry name="AP_PIN_CAM_DATA_6"/>
        <entry name="AP_PIN_CAM_DATA_7"/>
        <entry name="AP_PIN_M_SPI_CS_0"/>
        <entry name="AP_PIN_NFCLE"/>
        <entry name="AP_PIN_NFWEN"/>
        <entry name="AP_PIN_NFWPN"/>
        <entry name="AP_PIN_NFREN"/>
        <entry name="AP_PIN_NFRB"/>
        <entry name="AP_PIN_I2C1_SCL"/>
        <entry name="AP_PIN_I2C1_SDA"/>
        <bound name="AP_GPIO_B_NB"/>
    </enum>
    <enum name="AP_GPIO_D_mapping">
        <entry name="AP_PIN_UART3_RXD"><comment>AP GPIO D Map</comment></entry>
        <entry name="AP_PIN_UART3_TXD"/>
        <entry name="AP_PIN_UART3_CTS"/>
        <entry name="AP_PIN_UART3_RTS"/>
        <entry name="AP_PIN_NFDQS"/>
        <bound name="AP_GPIO_D_NB"/>
    </enum>


    <reg name="CHIP_ID" protect="r">
        <bits name="METAL_ID" pos="11:0" access="r">
            <comment> ECO Identification number.
            </comment>
            <options>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="BOND_ID" pos="14:12" access="r">
            <comment>Bonding Identification number.
            </comment>
            <options>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="PROD_ID" pos="31:16" access="r">
            <comment>Product Identification number.
            </comment>
            <options>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>

    <reg name="Build_Version" protect="r">
        <comment>This register contain the synthesis date and version
        </comment>
        <bits name="Major" pos="31:28" access="r" rst="no">
        </bits>
        <bits name="Year" pos="27:24" access="r" rst="no">
        </bits>
        <bits name="Month" pos="23:16" access="r" rst="no" display="hex">
        </bits>
        <bits name="Day" pos="15:8" access="r" rst="no" display="hex">
        </bits>
        <bits name="Build_Style" pos="5:4" access="r" rst="no">
            <options>
                <option name="FPGA" value ="0"/>
                <option name="CHIP" value ="1"/>
                <option name="FPGA_USB" value ="2"/>
                <option name="FPGA_GSM" value ="3"/>
            </options>
        </bits>
        <bits name="Build_Revision" pos="3:0" access="r" rst="no">
        </bits>
    </reg>

    <reg name="BB_GPIO_Mode" protect="rw">
        <comment>Setting bit n to '1' selects GPIO Usage for PAD connected to GPIOn. Setting bit n to '0' selects Alt.
        </comment>
        <bits name="BB_GPIO_Mode" pos="BB_GPIO_NB-1:0" access="rw" rst="all1" cut="1" cutprefix="Mode" cutenum="BB_GPIO_mapping" cutstart="0">
            <options>
                <option name="ALT" value ="0"/>
                <option name="GPIO" value ="1"/>
                <mask/><shift/><default/>
            </options>
        </bits>
    </reg>

    <reg name="AP_GPIO_A_Mode" protect="rw">
        <comment>Setting bit n to '1' selects GPIO Usage for PAD connected to GPIOn. Setting bit n to '0' selects Alt.
        </comment>
        <bits name="AP_GPIO_A_Mode" pos="AP_GPIO_A_NB-1:0" access="rw" rst="all1" cut="1" cutprefix="Mode" cutenum="AP_GPIO_A_mapping" cutstart="0">
            <options>
                <option name="ALT" value ="0"/>
                <option name="GPIO" value ="1"/>
                <mask/><shift/><default/>
            </options>
        </bits>
    </reg>

    <reg name="AP_GPIO_B_Mode" protect="rw">
        <comment>Setting bit n to '1' selects GPIO Usage for PAD connected to GPIOn. Setting bit n to '0' selects Alt.
        </comment>
        <bits name="AP_GPIO_B_Mode" pos="AP_GPIO_B_NB-1:0" access="rw" rst="all1" cut="1" cutprefix="Mode" cutenum="AP_GPIO_B_mapping" cutstart="0">
            <options>
                <option name="ALT" value ="0"/>
                <option name="GPIO" value ="1"/>
                <mask/><shift/><default/>
            </options>
        </bits>
    </reg>

    <reg name="AP_GPIO_D_Mode" protect="rw">
        <comment>Setting bit n to '1' selects GPIO Usage for PAD connected to GPIOn. Setting bit n to '0' selects Alt.
        </comment>
        <bits name="AP_GPIO_D_Mode" pos="AP_GPIO_D_NB-1:0" access="rw" rst="all0" cut="1" cutprefix="Mode" cutenum="AP_GPIO_D_mapping" cutstart="0">
            <options>
                <option name="ALT" value ="0"/>
                <option name="GPIO" value ="1"/>
                <mask/><shift/><default/>
            </options>
        </bits>
    </reg>

    <reg name="Alt_mux_select" protect="rw">
        <bits name="LCD_Mode" pos="1:0" access="rw" rst="00">
            <comment>LCD mode select
            </comment>
            <options>
                <option name="Parallel_16bit" value="0"><comment>Parallel 16-bit mode.</comment></option>
                <option name="DSI" value="1"><comment>DSI mode.</comment></option>
                <option name="RGB_16bit" value="2"><comment>RGB 16-bit data.</comment></option>
                <option name="RGB_24bit" value="3"><comment>RGB 24-bit data.</comment></option>
                <mask/>
            </options>
        </bits>
        <bits name="SPI_LCD" pos="2" access="rw" rst="0">
            <comment>SPI LCD mode
            </comment>
            <options>
                <option name="NONE" value="0"><comment>None.</comment></option>
                <option name="SPI_LCD" value="1"><comment>SPI LCD selected.</comment></option>
                <mask/>
            </options>
        </bits>
        <bits name="CAM_I2C2" pos="3" access="rw" rst="0">
            <comment>CAM_RST and CAM_PDN pin select
            </comment>
            <options>
                <option name="CAM" value="0"><comment>CAM_RST and CAM_PDN selected.</comment></option>
                <option name="I2C2" value="1"><comment>I2C2_SCL and I2C2_SDA selected.</comment></option>
                <mask/>
            </options>
        </bits>
        <bits name="CSI2" pos="5:4" access="rw" rst="0">
            <comment>CAM CSI2 mode
            </comment>
            <options>
                <option name="Parallel CAM" value="0"><comment>Parallel CAM selected.</comment></option>
                <option name="CSI2" value="1"><comment>CSI2 selected.</comment></option>
                <option name="SPI_CAM" value="2"><comment>SPI CAM selected.</comment></option>
                <mask/>
            </options>
        </bits>
        <bits name="UART2" pos="6" access="rw" rst="0">
            <comment>UART2/HOST_UART functionality select.
            </comment>
            <options>
                <option name="HOST_UART" value="0"><comment>HST_RXD and HST_TXD selected.</comment></option>
                <option name="UART2" value="1"><comment>UART2_RXD and UART2_TXD selected.</comment></option>
                <mask/>
            </options>
        </bits>
        <bits name="UART1_8LINE" pos="7" access="rw" rst="0">
            <comment>UART2/UART1 8 Line functionality select.
            </comment>
            <options>
                <option name="UART2" value="0"><comment>HST_UART or UART2 selected, depends on above UART2 bit.</comment></option>
                <option name="UART1_8_Line" value="1"><comment>UART1 DTR DCD DSR RI selected.</comment></option>
                <mask/>
            </options>
        </bits>
        <bits name="DAI" pos="9:8" access="rw" rst="0">
            <comment>I2S/DAI/DAI_Simple functionality select.
            </comment>
            <options>
                <option name="I2S" value="0"><comment>I2S selected.</comment></option>
                <option name="DAI" value="1"><comment>Puts DAI port on I2S port.</comment></option>
                <option name="DAI Simple" value="2"><comment>Puts DAI-Simple port on I2S port.</comment></option>
                <mask/>
            </options>
        </bits>
        <bits name="KEYIN_3" pos="10" access="rw" rst="0">
            <comment>SPI2_CS_1/KEYIN_3 pin select.
            </comment>
            <options>
                <option name="SPI2_CS_1" value="0"><comment>SPI2_CS_1 Selected</comment></option>
                <option name="KEYIN_3" value="1"><comment>KEYIN_3 Selected</comment></option>
                <mask/>
            </options>
        </bits>
        <bits name="LPSCO_1" pos="11" access="rw" rst="0">
            <comment>KEYIN_4/LPSCO_1 pin select.
            </comment>
            <options>
                <option name="KEYIN_4" value="0"></option>
                <option name="LPSCO_1" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="SPI1_CS_2" pos="12" access="rw" rst="0">
            <comment>KEYIN_1/SPI1_CS_2 pin select.
            </comment>
            <options>
                <option name="KEYIN_1" value="0"></option>
                <option name="SPI1_CS_2" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="I2S_DI_2" pos="13" access="rw" rst="0">
            <comment>KEYIN_2/I2S_DI_2 pin select.
            </comment>
            <options>
                <option name="KEYIN_2" value="0"></option>
                <option name="I2S_DI_2" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="TCO_0" pos="14" access="rw" rst="0">
            <comment>KEYOUT_0/TCO_0 pin select.
            </comment>
            <options>
                <option name="KEYOUT_0" value="0"></option>
                <option name="TCO_0" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="TCO_1" pos="15" access="rw" rst="0">
            <comment>KEYOUT_1/TCO_1 pin select.
            </comment>
            <options>
                <option name="KEYOUT_1" value="0"></option>
                <option name="TCO_1" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="TCO_2" pos="16" access="rw" rst="0">
            <comment>KEYOUT_2/TCO_2 pin select.
            </comment>
            <options>
                <option name="KEYOUT_2" value="0"></option>
                <option name="TCO_2" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="KEYOUT_3_4" pos="17" access="rw" rst="0">
            <comment>I2C3/KEYOUT_3_4 pin select.
            </comment>
            <options>
                <option name="I2C3" value="0"></option>
                <option name="KEYOUT_3_4" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="KEYOUT_6" pos="18" access="rw" rst="0">
            <comment>UART2_RTS/KEYOUT_6 pin select.
            </comment>
            <options>
                <option name="UART2_RTS" value="0"></option>
                <option name="KEYOUT_6" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="KEYOUT_7" pos="19" access="rw" rst="0">
            <comment>UART1_RTS/KEYOUT_7 pin select.
            </comment>
            <options>
                <option name="UART1_RTS" value="0"></option>
                <option name="KEYOUT_7" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="GPO_0" pos="21:20" access="rw" rst="0">
            <comment>GPO_0/PWT/KEYIN_5 pin select.
            </comment>
            <options>
                <option name="GPO_0" value="0"></option>
                <option name="PWT" value="1"></option>
                <option name="KEYIN_5" value="2"></option>
                <mask/>
            </options>
        </bits>
        <bits name="GPO_1" pos="23:22" access="rw" rst="0">
            <comment>GPO_1/LPG/KEYOUT_5 pin select.
            </comment>
            <options>
                <option name="GPO_1" value="0"></option>
                <option name="LPG" value="1"></option>
                <option name="KEYOUT_5" value="2"></option>
                <mask/>
            </options>
        </bits>
        <bits name="GPO_2" pos="25:24" access="rw" rst="0">
            <comment>GPO_2/PWL_1/CLK_32K pin select.
            </comment>
            <options>
                <option name="GPO_2" value="0"></option>
                <option name="PWL_1" value="1"></option>
                <option name="CLK_32K" value="2"></option>
                <mask/>
            </options>
        </bits>
        <bits name="GPO_3" pos="26" access="rw" rst="0">
            <comment>GPO_3/LCD_CS_1 pin select.
            </comment>
            <options>
                <option name="LCD_CS_1" value="0"></option>
                <option name="GPO_3" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="GPO_4" pos="27" access="rw" rst="0">
            <comment>GPO_4/LCD_CS_0 pin select.
            </comment>
            <options>
                <option name="LCD_CS_0" value="0"></option>
                <option name="GPO_4" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="CLK_OUT" pos="28" access="rw" rst="0">
            <comment>CLK_OUT/HST_CLK pin select.
            </comment>
            <options>
                <option name="HST_CLK" value="0"></option>
                <option name="CLK_OUT" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="DEBUG" pos="29" access="rw" rst="0">
            <comment>Debug monitor functionality select.
            </comment>
            <options>
                <option name="None" value="0"><comment>None.</comment></option>
                <option name="Debug Monitor" value="1"><comment>Debug monitor selected.</comment></option>
                <mask/>
            </options>
        </bits>
        <bits name="AP_SPI1" pos="30" access="rw" rst="0">
            <comment>AP_SPI1/BB_SPI1 pin select.
            </comment>
            <options>
                <option name="BB_SPI1" value="0"><comment>BB_SPI1 selected.</comment></option>
                <option name="AP_SPI1" value="1"><comment>AP_SPI1 selected.</comment></option>
                <mask/>
            </options>
        </bits>
        <bits name="TBD" pos="31" access="rw" rst="0">
            <comment>Reserved register for functionality select.
            </comment>
            <options>
                <option name="None" value="0"><comment>None.</comment></option>
                <option name="Alt1" value="1"><comment>Alt1 selected.</comment></option>
                <mask/>
            </options>
        </bits>
    </reg>

    <reg name="IO_Drive1_Select" protect="rw">
       <bits name="DDR_drive" pos="2:0" access="rw" rst="100">
            <comment>V_MEM_DDR Pad drive select</comment>
            <options>
                <option name="Fast and most weak"   value="7"></option>
                <option name="Fast and weak"        value="6"></option>
                <option name="Fast and strong"      value="5"></option>
                <option name="Fast and most strong" value="4"></option>
                <option name="Slow and most weak"   value="3"></option>
                <option name="Slow and weak"        value="2"></option>
                <option name="Slow and strong"      value="1"></option>
                <option name="Slow and most strong" value="0"></option>
                <mask/>
            </options>
       </bits>
       <bits name="PSRAM1_drive" pos="5:3" access="rw" rst="100">
            <comment>V_MEM_PSRAM Pad1 drive select</comment>
            <options>
                <option name="Fast and most weak"   value="7"></option>
                <option name="Fast and weak"        value="6"></option>
                <option name="Fast and strong"      value="5"></option>
                <option name="Fast and most strong" value="4"></option>
                <option name="Slow and most weak"   value="3"></option>
                <option name="Slow and weak"        value="2"></option>
                <option name="Slow and strong"      value="1"></option>
                <option name="Slow and most strong" value="0"></option>
                <mask/>
            </options>
       </bits>
       <bits name="PSRAM2_drive" pos="8:6" access="rw" rst="100">
            <comment>V_MEM_PSRAM Pad2 drive select</comment>
            <options>
                <option name="Fast and most weak"   value="7"></option>
                <option name="Fast and weak"        value="6"></option>
                <option name="Fast and strong"      value="5"></option>
                <option name="Fast and most strong" value="4"></option>
                <option name="Slow and most weak"   value="3"></option>
                <option name="Slow and weak"        value="2"></option>
                <option name="Slow and strong"      value="1"></option>
                <option name="Slow and most strong" value="0"></option>
                <mask/>
            </options>
       </bits>
       <bits name="NFLSH_drive" pos="11:9" access="rw" rst="100">
            <comment>V_NFLSH Pad drive select</comment>
            <options>
                <option name="Fast and most weak"   value="7"></option>
                <option name="Fast and weak"        value="6"></option>
                <option name="Fast and strong"      value="5"></option>
                <option name="Fast and most strong" value="4"></option>
                <option name="Slow and most weak"   value="3"></option>
                <option name="Slow and weak"        value="2"></option>
                <option name="Slow and strong"      value="1"></option>
                <option name="Slow and most strong" value="0"></option>
                <mask/>
            </options>
       </bits>
       <bits name="LCD1_drive" pos="14:12" access="rw" rst="100">
            <comment>V_LCD Pad1 drive select</comment>
            <options>
                <option name="Fast and most weak"   value="7"></option>
                <option name="Fast and weak"        value="6"></option>
                <option name="Fast and strong"      value="5"></option>
                <option name="Fast and most strong" value="4"></option>
                <option name="Slow and most weak"   value="3"></option>
                <option name="Slow and weak"        value="2"></option>
                <option name="Slow and strong"      value="1"></option>
                <option name="Slow and most strong" value="0"></option>
                <mask/>
            </options>
       </bits>
       <bits name="LCD2_drive" pos="17:15" access="rw" rst="100">
            <comment>V_LCD Pad2 drive select</comment>
            <options>
                <option name="Fast and most weak"   value="7"></option>
                <option name="Fast and weak"        value="6"></option>
                <option name="Fast and strong"      value="5"></option>
                <option name="Fast and most strong" value="4"></option>
                <option name="Slow and most weak"   value="3"></option>
                <option name="Slow and weak"        value="2"></option>
                <option name="Slow and strong"      value="1"></option>
                <option name="Slow and most strong" value="0"></option>
                <mask/>
            </options>
       </bits>
       <bits name="SDAT1_drive" pos="20:18" access="rw" rst="all0">
            <comment>V_SDIO1 Pad drive select</comment>
            <options>
                <option name="Fast and most weak"   value="7"></option>
                <option name="Fast and weak"        value="6"></option>
                <option name="Fast and strong"      value="5"></option>
                <option name="Fast and most strong" value="4"></option>
                <option name="Slow and most weak"   value="3"></option>
                <option name="Slow and weak"        value="2"></option>
                <option name="Slow and strong"      value="1"></option>
                <option name="Slow and most strong" value="0"></option>
                <mask/>
            </options>
       </bits>
       <bits name="SDAT2_drive" pos="23:21" access="rw" rst="all0">
            <comment>V_SDIO2 Pad drive select</comment>
            <options>
                <option name="Fast and most weak"   value="7"></option>
                <option name="Fast and weak"        value="6"></option>
                <option name="Fast and strong"      value="5"></option>
                <option name="Fast and most strong" value="4"></option>
                <option name="Slow and most weak"   value="3"></option>
                <option name="Slow and weak"        value="2"></option>
                <option name="Slow and strong"      value="1"></option>
                <option name="Slow and most strong" value="0"></option>
                <mask/>
            </options>
       </bits>
       <bits name="CAM_drive" pos="25:24" access="rw" rst="all0">
            <comment>V_CAM Pad drive select</comment>
            <options>
                <option name="Most strong" value="0"></option>
                <option name="Strong"      value="1"></option>
                <option name="Weak"        value="2"></option>
                <option name="Most weak"   value="3"></option>
                <mask/>
            </options>
       </bits>
       <bits name="SIM1_drive" pos="27:26" access="rw" rst="all0">
            <comment>V_SIM1 Pad drive select</comment>
            <options>
                <option name="Most strong" value="0"></option>
                <option name="Strong"      value="1"></option>
                <option name="Weak"        value="2"></option>
                <option name="Most weak"   value="3"></option>
                <mask/>
            </options>
       </bits>
       <bits name="SIM2_drive" pos="29:28" access="rw" rst="all0">
            <comment>V_SIM2 Pad drive select</comment>
            <options>
                <option name="Most strong" value="0"></option>
                <option name="Strong"      value="1"></option>
                <option name="Weak"        value="2"></option>
                <option name="Most weak"   value="3"></option>
                <mask/>
            </options>
       </bits>
       <bits name="SIM3_drive" pos="31:30" access="rw" rst="all0">
            <comment>V_SIM3 Pad drive select</comment>
            <options>
                <option name="Most strong" value="0"></option>
                <option name="Strong"      value="1"></option>
                <option name="Weak"        value="2"></option>
                <option name="Most weak"   value="3"></option>
                <mask/>
            </options>
       </bits>
    </reg>

    <reg name="IO_Drive2_Select" protect="rw">
       <bits name="GPIO_drive" pos="1:0" access="rw" rst="all0">
            <comment>V_STD Pad drive select</comment>
            <options>
                <option name="Most strong" value="0"></option>
                <option name="Strong"      value="1"></option>
                <option name="Weak"        value="2"></option>
                <option name="Most weak"   value="3"></option>
                <mask/>
            </options>
       </bits>
    </reg>

    <reg name="RAM_DRIVE" protect="rw">
       <bits name="mbram_a" pos="2:0" access="rw" rst="010">
            <comment>membridge ram cfg.</comment>
            <options> <default/><shift/><mask/> </options>
       </bits>
       <bits name="mbram_w" pos="4:3" access="rw" rst="all0">
            <comment>membridge ram cfg.</comment>
            <options> <default/><shift/><mask/> </options>
       </bits>
       <bits name="mbram_r" pos="5" access="rw" rst="1">
            <comment>membridge ram cfg.</comment>
       </bits>
       <bits name="bbram_a" pos="8:6" access="rw" rst="010">
            <comment>bb ram cfg.</comment>
            <options> <default/><shift/><mask/> </options>
       </bits>
       <bits name="bbram_w" pos="10:9" access="rw" rst="all0">
            <comment>bb ram cfg.</comment>
            <options> <default/><shift/><mask/> </options>
       </bits>
       <bits name="bbram_r" pos="11" access="rw" rst="1">
            <comment>bb ram cfg.</comment>
       </bits>
       <bits name="xp_a" pos="14:12" access="rw" rst="010">
            <comment>xp ram cfg.</comment>
            <options> <default/><shift/><mask/> </options>
       </bits>
       <bits name="xp_w" pos="16:15" access="rw" rst="all0">
            <comment>xp ram cfg.</comment>
            <options> <default/><shift/><mask/> </options>
       </bits>
       <bits name="xp_r" pos="17" access="rw" rst="1">
            <comment>xp ram cfg.</comment>
       </bits>
       <bits name="bp_a" pos="20:18" access="rw" rst="010">
            <comment>bp ram cfg.</comment>
            <options> <default/><shift/><mask/> </options>
       </bits>
       <bits name="bp_w" pos="22:21" access="rw" rst="all0">
            <comment>bp ram cfg.</comment>
            <options> <default/><shift/><mask/> </options>
       </bits>
       <bits name="bp_r" pos="23" access="rw" rst="1">
            <comment>bp ram cfg.</comment>
       </bits>
       <bits name="ev_a" pos="26:24" access="rw" rst="010">
            <comment>ev ram cfg.</comment>
            <options> <default/><shift/><mask/> </options>
       </bits>
       <bits name="ev_w" pos="28:27" access="rw" rst="all0">
            <comment>ev ram cfg.</comment>
            <options> <default/><shift/><mask/> </options>
       </bits>
       <bits name="ev_r" pos="29" access="rw" rst="1">
            <comment>ev ram cfg.</comment>
       </bits>
    </reg>

    <reg name="H2X_AP_Offset" protect="rw">
        <bits name="H2X_AP_Offset" pos="7:0" access="rw" rst="0">
            <comment>Offset value of AHB2AXI for access AP. </comment>
            <options> <default/><shift/><mask/> </options>
        </bits>
    </reg>

    <reg name="H2X_DDR_Offset" protect="rw">
        <bits name="H2X_DDR_Offset" pos="7:0" access="rw" rst="0">
            <comment>Offset value of AHB2AXI for access DDR. </comment>
            <options> <default/><shift/><mask/> </options>
        </bits>
    </reg>

    <reg name="audio_pd_set" protect="rw">
        <bits name="au_deep_pd_n" pos="0" access="rs" rst="0">
            <comment>Power down of all analog audio.
                <br/>0 = Deep Power down
                <br/>1 = Out of Deep Power down
            </comment>
        </bits>
        <bits name="au_ref_pd_n" pos="1" access="rs" rst="0">
            <comment>Reference audio power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>
        <bits name="au_mic_pd_n" pos="2" access="rs" rst="0">
            <comment>Microphone power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>
        <bits name="au_auxmic_pd_n" pos="3" access="rs" rst="0">
            <comment>Aux Microphone power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>
        <bits name="au_ad_pd_n" pos="4" access="rs" rst="0">
            <comment>ADC power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>
        <bits name="au_dac_pd_n" pos="5" access="rs" rst="0">
            <comment>DAC power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>
        <bits name="au_dac_reset_n" pos="8" access="rs" rst="0">
            <comment>Reset audio dac.
                <br/>0 = Reseted
                <br/>1 = Not reseted
            </comment>
        </bits>
        <bits name="au_pll_pu" pos="16" access="rs" rst="0">
            <comment>Audio PLL power up.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>
    </reg>

    <reg name="audio_pd_clr" protect="rw">
        <bits name="au_deep_pd_n" pos="0" access="rc" rst="0">
            <comment>Power down of all analog audio.
                <br/>0 = Deep Power down
                <br/>1 = Out of Deep Power down
            </comment>
        </bits>
        <bits name="au_ref_pd_n" pos="1" access="rc" rst="0">
            <comment>Reference audio power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>
        <bits name="au_mic_pd_n" pos="2" access="rc" rst="0">
            <comment>Microphone power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>
        <bits name="au_auxmic_pd_n" pos="3" access="rc" rst="0">
            <comment>Aux Microphone power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>
        <bits name="au_ad_pd_n" pos="4" access="rc" rst="0">
            <comment>ADC power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>
        <bits name="au_dac_pd_n" pos="5" access="rc" rst="0">
            <comment>DAC power down.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>
        <bits name="au_dac_reset_n" pos="8" access="rc" rst="0">
            <comment>Reset audio dac.
                <br/>0 = Reseted
                <br/>1 = Not reseted
            </comment>
        </bits>
        <bits name="au_pll_pu" pos="16" access="rs" rst="0">
            <comment>Audio PLL power up.
                <br/>0 = Power down
                <br/>1 = Out of Power down
            </comment>
        </bits>
    </reg>

    <reg name="audio_sel_cfg" protect="rw">
        <bits name="au_auxmic_sel" pos="0" access="rw" rst="0">
            <comment>Audio aux microphone input select.
                <br/>0 = mic selected
                <br/>1 = auxmic selected
            </comment>
        </bits>
        <bits name="au_spk_sel" pos="1" access="rw" rst="0">
            <comment>Enable Loudspeaker output.
                <br/>0 = not selected
                <br/>1 = selected
            </comment>
        </bits>
        <bits name="au_spk_mono_sel" pos="2" access="rw" rst="0">
            <comment>Loudspeaker audio mode select.
                <br/>0 = select Stereo audio mode
                <br/>1 = Select Mono audio mode
            </comment>
        </bits>
        <bits name="au_rcv_sel" pos="3" access="rw" rst="0">
            <comment>Enable receiver output.
                <br/>0 = not selected
                <br/>1 = selected
            </comment>
        </bits>
        <bits name="au_head_sel" pos="4" access="rw" rst="0">
            <comment>Enable headphone output.
                <br/>0 = not selected
                <br/>1 = selected
            </comment>
        </bits>
    </reg>

    <reg name="audio_mic_cfg" protect="rw">
        <bits name="au_mic_gain" pos="3:0" access="rw" rst="1000">
            <comment>Select Microphone gain (default"1000").
            </comment>
            <options> <default/><shift/><mask/> </options>
        </bits>
        <bits name="au_mic_mute_n" pos="4" access="rw" rst="0">
            <comment>Microphone mute.
                <br/>0 = Mute
                <br/>1 = Not Mute
            </comment>
        </bits>
    </reg>
    <reg name="audio_spk_cfg" protect="rw">
        <bits name="au_spk_gain" pos="3:0" access="rw" rst="0">
            <comment>Select loudspeaker gain.
            </comment>
            <options> <default/><shift/><mask/> </options>
        </bits>
        <bits name="au_spk_mute_n" pos="4" access="rw" rst="0">
            <comment>Loudspeaker audio mute.
                <br/>0 = Mute Audio output
                <br/>1 = Enable Audio output
            </comment>
        </bits>
    </reg>
    <reg name="audio_rcv_gain" protect="rw">
        <bits name="au_rcv_gain" pos="3:0" access="rw" rst="0">
            <comment>Select receiver gain.
            </comment>
            <options> <default/><shift/><mask/> </options>
        </bits>
    </reg>
    <reg name="audio_head_gain" protect="rw">
        <bits name="au_head_gain" pos="3:0" access="rw" rst="0">
            <comment>Select headphone gain.
            </comment>
            <options> <default/><shift/><mask/> </options>
        </bits>
    </reg>
    <reg name="TSC_DATA" protect="r">
        <bits name="TSC_X_Value_bit" pos="9:0" access="r" rst="0">
            <comment>TSC X Value. </comment>
            <options> <default/><shift/><mask/> </options>
        </bits>
        <bits name="TSC_X_Value_valid" pos="10" access="r" rst="0">
            <comment>TSC X Value valid. </comment>
        </bits>
        <bits name="TSC_Y_Value_bit" pos="20:11" access="r" rst="0">
            <comment>TSC Y Value. </comment>
            <options> <default/><shift/><mask/> </options>
        </bits>
        <bits name="TSC_Y_Value_valid" pos="21" access="r" rst="0">
            <comment>TSC Y Value valid. </comment>
        </bits>
    </reg>
    <reg name="GPADC_DATA_CH" protect="rw" count="8">
        <bits name="GPADC_Data" pos="9:0" access="r" rst="0">
            <comment>GPADC Value. </comment>
            <options> <default/><shift/><mask/> </options>
        </bits>
        <bits name="GPADC_Valid" pos="10" access="r" rst="0">
            <comment>GPADC Value valid flag. </comment>
        </bits>
        <bits name="GPADC_CH_En" pos="31" access="rw" rst="0">
            <comment>GPADC channel enable. </comment>
        </bits>
    </reg>
</module>
</archive>

<archive relative='sys_ctrl_ap.xml' >


<include file="globals.xml"/>

<module name="sys_ctrl_ap" category="Ap">
    
    <enum name="AP_Cpu_Id">
        <entry name="CPU0"><comment>CPU IDs</comment></entry>
        <entry name="CPU1"/>
    </enum>

    
    <enum name="CPU_Clks">
    
        <entry name="CPU_CORE"><comment>AP CPU side System clocks</comment></entry>
        <bound name="NB_CPU_CLK_AEN"/>
    
        <entry name="CPU_DUMMY"><comment>the following don't have an auto enable</comment></entry>
        <bound name="NB_CPU_CLK_EN"/>
    
        <bound name="NB_CPU_CLK"/>
    </enum>

    
    <enum name="AXI_Clks">
    
        <entry name="AHB0_CONF"><comment>AP AXI side System clocks: AXI and AHB0 and APB0</comment></entry>
        <entry name="APB0_CONF"/>
        <entry name="AXI_VOC"/>
        <entry name="AXI_DMA"/>
        <bound name="NB_AXI_CLK_AEN"/>
    
        <entry name="AXI_ALWAYS"><comment>the following don't have an auto enable</comment></entry>
        <entry name="AXI_CONNECT"/>
        <entry name="APB0_IRQ"/>
        <bound name="NB_AXI_CLK_EN"/>
    
        <bound name="NB_AXI_CLK"/>
    </enum>

    
    <enum name="AXIDIV2_Clks">
    
        <entry name="AXIDIV2_IMEM"><comment>AP AXIdiv2 side System clocks</comment></entry>
        <bound name="NB_AXIDIV2_CLK_AEN"/>
    
        <entry name="AXIDIV2_ALWAYS"><comment>the following don't have an auto enable</comment></entry>
        <entry name="AXIDIV2_CONNECT"/>
        <entry name="AXIDIV2_VPU"/>
        <bound name="NB_AXIDIV2_CLK_EN"/>
    
        <bound name="NB_AXIDIV2_CLK"/>
    </enum>

    
    <enum name="GCG_Clks">
    
        <entry name="GCG_APB_CONF"><comment>AP GCG side System clocks</comment></entry>
        <entry name="GCG_GOUDA"/>
        <entry name="GCG_CAMERA"/>
        <bound name="NB_GCG_CLK_AEN"/>
    
        <entry name="GCG_ALWAYS"><comment>the following don't have an auto enable</comment></entry>
        <entry name="GCG_CONNECT"/>
        <bound name="NB_GCG_CLK_EN"/>
    
        <bound name="NB_GCG_CLK"/>
    </enum>

    
    <enum name="AHB1_Clks">
    
        <entry name="AHB1_USBC"><comment>AP AHB1 side System clocks</comment></entry>
        <bound name="NB_AHB1_CLK_AEN"/>
    
        <entry name="AHB1_ALWAYS"><comment>the following don't have an auto enable</comment></entry>
        <entry name="AHB1_SPIFLASH"/>
        <bound name="NB_AHB1_CLK_EN"/>
    
        <bound name="NB_AHB1_CLK"/>
    </enum>

    
    <enum name="APB1_Clks">
    
        <entry name="APB1_CONF"><comment>AP APB1 side System clocks</comment></entry>
        <entry name="APB1_AIF"/>
        <entry name="APB1_AUIFC"/>
        <entry name="APB1_AUIFC_CH0"/>
        <entry name="APB1_AUIFC_CH1"/>
        <entry name="APB1_I2C1"/>
        <entry name="APB1_I2C2"/>
        <entry name="APB1_I2C3"/>
    
        <entry name="APB1D_OSC"><comment>AP APB1 side divided clock (either divided by module or by clock_ctrl)</comment></entry>
        <entry name="APB1D_PWM"/>
        <bound name="NB_APB1_CLK_AEN"/>
    
        <entry name="APB1_ALWAYS"><comment>the following don't have an auto enable</comment></entry>
        <entry name="APB1_DAPLITE"/>
        <entry name="APB1_TIMER"/>
        <entry name="APB1_GPIO"/>
        <bound name="NB_APB1_CLK_EN"/>
    
        <bound name="NB_APB1_CLK"/>
    </enum>

    
    <enum name="APB2_Clks">
    
        <entry name="APB2_CONF"><comment>AP APB2 side System clocks</comment></entry>
        <entry name="APB2_IFC"/>
        <entry name="APB2_IFC_CH0"/>
        <entry name="APB2_IFC_CH1"/>
        <entry name="APB2_IFC_CH2"/>
        <entry name="APB2_IFC_CH3"/>
        <entry name="APB2_IFC_CH4"/>
        <entry name="APB2_IFC_CH5"/>
        <entry name="APB2_IFC_CH6"/>
        <entry name="APB2_IFC_CH7"/>
        <entry name="APB2_UART1"/>
        <entry name="APB2_UART2"/>
        <entry name="APB2_UART3"/>
        <entry name="APB2_SPI1"/>
        <entry name="APB2_SPI2"/>
        <entry name="APB2_SPI3"/>
        <entry name="APB2_SDMMC1"/>
        <entry name="APB2_SDMMC2"/>
        <entry name="APB2_SDMMC3"/>
        <bound name="NB_APB2_CLK_AEN"/>
    
        <entry name="APB2_ALWAYS"><comment>the following don't have an auto enable</comment></entry>
        <entry name="APB2_NANDFLASH"/>
        <bound name="NB_APB2_CLK_EN"/>
    
        <bound name="NB_APB2_CLK"/>
    </enum>

    
    <enum name="MEM_Clks">
    
        <entry name="MEM_CONF"><comment>AP MEM side System clocks</comment></entry>
        <bound name="NB_MEM_CLK_AEN"/>
    
        <entry name="MEM_DMC"><comment>the following don't have an auto enable</comment></entry>
        <entry name="MEM_GPU"/>
        <entry name="MEM_VPU"/>
        <entry name="MEM_DDRPHY_P"/>
        <entry name="MEM_CONNECT"/>
        <bound name="NB_MEM_CLK_EN"/>
    
        <bound name="NB_MEM_CLK"/>
    </enum>

    
    <enum name="APO_Clks">
    
        <entry name="APOC_VPU"><comment>AP side Other clocks<br/>clocks with auto enble</comment></entry>
        <entry name="APOC_BCK"/>
        <entry name="APOC_UART1"/>
        <entry name="APOC_UART2"/>
        <entry name="APOC_UART3"/>
        <bound name="NB_CLK_VOC_AEN_SYNC"/>
        <entry name="APOC_VOC_CORE"/>
        <bound name="NB_CLK_VOC_CORE"/>
        <entry name="APOC_VOC"/>
        <bound name="NB_APO_CLK_AEN"/>
    
        <entry name="APOC_VOC_ALWAYS"><comment>the following don't have an auto enable</comment></entry>
        <bound name="NB_CLK_VOC_END"/>
        <entry name="APOC_DDRPHY_N"/>
        <entry name="APOC_DDRPHY2XP"/>
        <entry name="APOC_DDRPHY2XN"/>
        <entry name="APOC_GPU"/>
        <entry name="APOC_USBPHY"/>
        <entry name="APOC_CSI"/>
        <entry name="APOC_DSI"/>
        <entry name="APOC_GPIO"/>
        <entry name="APOC_SPIFLASH"/>
        <entry name="APOC_PIX"/>
        <entry name="APOC_PDGB"/>
        <bound name="NB_APO_CLK_EN"/>
    
        <bound name="NB_APO_CLK"/>
    </enum>

    
    <enum name="CPU_Resets">
        
        <entry name="CPU_RST_CORE"><comment>AP CPU side resets</comment></entry>
        <entry name="CPU_RST_SYS"/>
        <bound name="NB_CPU_RST"/>
    </enum>
    <enum name="AXI_Resets">
        
        <entry name="AXI_RST_VOC"><comment>AP AXI side resets: AXI and AHB0 and APB0</comment></entry>
        <entry name="AXI_RST_DMA"/>
        <entry name="AXI_RST_SYS"/>
        <entry name="AXI_RST_CONNECT"/>
        <entry name="AHB0_RST_GPU"/>
        <entry name="APB0_RST_VPU"/>
        <entry name="APB0_RST_IRQ"/>
        <bound name="NB_AXI_RST"/>
    </enum>
    <enum name="AXIDIV2_Resets">
        
        <entry name="AXIDIV2_RST_IMEM"><comment>AP AXIDIV2 side resets</comment></entry>
        <entry name="AXIDIV2_RST_SYS"/>
        <entry name="AXIDIV2_RST_VPU"/>
        <bound name="NB_AXIDIV2_RST"/>
    </enum>
    <enum name="GCG_Resets">
        
        <entry name="GCG_RST_SYS"><comment>AP GCG side resets</comment></entry>
        <entry name="GCG_RST_GOUDA"/>
        <entry name="GCG_RST_CAMERA"/>
        <bound name="NB_GCG_RST"/>
    </enum>
    <enum name="AHB1_Resets">
        
        <entry name="AHB1_RST_SYS"><comment>AP AHB1 side resets</comment></entry>
        <entry name="AHB1_RST_USBC"/>
        <entry name="AHB1_RST_SPIFLASH"/>
        <bound name="NB_AHB1_RST"/>
    </enum>
    <enum name="APB1_Resets">
        
        <entry name="APB1_RST_SYS"><comment>AP APB1 side resets</comment></entry>
        <entry name="APB1_RST_TIMER"/>
        <entry name="APB1_RST_KEYPAD"/>
        <entry name="APB1_RST_GPIO"/>
        <entry name="APB1_RST_PWM"/>
        <entry name="APB1_RST_AIF"/>
        <entry name="APB1_RST_AUIFC"/>
        <entry name="APB1_RST_I2C1"/>
        <entry name="APB1_RST_I2C2"/>
        <entry name="APB1_RST_I2C3"/>
        <entry name="APB1_RST_COM_REGS"/>
        <entry name="APB1_RST_DMC"/>
        <entry name="APB1_RST_DDRPHY_P"/>
        <entry name="APB1_RST_BB2G_XCPU"/>
        <entry name="APB1_RST_BB2G_BCPU"/>
        <entry name="APB1_RST_BB2G_AHBC"/>
        <entry name="APB1_RST_BB2G_DMA"/>
        <entry name="APB1_RST_BB2G_A2A"/>
        <entry name="APB1_RST_BB2G_XIFC"/>
        <entry name="APB1_RST_BB2G_BIFC"/>
        <entry name="APB1_RST_BB2G_BAHBC"/>
        <entry name="APB1_RST_BB2G_MEM_BRIDGE"/>
        <bound name="NB_APB1_RST"/>
    </enum>
    <enum name="APB2_Resets">
        
        <entry name="APB2_RST_SYS"><comment>AP APB2 side resets</comment></entry>
        <entry name="APB2_RST_IFC"/>
        <entry name="APB2_RST_UART1"/>
        <entry name="APB2_RST_UART2"/>
        <entry name="APB2_RST_UART3"/>
        <entry name="APB2_RST_SPI1"/>
        <entry name="APB2_RST_SPI2"/>
        <entry name="APB2_RST_SPI3"/>
        <entry name="APB2_RST_SDMMC1"/>
        <entry name="APB2_RST_SDMMC2"/>
        <entry name="APB2_RST_SDMMC3"/>
        <entry name="APB2_RST_NANDFLASH"/>
        <bound name="NB_APB2_RST"/>
    </enum>
    <enum name="MEM_Resets">
        
        <entry name="MEM_RST_SYS"><comment>AP MEM side resets</comment></entry>
        <entry name="MEM_RST_GPU"/>
        <entry name="MEM_RST_VPU"/>
        <entry name="MEM_RST_DMC"/>
        <entry name="MEM_RST_DDRPHY_P"/>
        <bound name="NB_MEM_RST"/>
    </enum>

    
    <enum name="AP_Others_Resets">
        
        <entry name="AP_RSTO_VOC"><comment>AP Reset Other : resync on corresponding clock other</comment></entry>
        <entry name="AP_RSTO_DDRPHY_N"/>
        <entry name="AP_RSTO_DDRPHY2XP"/>
        <entry name="AP_RSTO_DDRPHY2XN"/>
        <entry name="AP_RSTO_GPU"/>
        <entry name="AP_RSTO_VPU"/>
        <entry name="AP_RSTO_BCK"/>
        <entry name="AP_RSTO_UART1"/>
        <entry name="AP_RSTO_UART2"/>
        <entry name="AP_RSTO_UART3"/>
        <entry name="AP_RSTO_GPIO"/>
        <entry name="AP_RSTO_TIMER"/>
        <entry name="AP_RSTO_USBC"/>
        <entry name="AP_RSTO_DSI"/>
        <entry name="AP_RSTO_SPIFLASH"/>
        <entry name="AP_RSTO_TCK"/>
        <entry name="AP_RSTO_PDBG_XTAL"/>
        <bound name="NB_AP_RSTO"/>
    </enum>


    <range name="range_AP_Reset_Other" left="NB_AP_RSTO-1" right="0" />

    <range name="range_Clock_VOC_H" left="NB_CLK_VOC_END-1" right="NB_CLK_VOC_AEN_SYNC" />
    <range name="range_Mode_Clock_VOC_H" left="NB_APO_CLK_AEN-1" right="NB_CLK_VOC_AEN_SYNC" /> 
    <range name="range_VOC_Always_H" left="NB_CLK_VOC_END-1" right="NB_APO_CLK_AEN" />


    <var name="AP_CTRL_PROTECT_LOCK" value="0xa50000" ><comment>For REG_DBG protect lock/unlock value</comment></var>
    <var name="AP_CTRL_PROTECT_UNLOCK" value="0xa50001" />




    <reg name="REG_DBG" protect="rw">
        <comment><strong>This register is used to Lock and Unlock the protected registers.</strong>
        </comment>
        <bits name="Scratch"    pos="15:0"  access="rw"  rst="no">
            <comment>Scratch register: used for debug
            </comment>
        </bits>
        <bits name="Write Unlock Status"    pos="30"  access="r"  rst="0">
            <comment>Is set to 1 when a write attempt has been done on a protected register
                <br/>Can be reset by writing 0xa50000 or 0xa50001 to the debug register (With the LSB at 1 to unlock the protected registers, with the LSB at 0 to lock them)
            </comment>
        </bits>
        <bits name="Write Unlock"           pos="31"  access="r"  rst="1">
            <comment>When this bit is set to 1, the protected registers are accessible
                <br/>When this bit is set to 0, the protected registers can not be written
                <br/>Write 0xa50000 to the debug register to set this bit to 0
                <br/>Write 0xa50001 to the debug register to set this bit to 1
            </comment>
        </bits>
    </reg>

    <reg name="Cfg_Pll_Ctrl" protect="rw" count="4">
        <comment>Register protected by Write_Unlocked_H.</comment>
        <bits name="AP_Pll_Enable" pos="0" access="rw" rst="0">
            <comment>Mode of the Pll. This register is set to enable by the LPS_start_ExtPll_pulse_H.</comment>
            <options>
                <option name="Power_Down" value="0"></option>
                <option name="Enable" value="1"></option>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="AP_Pll_Lock_Reset" pos="4" access="rw" rst="0">
            <comment>Used to reset the PLL Lock Detector.</comment>
            <options>
                <option name="Reset"    value="0"></option>
                <option name="No_Reset" value="1"></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="AP_Pll_Bypass" pos="8" access="rw" rst="0">
            <options>
                <option name="Pass" value="0"><comment>In this mode the output of the PLL is its input clock divided by the proper dividers</comment></option>
                <option name="Bypass" value="1"><comment>In this mode the output of the PLL is its input clock</comment></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="AP_Pll_Clk_Fast_Enable" pos="12" access="rw" rst="0">
            <comment>Enables the Fast Clock from the ExtPll (Clock Gate Reg Resync).</comment>
            <options>
                <option name="Enable" value="1"></option>
                <option name="Disable" value="0"></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="AP_Pll_Lock_Num_Low" pos="20:16" access="rw" rst="14">
            <comment>Pll lock detect range LOW.</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="AP_Pll_Lock_Num_High" pos="28:24" access="rw" rst="30">
            <comment>Pll lock detect range HIGH.</comment>
            <options><mask/><shift/></options>
        </bits>
        <bitgroup name="Pll_ap_cfg">
            <entry ref="AP_Pll_Enable"/>
            <entry ref="AP_Pll_Lock_Reset"/>
            <entry ref="AP_Pll_Bypass"/>
            <entry ref="AP_Pll_Clk_Fast_Enable"/>
            <entry ref="AP_Pll_Lock_Num_Low"/>
            <entry ref="AP_Pll_Lock_Num_High"/>
        </bitgroup>
    </reg>
    <reg name="Sel_Clock" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Slow_sel_RF"    pos="0"  access="rw" rst="1">
            <comment>PreSelects between RF clock and Oscillator clock for Clock Slow
            </comment>
            <options>
                <option name="Oscillator"   value="1"/>
                <option name="RF"           value="0"/>
            </options>
        </bits>
        <bits name="Cpu_sel_Fast"    pos="4"  access="rw" rst="1">
            <comment>Selects between the Slow clock and the Fast Clock (Pll clock) and Selects between the Slow clock and the Xcpu Clock
            </comment>
            <options>
                <option name="Slow"         value="1"/>
                <option name="Fast"         value="0"/>
            </options>
        </bits>
        <bits name="Bus_sel_Fast"    pos="5"  access="rw" rst="1">
            <comment>Selects between the Slow clock and the Fast Clock (Pll clock) and Selects between the Slow clock and the Xcpu Clock
            </comment>
            <options>
                <option name="Slow"         value="1"/>
                <option name="Fast"         value="0"/>
            </options>
        </bits>
        <bits name="Timer_sel_Fast"    pos="7"  access="rw" rst="1">
            <comment>0: Timer at 2MHz; 1: Timer at 16KHz.</comment>
            <options>
                <option name="Slow"         value="1"/>
                <option name="Fast"         value="0"/>
            </options>
        </bits>
        <bits name="RF_detected" pos="8" access="r" rst="no">
            <options>
                <option name="Ok" value="1"><comment>When 1, the clock from the XCver is detected.</comment></option>
                <option name="No" value="0"><comment>When 0, the clock from the XCver is not detected.</comment></option>
            </options>
        </bits>
        <bits name="RF_Detect_Bypass" pos="9" access="rw" rst="0">
            <comment>If RF_Detect_Bypass = 0, RF clock is selected when she is detected.
                <br/>If RF_Detect_Bypass = 1, RF clock is selected even she is not detected.
            </comment>
        </bits>

        <bits name="RF_Detect_Reset" pos="10" access="rw" rst="0">
            <comment>When 1, The RF clock detection counter is force reseted.
                <br/>When 0, The RF clock detection counter is enabled.
            </comment>
        </bits>
        <bits name="RF_selected_L" pos="11"    access="r" rst="1">
            <comment>0 when RF clock is effectively selected for Slow Clock. RF clock selection is not done until the clock has been detected.
            </comment>
        </bits>
        <bits name="PLL_Locked_CPU" pos="12" access="r" rst="0">
            <options>
                <option name="Locked"     value="1"><comment></comment></option>
                <option name="Not_Locked" value="0"><comment></comment></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="PLL_Locked_BUS" pos="13" access="r" rst="0">
            <options>
                <option name="Locked"     value="1"><comment></comment></option>
                <option name="Not_Locked" value="0"><comment></comment></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="PLL_Locked_MEM" pos="14" access="r" rst="0">
            <options>
                <option name="Locked"     value="1"><comment></comment></option>
                <option name="Not_Locked" value="0"><comment></comment></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="PLL_Locked_USB" pos="15" access="r" rst="0">
            <options>
                <option name="Locked"     value="1"><comment></comment></option>
                <option name="Not_Locked" value="0"><comment></comment></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="PLL_bypass_Lock_CPU" pos="20" access="rw" rst="0">
            <comment>When set to 1, the system clock will switch to the fast clock even if the pll is not locked.
                <br/>When set to 0, the system clock is only allowed to switch to the fast clock if the pll is locked
            </comment>
        </bits>
        <bits name="PLL_bypass_Lock_BUS" pos="21" access="rw" rst="0">
            <comment>When set to 1, the system clock will switch to the fast clock even if the pll is not locked.
                <br/>When set to 0, the system clock is only allowed to switch to the fast clock if the pll is locked
            </comment>
        </bits>
        <bits name="Fast_Selected_Cpu_L" pos="30" access="r" rst="1">
            <comment>0 when Fast clock is effectively selected. Fast clock selection is not done until the PLL has locked.
            </comment>
            <options>
            <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="Fast_Selected_Bus_L" pos="31" access="r" rst="1">
            <comment>0 when Fast clock is effectively selected. Fast clock selection is not done until the PLL has locked.
            </comment>
            <options>
            <mask/><shift/><default/>
            </options>
        </bits>
    </reg>
    <reg name="Reset_Cause" protect="rw">
        
        <bits name="WatchDog_Reset" pos="0" access="rw" rst="no">
            <options>
                <option name="Happened" value="1"><comment>A watchdog reset has happened</comment></option>
                <option name="No" value="0"><comment>No watchdog reset happened since the last HW reset or power on.</comment></option>
            </options>
            <comment>Writing a 1 to this bit will reset the bits watchdog_Reset cause, GlobalSoft_Reset cause and HostDebug_Reset cause to 0.
            </comment>
        </bits>
        <bits name="GlobalSoft_Reset" pos="4" access="r" rst="no">
            <options>
                <option name="Happened" value="1"><comment>A reset was initiated from Global soft reset register</comment></option>
                <option name="No" value="0"><comment>The reset was not from the soft reset register.</comment></option>
            </options>
        </bits>
        <bits name="HostDebug_Reset" pos="5" access="r" rst="no">
            <options>
                <option name="Happened" value="1"><comment>A reset was initiated from the Host interface</comment></option>
                <option name="No" value="0"><comment>The reset was not from the debug interface.</comment></option>
            </options>
        </bits>
        <bits name="AlarmCause" pos="6" access="r" rst="no">
            <options>
                <option name="Happened" value="1"><comment>An Alarm occur from the calendar</comment></option>
                <option name="No" value="0"><comment>No Alarm occur.</comment></option>
            </options>
        </bits>
        <bits name="Boot_Mode" pos="23:8" access="rw" rst="no">
            <comment>This contains the state of boot mode pins latched during Reset.
                <br/> bit 16: BOOT_MODE0.
                <br/> bit 17: BOOT_MODE1.
                <br/> bit 18: reserved.
                <br/> bit 19: reserved.
                <br/> bit 20: reserved.
                <br/> bit 21: reserved.
                <br/> see BootSequence for details.
                <br/> This register is not reseted by a software or host reset.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="SW_Boot_Mode" pos="30:24" access="rw" rst="no">
            <comment> Software boot mode (Reseted at zero by external reset pin)
                <br/> This register is not reseted by a software or host reset.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Fonctional_Test_Mode" pos="31" access="r" rst="no">
            <comment>When 1 the chip has booted in fonctional test mode (for chip production tests).
            </comment>
        </bits>
    </reg>

    <reg name="CPU_Rst_Set" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Set_CPU_Rst"    pos="NB_CPU_RST-1:0"  access="rs" rst="1" cut="1" cutprefix="Set" cutenum="CPU_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name="Soft_Rst"   pos="31"    access="s" rst="0">
            <comment>Writing a 1 to this bit will reset the entire chip.
            </comment>
        </bits>
    </reg>
    <reg name="CPU_Rst_Clr" protect="rw">
        <bits name="Clr_CPU_Rst"    pos="NB_CPU_RST-1:0"  access="rc" rst="1" cut="1" cutprefix="Clr" cutenum="CPU_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="AXI_Rst_Set" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Set_AXI_Rst"    pos="NB_AXI_RST-1:0"  access="rs" rst="1" cut="1" cutprefix="Set" cutenum="AXI_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="AXI_Rst_Clr" protect="rw">
        <bits name="Clr_AXI_Rst"    pos="NB_AXI_RST-1:0"  access="rc" rst="1" cut="1" cutprefix="Clr" cutenum="AXI_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="AXIDIV2_Rst_Set" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Set_AXIDIV2_Rst"    pos="NB_AXIDIV2_RST-1:0"  access="rs" rst="1" cut="1" cutprefix="Set" cutenum="AXIDIV2_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="AXIDIV2_Rst_Clr" protect="rw">
        <bits name="Clr_AXIDIV2_Rst"    pos="NB_AXIDIV2_RST-1:0"  access="rc" rst="1" cut="1" cutprefix="Clr" cutenum="AXIDIV2_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="GCG_Rst_Set" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Set_GCG_Rst"    pos="NB_GCG_RST-1:0"  access="rs" rst="1" cut="1" cutprefix="Set" cutenum="GCG_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="GCG_Rst_Clr" protect="rw">
        <bits name="Clr_GCG_Rst"    pos="NB_GCG_RST-1:0"  access="rc" rst="1" cut="1" cutprefix="Clr" cutenum="GCG_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="AHB1_Rst_Set" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Set_AHB1_Rst"    pos="NB_AHB1_RST-1:0"  access="rs" rst="1" cut="1" cutprefix="Set" cutenum="AHB1_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="AHB1_Rst_Clr" protect="rw">
        <bits name="Clr_AHB1_Rst"    pos="NB_AHB1_RST-1:0"  access="rc" rst="1" cut="1" cutprefix="Clr" cutenum="AHB1_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="APB1_Rst_Set" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Set_APB1_Rst"    pos="NB_APB1_RST-1:0"  access="rs" rst="1" cut="1" cutprefix="Set" cutenum="APB1_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="APB1_Rst_Clr" protect="rw">
        <bits name="Clr_APB1_Rst"    pos="NB_APB1_RST-1:0"  access="rc" rst="1" cut="1" cutprefix="Clr" cutenum="APB1_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="APB2_Rst_Set" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Set_APB2_Rst"    pos="NB_APB2_RST-1:0"  access="rs" rst="1" cut="1" cutprefix="Set" cutenum="APB2_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="APB2_Rst_Clr" protect="rw">
        <bits name="Clr_APB2_Rst"    pos="NB_APB2_RST-1:0"  access="rc" rst="1" cut="1" cutprefix="Clr" cutenum="APB2_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="MEM_Rst_Set" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Set_MEM_Rst"    pos="NB_MEM_RST-1:0"  access="rs" rst="1" cut="1" cutprefix="Set" cutenum="MEM_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name="MEM_Rst_Clr" protect="rw">
        <bits name="Clr_MEM_Rst"    pos="NB_MEM_RST-1:0"  access="rc" rst="1" cut="1" cutprefix="Clr" cutenum="MEM_Resets" cutstart="0">
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>

    <reg name="Clk_CPU_Mode" protect="rw">
        <bits name="Mode_Clk_CPU"   pos="NB_CPU_CLK_AEN-1:0"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="CPU_Clks" cutstart="0">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_CPU_Enable" protect="rw">
        <bits name="Enable_Clk_CPU"     pos="NB_CPU_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="CPU_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_CPU_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_CPU"    pos="NB_CPU_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="CPU_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>

    <reg name="Clk_AXI_Mode" protect="rw">
        <bits name="Mode_Clk_AXI"   pos="NB_AXI_CLK_AEN-1:0"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="AXI_Clks" cutstart="0">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_AXI_Enable" protect="rw">
        <bits name="Enable_Clk_AXI"     pos="NB_AXI_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="AXI_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_AXI_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_AXI"    pos="NB_AXI_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="AXI_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>

    <reg name="Clk_AXIDIV2_Mode" protect="rw">
        <bits name="Mode_Clk_AXIDIV2"   pos="NB_AXIDIV2_CLK_AEN-1:0"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="AXIDIV2_Clks" cutstart="0">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_AXIDIV2_Enable" protect="rw">
        <bits name="Enable_Clk_AXIDIV2"     pos="NB_AXIDIV2_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="AXIDIV2_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_AXIDIV2_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_AXIDIV2"    pos="NB_AXIDIV2_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="AXIDIV2_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>

    <reg name="Clk_GCG_Mode" protect="rw">
        <bits name="Mode_Clk_GCG"   pos="NB_GCG_CLK_AEN-1:0"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="GCG_Clks" cutstart="0">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_GCG_Enable" protect="rw">
        <bits name="Enable_Clk_GCG"     pos="NB_GCG_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="GCG_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_GCG_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_GCG"    pos="NB_GCG_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="GCG_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>

    <reg name="Clk_AHB1_Mode" protect="rw">
        <bits name="Mode_Clk_AHB1"   pos="NB_AHB1_CLK_AEN-1:0"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="AHB1_Clks" cutstart="0">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_AHB1_Enable" protect="rw">
        <bits name="Enable_Clk_AHB1"     pos="NB_AHB1_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="AHB1_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_AHB1_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_AHB1"    pos="NB_AHB1_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="AHB1_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>

    <reg name="Clk_APB1_Mode" protect="rw">
        <bits name="Mode_Clk_APB1"   pos="NB_APB1_CLK_AEN-1:0"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="APB1_Clks" cutstart="0">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_APB1_Enable" protect="rw">
        <bits name="Enable_Clk_APB1"     pos="NB_APB1_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="APB1_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_APB1_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_APB1"    pos="NB_APB1_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="APB1_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>

    <reg name="Clk_APB2_Mode" protect="rw">
        <bits name="Mode_Clk_APB2"   pos="NB_APB2_CLK_AEN-1:0"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="APB2_Clks" cutstart="0">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_APB2_Enable" protect="rw">
        <bits name="Enable_Clk_APB2"     pos="NB_APB2_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="APB2_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_APB2_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_APB2"    pos="NB_APB2_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="APB2_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>

    <reg name="Clk_MEM_Mode" protect="rw">
        <bits name="Mode_Clk_MEM"   pos="NB_MEM_CLK_AEN-1:0"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="MEM_Clks" cutstart="0">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_MEM_Enable" protect="rw">
        <bits name="Enable_Clk_MEM"     pos="NB_MEM_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="MEM_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_MEM_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_MEM"    pos="NB_MEM_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="MEM_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>

    <reg name="Clk_APO_Mode" protect="rw">
        <bits name="Mode_Clk_APO"   pos="NB_APO_CLK_AEN-1:0"  access="rw" rst="1" cut="1" cutprefix="Mode" cutenum="APO_Clks" cutstart="0">
            <options>
                <option name="Automatic" value="0"><comment>automatic clock gating enabled</comment></option>
                <option name="Manual"    value="1"><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Clk_APO_Enable" protect="rw">
        <bits name="Enable_Clk_APO"     pos="NB_APO_CLK_EN-1:0"  access="rs" rst="1" cut="1" cutprefix="Enable" cutenum="APO_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name="Clk_APO_Disable" protect="rw">
        <comment>This register is protected.
        </comment>
        <bits name="Disable_Clk_APO"    pos="NB_APO_CLK_EN-1:0"  access="rc" rst="1" cut="1" cutprefix="Disable" cutenum="APO_Clks" cutstart="0">
            <comment>Each bit controls the manual enable  for one clock
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>

    <reg name="Cfg_Clk_AP_CPU" protect="rw">
       <bits name="AP_CPU_Freq"   pos="4:0"  access="rw" rst="all0">
            <comment>Bit force_div_update in this register is protected.
            </comment>
            <options>
                <option name="19M"  value="6"/>
                <option name="20M"  value="7"/>
                <option name="300M" value="26"/>
                <option name="340M" value="27"/>
                <option name="400M" value="28"/>
                <option name="480M" value="29"/>
                <option name="600M" value="30"/>
                <option name="1.2G" value="31"/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values the system will run at 26MHz
                <br/>any writing to this register will trigger an update request. The update will be effective when the gsm clocks are in the proper phase to avoid schronization loss unless bit force_div_update is written '1'.
            </comment>
        </bits>
        <bits name="Bus_div_sel" pos="17:16" access="rw" rst="0">
            <comment>Bus divider select.
            </comment>
            <options>
                <option name="DIV2" value="0"/>
                <option name="DIV3" value="1"/>
                <option name="DIV4" value="2"/>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="AP_CPU_req_div_update" pos="31" access="r" rst="1">
            <comment>Status to check if a request to update the pll divider is pending.
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_AP_AXI" protect="rw">
       <bits name="AP_AXI_Freq"   pos="4:0"  access="rw" rst="all0">
            <comment>Bit force_div_update in this register is protected.
            </comment>
            <options>
                <option name="19M"  value="6"/>
                <option name="20M"  value="7"/>
                <option name="300M" value="26"/>
                <option name="340M" value="27"/>
                <option name="400M" value="28"/>
                <option name="480M" value="29"/>
                <option name="600M" value="30"/>
                <option name="1.2G" value="31"/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values the system will run at 26MHz
                <br/>any writing to this register will trigger an update request. The update will be effective when the gsm clocks are in the proper phase to avoid schronization loss unless bit force_div_update is written '1'.
            </comment>
        </bits>
        <bits name="AP_AXI_src_sel"   pos="12"    access="rw" rst="0">
            <comment>Select source div 2
            </comment>
        </bits>
        <bits name="AP_AXI_req_div_update"     pos="31"   access="r" rst="1">
            <comment>Status to check if a request to update the pll divider is pending.
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_AP_GCG" protect="rw">
       <bits name="AP_GCG_Freq"   pos="4:0"  access="rw" rst="all0">
            <comment>Bit force_div_update in this register is protected.
            </comment>
            <options>
                <option name="19M"  value="6"/>
                <option name="20M"  value="7"/>
                <option name="300M" value="26"/>
                <option name="340M" value="27"/>
                <option name="400M" value="28"/>
                <option name="480M" value="29"/>
                <option name="600M" value="30"/>
                <option name="1.2G" value="31"/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values the system will run at 26MHz
                <br/>any writing to this register will trigger an update request. The update will be effective when the gsm clocks are in the proper phase to avoid schronization loss unless bit force_div_update is written '1'.
            </comment>
        </bits>
        <bits name="AP_GCG_src_sel"   pos="12"    access="rw" rst="0">
            <comment>Select source div 2
            </comment>
        </bits>
        <bits name="AP_GCG_req_div_update"     pos="31"   access="r" rst="1">
            <comment>Status to check if a request to update the pll divider is pending.
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_AP_AHB1" protect="rw">
       <bits name="AP_AHB1_Freq"   pos="4:0"  access="rw" rst="all0">
            <comment>Bit force_div_update in this register is protected.
            </comment>
            <options>
                <option name="19M"  value="6"/>
                <option name="20M"  value="7"/>
                <option name="300M" value="26"/>
                <option name="340M" value="27"/>
                <option name="400M" value="28"/>
                <option name="480M" value="29"/>
                <option name="600M" value="30"/>
                <option name="1.2G" value="31"/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values the system will run at 26MHz
                <br/>any writing to this register will trigger an update request. The update will be effective when the gsm clocks are in the proper phase to avoid schronization loss unless bit force_div_update is written '1'.
            </comment>
        </bits>
        <bits name="AP_AHB1_src_sel"   pos="12"    access="rw" rst="0">
            <comment>Select source div 2
            </comment>
        </bits>
        <bits name="AP_AHB1_req_div_update"     pos="31"   access="r" rst="1">
            <comment>Status to check if a request to update the pll divider is pending.
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_AP_APB1" protect="rw">
       <bits name="AP_APB1_Freq"   pos="4:0"  access="rw" rst="all0">
            <comment>Bit force_div_update in this register is protected.
            </comment>
            <options>
                <option name="19M"  value="6"/>
                <option name="20M"  value="7"/>
                <option name="300M" value="26"/>
                <option name="340M" value="27"/>
                <option name="400M" value="28"/>
                <option name="480M" value="29"/>
                <option name="600M" value="30"/>
                <option name="1.2G" value="31"/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values the system will run at 26MHz
                <br/>any writing to this register will trigger an update request. The update will be effective when the gsm clocks are in the proper phase to avoid schronization loss unless bit force_div_update is written '1'.
            </comment>
        </bits>
        <bits name="AP_APB1_src_sel"   pos="12"    access="rw" rst="0">
            <comment>Select source div 2
            </comment>
        </bits>
        <bits name="AP_APB1_req_div_update"     pos="31"   access="r" rst="1">
            <comment>Status to check if a request to update the pll divider is pending.
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_AP_APB2" protect="rw">
       <bits name="AP_APB2_Freq"   pos="4:0"  access="rw" rst="all0">
            <comment>Bit force_div_update in this register is protected.
            </comment>
            <options>
                <option name="19M"  value="6"/>
                <option name="20M"  value="7"/>
                <option name="300M" value="26"/>
                <option name="340M" value="27"/>
                <option name="400M" value="28"/>
                <option name="480M" value="29"/>
                <option name="600M" value="30"/>
                <option name="1.2G" value="31"/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values the system will run at 26MHz
                <br/>any writing to this register will trigger an update request. The update will be effective when the gsm clocks are in the proper phase to avoid schronization loss unless bit force_div_update is written '1'.
            </comment>
        </bits>
        <bits name="AP_APB2_src_sel"   pos="12"    access="rw" rst="0">
            <comment>Select source div 2
            </comment>
        </bits>
        <bits name="AP_APB2_req_div_update"     pos="31"   access="r" rst="1">
            <comment>Status to check if a request to update the pll divider is pending.
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_AP_MEM" protect="rw">
        <bits name="AP_MEM_src_div2"   pos="12"    access="rw" rst="0">
            <comment>Select source div 2
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_AP_GPU" protect="rw">
       <bits name="AP_GPU_Freq"   pos="4:0"  access="rw" rst="all0">
            <comment>Bit force_div_update in this register is protected.
            </comment>
            <options>
                <option name="19M"  value="6"/>
                <option name="20M"  value="7"/>
                <option name="300M" value="26"/>
                <option name="340M" value="27"/>
                <option name="400M" value="28"/>
                <option name="480M" value="29"/>
                <option name="600M" value="30"/>
                <option name="1.2G" value="31"/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values the system will run at 26MHz
                <br/>any writing to this register will trigger an update request. The update will be effective when the gsm clocks are in the proper phase to avoid schronization loss unless bit force_div_update is written '1'.
            </comment>
        </bits>
        <bits name="AP_GPU_src_div2"   pos="12"    access="rw" rst="0">
            <comment>Select source div 2
            </comment>
        </bits>
        <bits name="AP_GPU_req_div_update"     pos="31"   access="r" rst="1">
            <comment>Status to check if a request to update the pll divider is pending.
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_AP_VPU" protect="rw">
       <bits name="AP_VPU_Freq"   pos="4:0"  access="rw" rst="all0">
            <comment>Bit force_div_update in this register is protected.
            </comment>
            <options>
                <option name="19M"  value="6"/>
                <option name="20M"  value="7"/>
                <option name="300M" value="26"/>
                <option name="340M" value="27"/>
                <option name="400M" value="28"/>
                <option name="480M" value="29"/>
                <option name="600M" value="30"/>
                <option name="1.2G" value="31"/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values the system will run at 26MHz
                <br/>any writing to this register will trigger an update request. The update will be effective when the gsm clocks are in the proper phase to avoid schronization loss unless bit force_div_update is written '1'.
            </comment>
        </bits>
        <bits name="AP_VPU_src_div2"   pos="12"    access="rw" rst="0">
            <comment>Select source div 2
            </comment>
        </bits>
        <bits name="AP_VPU_req_div_update"     pos="31"   access="r" rst="1">
            <comment>Status to check if a request to update the pll divider is pending.
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_AP_VOC" protect="rw">
       <bits name="AP_VOC_Freq"   pos="4:0"  access="rw" rst="all0">
            <comment>Bit force_div_update in this register is protected.
            </comment>
            <options>
                <option name="19M"  value="6"/>
                <option name="20M"  value="7"/>
                <option name="300M" value="26"/>
                <option name="340M" value="27"/>
                <option name="400M" value="28"/>
                <option name="480M" value="29"/>
                <option name="600M" value="30"/>
                <option name="1.2G" value="31"/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values the system will run at 26MHz
                <br/>any writing to this register will trigger an update request. The update will be effective when the gsm clocks are in the proper phase to avoid schronization loss unless bit force_div_update is written '1'.
            </comment>
        </bits>
        <bits name="AP_VOC_src_div2"   pos="12"    access="rw" rst="0">
            <comment>Select source div 2
            </comment>
        </bits>
        <bits name="AP_VOC_req_div_update"     pos="31"   access="r" rst="1">
            <comment>Status to check if a request to update the pll divider is pending.
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_AP_SFLSH" protect="rw">
       <bits name="AP_SFLSH_Freq"   pos="4:0"  access="rw" rst="all0">
            <comment>Bit force_div_update in this register is protected.
            </comment>
            <options>
                <option name="19M"  value="6"/>
                <option name="20M"  value="7"/>
                <option name="300M" value="26"/>
                <option name="340M" value="27"/>
                <option name="400M" value="28"/>
                <option name="480M" value="29"/>
                <option name="600M" value="30"/>
                <option name="1.2G" value="31"/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values the system will run at 26MHz
                <br/>any writing to this register will trigger an update request. The update will be effective when the gsm clocks are in the proper phase to avoid schronization loss unless bit force_div_update is written '1'.
            </comment>
        </bits>
        <bits name="AP_SFLSH_src_div2"   pos="12"    access="rw" rst="0">
            <comment>Select source div 2
            </comment>
        </bits>
        <bits name="AP_SFLSH_req_div_update"     pos="31"   access="r" rst="1">
            <comment>Status to check if a request to update the pll divider is pending.
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_Uart"    protect="rw" count="3">
        <bits name="Uart_Divider"    pos="9:0"   access="rw" rst="5">
            <comment>The generated clock frequency is equal to the selected source frequency divided by this value + 2 (see bit 12 clock select for source selection).
                <br/>The generated clock must be 4 or 16 times the expected baud rate depending on the Uart settings (see Uart section for details).
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Uart_Sel_PLL"   pos="12"    access="rw" rst="0">
            <options>
                <option name="Slow" value="0"><comment>The Uart clock is generated from the Slow clock divided by the divider value + 2</comment></option>
                <option name="PLL"  value="1"><comment>The Uart clock is generated from a 156MHz clock generated by the PLL.</comment></option>
            </options>
        </bits>
    </reg>

    <reg name="L2cc_Ctrl"    protect="rw">
        <bits name="arqos_l2cc_1_m"    pos="3:0"   access="rw" rst="0">
            <comment>arqos_l2cc_1_m</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="awqos_l2cc_1_m"    pos="7:4"   access="rw" rst="0">
            <comment>awqos_l2cc_1_m</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="arqos_modem_mem_ahbs_m"    pos="11:8"   access="rw" rst="0">
            <comment>arqos_modem_mem_ahbs_m</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="awqos_modem_mem_ahbs_m"    pos="15:12"   access="rw" rst="0">
            <comment>awqos_modem_mem_ahbs_m</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="arap_l2cc_1_m"    pos="16"   access="rw" rst="0">
            <comment>arap_l2cc_1_m</comment>
        </bits>
        <bits name="awap_l2cc_1_m"    pos="17"   access="rw" rst="0">
            <comment>awap_l2cc_1_m</comment>
        </bits>
        <bits name="arap_modem_mem_ahbs_m"    pos="18"   access="rw" rst="0">
            <comment>arap_modem_mem_ahbs_m</comment>
        </bits>
        <bits name="awap_modem_mem_ahbs_m"    pos="19"   access="rw" rst="0">
            <comment>awap_modem_mem_ahbs_m</comment>
        </bits>
        <bits name="arap_merge1m"    pos="20"   access="rw" rst="0">
            <comment>arap_merge1m</comment>
        </bits>
        <bits name="awap_merge1m"    pos="21"   access="rw" rst="0">
            <comment>awap_merge1m</comment>
        </bits>
        <bits name="arap_merge2m"    pos="22"   access="rw" rst="0">
            <comment>arap_merge2m</comment>
        </bits>
        <bits name="awap_merge2m"    pos="23"   access="rw" rst="0">
            <comment>awap_merge2m</comment>
        </bits>
        <bits name="Reserve1" pos="31:24" access="rw" rst="10101010">
            <comment>This register is reserved.
            </comment>
            <options><mask/><shift/></options>
        </bits>
    </reg>

    <reg name="Spi_Ctrl"    protect="rw">
        <bits name="limited_en_spi1"    pos="0"   access="rw" rst="0">
            <comment>limited_en_spi1</comment>
        </bits>
        <bits name="lpsen_spi1"    pos="1"   access="rw" rst="0">
            <comment>lpsen_spi1</comment>
        </bits>
        <bits name="limited_en_spi2"    pos="2"   access="rw" rst="0">
            <comment>limited_en_spi2</comment>
        </bits>
        <bits name="lpsen_spi2"    pos="3"   access="rw" rst="0">
            <comment>lpsen_spi2</comment>
        </bits>
        <bits name="limited_en_spi3"    pos="4"   access="rw" rst="0">
            <comment>limited_en_spi3</comment>
        </bits>
        <bits name="lpsen_spi3"    pos="5"   access="rw" rst="0">
            <comment>lpsen_spi3</comment>
        </bits>
        <bits name="fbuswid_nfsc"    pos="6"   access="rw" rst="0">
            <comment>fbuswid_nfsc</comment>
        </bits>
        <bits name="Reserve3"    pos="7"   access="rw" rst="1">
            <comment>fbuswid_nfsc</comment>
        </bits>
        <bits name="DMC_cfg" pos="17:8" access="rw" rst="1010101010">
            <comment>DMC_cfg.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Reserve2" pos="31:18" access="rw" rst="10101010101010">
            <comment>This register is reserved.
            </comment>
            <options><mask/><shift/></options>
        </bits>
    </reg>

    <reg name="Memory_Margin"    protect="rw">
        <bits name="emaw_voc"    pos="1:0"   access="rw" rst="all0">
            <comment>emaw_voc</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="ema_voc"    pos="4:2"   access="rw" rst="010">
            <comment>ema_voc</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="emaw_vpu"    pos="6:5"   access="rw" rst="all0">
            <comment>emaw_vpu</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="ema_vpu"    pos="9:7"   access="rw" rst="010">
            <comment>ema_vpu</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="emaw_gpu"    pos="11:10"   access="rw" rst="all0">
            <comment>emaw_gpu</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="ema_gpu"    pos="14:12"   access="rw" rst="010">
            <comment>ema_gpu</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="emaw_gouda"    pos="16:15"   access="rw" rst="all0">
            <comment>emaw_gouda</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="ema_gouda"    pos="19:17"   access="rw" rst="010">
            <comment>ema_gouda</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="emaw_imem"    pos="21:20"   access="rw" rst="all0">
            <comment>emaw_imem</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="ema_imem"    pos="24:22"   access="rw" rst="010">
            <comment>ema_imem</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="emaw_usb"    pos="26:25"   access="rw" rst="all0">
            <comment>emaw_usb</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="ema_usb"    pos="29:27"   access="rw" rst="010">
            <comment>ema_usb</comment>
            <options><mask/><shift/></options>
        </bits>
    </reg>
    <reg name="Memory_Margin2"    protect="rw">
        <bits name="emaw_nfsc"    pos="1:0"   access="rw" rst="all0">
            <comment>emaw_nfsc</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="ema_nfsc"    pos="4:2"   access="rw" rst="010">
            <comment>ema_nfsc</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="ema_vpurom"    pos="7:5"   access="rw" rst="all0">
            <comment>ema_vpurom</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="ema_imemrom"    pos="10:8"   access="rw" rst="010">
            <comment>ema_imemrom</comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="ken_vpurom"    pos="11"   access="rw" rst="1">
            <comment>ken_vpurom</comment>
        </bits>
        <bits name="pgen_vpurom"    pos="12"   access="rw" rst="0">
            <comment>ken_vpurom</comment>
        </bits>
        <bits name="ken_imemrom"    pos="13"   access="rw" rst="1">
            <comment>ken_imemrom</comment>
        </bits>
        <bits name="pgen_imemrom"    pos="14"   access="rw" rst="0">
            <comment>ken_imemrom</comment>
        </bits>
    </reg>

    <reg name="Memory_Observe"    protect="r">
        <bits name="mem_observe"    pos="31:0"   access="r">
            <comment>mem_observe</comment>
        </bits>
    </reg>

    <hole size="1856"/>
    <reg name="Cfg_Reserve" protect="rw">
        <comment>This register is reserved.
        </comment>
        <bits name="Reserve" pos="31:0" access="rw" rst="11110000111100001111000011110000">
            <comment>This register is reserved.
            </comment>
        </bits>
    </reg>
</module>

</archive>

<archive relative='uart.xml' >

<module name="uart" category="Ap">
  <var  name="UART_RX_FIFO_SIZE"    value="32"  />
  <var  name="UART_TX_FIFO_SIZE"    value="16"  />
  <var  name="NB_RX_FIFO_BITS"      value="5"   />
  <var  name="NB_TX_FIFO_BITS"      value="4"   />

  
  <reg protect="rw" name="ctrl">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Allows to turn off the UART:<br />0 = Disable<br />1 = Enable
      </comment>
    </bits>

    <bits access="rw" name="Data Bits" pos="1" rst="0">
      <options>
        <option name="7_BITS" value="0" />

        <option name="8_BITS" value="1" />

        <default />
      </options>

      <comment>Number of data bits per character (least significant bit
      first):<br />0 = 7 bits<br />1 = 8 bits </comment>
    </bits>

    <bits access="rw" name="Tx Stop Bits" pos="2" rst="0">
      <options>
        <option name="1_BIT" value="0" />

        <option name="2_BITS" value="1" />

        <default />
      </options>

      <comment>Stop bits controls the number of stop bits transmitted. Can
      receive with one stop bit (more inaccuracy can be compensated with two
      stop bits when divisor mode is set to 0).<br />0 = one stop bit is
      transmitted in the serial data.<br />1 = two stop bits are generated and
      transmitted in the serial data out. </comment>
    </bits>

    <bits access="rw" name="Parity Enable" pos="3" rst="0">
      <options>
        <option name="NO" value="0" />

        <option name="YES" value="1" />

        <default />
      </options>

      <comment> Parity is enabled when this bit is set. </comment>
    </bits>

    <bits access="rw" name="Parity Select" pos="5:4" rst="0">
      <options>
        <option name="ODD" value="0" />

        <option name="EVEN" value="1" />

        <option name="SPACE" value="2" />

        <option name="MARK" value="3" />

        <default />
      </options>

      <comment> Controls the parity format when parity is enabled:<br />00 =
      an odd number of received 1 bits is checked, or transmitted (the parity
      bit is included).<br />01 = an even number of received 1 bits is checked
      or transmitted (the parity bit is included).<br />10 = a space is
      generated and received as parity bit.<br />11 = a mark is generated and
      received as parity bit. </comment>
    </bits>


    <bits access="rw" name="Divisor Mode" pos="20" rst="0">
      <comment>Selects the divisor value used to generate the baud rate
      frequency (BCLK) from the SCLK (see UART Operation for details). If IrDA
      is enable, this bit is ignored and the divisor used will be 16.<br />0 =
      (BCLK = SCLK / 4)<br />1 = (BCLK = SCLK / 16) </comment>
    </bits>

    <bits access="rw" name="IrDA Enable" pos="21" rst="0">
      <comment>When set, the UART is in IrDA mode and the baud rate divisor
      used is 16 (see UART Operation for details). </comment>
    </bits>

    <bits access="rw" name="DMA Mode" pos="22" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Enables the DMA signaling for the Uart_Dma_Tx_Req_H and
      Uart_Dma_Rx_Req_H to the IFC. </comment>
    </bits>
    
    <bits access="rw" name="Auto Flow Control" pos="23" rst="0">
      <options>
        <option name="ENABLE" value="1" />
        
        <option name="DISABLE" value="0" />
        
        <default />
      </options>
      <comment>Enables the auto flow control. Uart_RTS is controlled by the Rx
      RTS bit and the UART Auto Control Flow System. If Uart_CTS
      become inactive high, the Tx data flow is stopped. </comment>
    </bits>

    <bits access="rw" name="Loop Back Mode" pos="24" rst="0">
      <comment>When set, data on the Uart_Tx line is held high, while the
      serial output is looped back to the serial input line, internally. In
      this mode all the interrupts are fully functional. This feature is used
      for diagnostic purposes. Also, in loop back mode, the modem control
      input Uart_CTS is disconnected and the modem control output Uart_RTS are
      looped back to the inputs, internally. In IrDA mode, Uart_Tx signal is
      inverted (see IrDA SIR Mode Support). </comment>
    </bits>

    <bits access="rw" name="Rx Lock Err" pos="25" rst="0">
      <comment>Allow to stop the data receiving when an error is detected
      (framing, parity or break). The data in the fifo are kept. </comment>
    </bits>

    <bits access="rw" name="Rx Break Length" pos="31:28" rst="0xF">
      <comment>Length of a break, in number of bits. </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Rx Fifo Level" pos="NB_RX_FIFO_BITS:0" rst="0">
       <options>
            <mask/>
            <shift/>
        </options>
        <comment>Those bits indicate the number of data available in the Rx
      Fifo. Those data can be read. </comment>
    </bits>

    <bits access="r" name="Tx Fifo space" pos="NB_TX_FIFO_BITS+8:8" rst="0">
        <options>
            <mask/>
            <shift/>
        </options>
        <comment>Those bits indicate the number of space available in the Tx
      Fifo. </comment>
    </bits>

    <bits access="r" name="Tx Active" pos="14" rst="0">
      <comment>This bit indicates that the UART is sending data. If no data is
      in the fifo, the UART is currently sending the last one through the
      serial interface. </comment>
    </bits>

    <bits access="r" name="Rx Active" pos="15" rst="0">
      <comment>This bit indicates that the UART is receiving a byte.
      </comment>
    </bits>

    <bits access="r" name="Rx Overflow Err" pos="16" rst="0">
      <comment>This bit indicates that the receiver received a new character
      when the fifo was already full. The new character is discarded. This bit
      is cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Tx Overflow Err" pos="17" rst="0">
      <comment>This bit indicates that the user tried to write a character when fifo was
          already full. The written data will not be kept. This bit is cleared when 
          the UART_STATUS register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Parity Err" pos="18" rst="0">
      <comment>This bit is set if the parity is enabled and a parity error
      occurred in the received data. This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Framing Err" pos="19" rst="0">
      <comment>This bit is set whenever there is a framing error occured. A
      framing error occurs when the receiver does not detect a valid STOP bit
      in the received data. This bit is cleared when the UART_STATUS register
      is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Break Int" pos="20" rst="0">
      <comment>This bit is set whenever the serial input is held in a logic 0
      state for longer than the length of x bits, where x is the value
      programmed Rx Break Length. A null word will be written in the Rx Fifo.
      This bit is cleared when the UART_STATUS register is written with any
      value. </comment>
    </bits>

    <bits access="r" name="DCTS" pos="24" rst="0">
      <comment>This bit is set when the Uart_CTS line changed since the last
      time this register has been written. This bit is cleared when the
      UART_STATUS register is written with any value. </comment>
    </bits>

    <bits access="r" name="CTS" pos="25" rst="1">
        <comment>current value of the Uart_CTS line. 
            <br/> '1' = Tx not allowed. 
            <br/> '0' = Tx allowed. 
      </comment>
    </bits>

    <bits access="r" name="DTR" pos="28" rst="0">
      <comment>Current value of the DTR line.
      </comment>
    </bits>
    
    <bits access="r" name="Clk Enabled" pos="31" rst="0">
      <comment>This bit is set when Uart Clk has been enabled and received by
      UART after Need Uart Clock becomes active. It serves to avoid enabling
      RTS too early.</comment>
    </bits>
  </reg>

  <reg protect="--" name="rxtx_buffer">
    <bits access="r" name="Rx Data" pos="7:0" rst="no">
      <comment>The UART_RECEIVE_BUFFER register is a read-only register that
      contains the data byte received on the serial input port. This register
      accesses the head of the receive FIFO. If the receive FIFO is full and
      this register is not read before the next data character arrives, then
      the data already in the FIFO will be preserved but any incoming data
      will be lost. An overflow error will also occur. </comment>
    </bits>

    <bits access="w" name="Tx Data" pos="7:0" rst="no">
      <comment>The UART_TRANSMIT_HOLDING register is a write-only register
      that contains data to be transmitted on the serial output port. 16
      characters of data may be written to the UART_TRANSMIT_HOLDING register
      before the FIFO is full. Any attempt to write data when the FIFO is full
      results in the write data being lost. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="irq_mask">
    <bits access="rw" name="Tx Modem Status" pos="0" rst="0">
      <comment>Clear to send signal change detected. </comment>
    </bits>

    <bits access="rw" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. </comment>
    </bits>

    <bits access="rw" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>Pulse detected on Uart_Dma_Tx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>Pulse detected on Uart_Dma_Rx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters
            in or out of the Rx Fifo during the last 4 character times.
        </comment>
    </bits>

    <bits access="rw" name="DTR RISE" pos="8" rst="0">
      <comment>Rising edge detected on the UART_DTR signal. 
      </comment>
    </bits>

    <bits access="rw" name="DTR FALL" pos="9" rst="0">
      <comment>Falling edge detected on the UART_DTR signal. 
      </comment>
    </bits>
  
  </reg>

  <reg protect="rw" name="irq_cause">
    <bits access="r" name="Tx Modem Status" pos="0" rst="0">
      <comment>Clear to send signal detected. Reset control: This bit is
      cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). Reset control: Reading the UART_RECEIVE_BUFFER
      until the Fifo drops below the trigger level. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). Reset control: Writing into UART_TRANSMIT_HOLDING
      register above threshold level. </comment>
    </bits>

    <bits access="r" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. Reset control: Reading from the UART_RECEIVE_BUFFER register.
      </comment>
    </bits>

    <bits access="r" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. Reset control: This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Tx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Rx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.
            Reset control: Write one in this register.
        </comment>    
    </bits>

    <bits access="rw" name="DTR RISE" pos="8" rst="0">
      <comment>This interrupt is generated when a rising edge is detected on the
      UART_DTR signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="DTR FALL" pos="9" rst="0">
      <comment>This interrupt is generated when a falling edge is detected on the
      UART_DTR signal. Reset control: Write one in this register.
      </comment>
    </bits>
    
    <bits access="r" name="Tx Modem Status U" pos="16" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Data Available U" pos="17" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed U" pos="18" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Timeout U" pos="19" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Line Err U" pos="20" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Dma Done U" pos="21" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Done U" pos="22" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Timeout U" pos="23" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="DTR RISE U" pos="24" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="DTR FALL U" pos="25" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
    
  </reg>

  <reg protect="rw" name="triggers">
    <bits access="rw" name="Rx Trigger" pos="NB_RX_FIFO_BITS-1:0" rst="0">
      <comment>Defines the empty threshold level at which the Data Available
      Interrupt will be generated. <br />The Data Available interrupt is
      generated when quantity of data in Rx Fifo &gt; Rx Trigger.</comment>
    </bits>

    <bits access="rw" name="Tx Trigger" pos="NB_TX_FIFO_BITS-1+8:8" rst="0">
      <comment>Defines the empty threshold level at which the Data Needed
      Interrupt will be generated.<br />The Data Needed Interrupt is generated
      when quantity of data in Tx Fifo &lt;= Tx Trigger.</comment>
    </bits>

    <bits access="rw" name="AFC Level" pos="NB_RX_FIFO_BITS-1+16:16" rst="0">
      <comment>Controls the Rx Fifo level at which the Uart_RTS Auto Flow
      Control will be set inactive high (see UART Operation for more details
      on AFC).<br />The Uart_RTS Auto Flow Control will be set inactive high
      when quantity of data in Rx Fifo &gt; AFC Level.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="CMD_Set">
    <bits access="rs" name="RI" pos="0" rst="0">
        <comment>Ring indicator. When write '1', set RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>
    
    <bits access="rs" name="DCD" pos="1" rst="0">
        <comment>Data carrier detect. When write '1', set DCD bit. When read, get DCD
            bit value.
        </comment>
    </bits>
    
    <bits access="rs" name="DSR" pos="2" rst="0">
        <comment>Data set ready. When write '1', set RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>
    
    <bits access="rs" name="Tx Break Control" pos="3" rst="0">
      <comment> Sends a break signal by holding the Uart_Tx line low until
      this bit is cleared. </comment>
    </bits>
    
    <bits access="rs" name="Tx Finish n Wait" pos="4" rst="0">
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>  

    <bits access="rs" name="RTS" pos="5" rst="0">
        <comment>Controls the Uart_RTS output.
            <br />0 = the Uart_RTS will be inactive high (Rx not allowed).
            <br />1 = the Uart_RTS will be active low (Rx allowed).
        </comment>
    </bits>
    
    <bits access="s" name="Rx Fifo Reset" pos="6" rst="0">
      <comment> Writing a 1 to this bit resets and flushes the Receive Fifo.
      This bit does not need to be cleared. </comment>
    </bits>
    
    <bits access="s" name="Tx Fifo Reset" pos="7" rst="0">
      <comment> Writing a 1 to this bit resets and flushes the Transmit Fifo.
      This bit does not need to be cleared. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="CMD_Clr">
    <bits access="rc" name="RI" pos="0" rst="0">
        <comment>Ring indicator. When write '1', clear RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>

    <bits access="rc" name="DCD" pos="1" rst="0">
        <comment>Data carrier detect. When write '1', clear DCD bit. When read, get DCD
            bit value.
        </comment>
    </bits>

    <bits access="rc" name="DSR" pos="2" rst="0">
        <comment>Data set ready. When write '1', clear RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>

    <bits access="rc" name="Tx Break Control" pos="3" rst="0">
      <comment> Sends a break signal by holding the Uart_Tx line low until
      this bit is cleared. </comment>
    </bits>
    
    <bits access="rc" name="Tx Finish n Wait" pos="4" rst="0">
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>  

    <bits access="rc" name="RTS" pos="5" rst="0">
        <comment>Controls the Uart_RTS output.
            <br />0 = the Uart_RTS will be inactive high.
            <br />1 = the Uart_RTS will be active low.
        </comment>
    </bits>
    
  </reg>
  
</module>


</archive>
<archive relative='sdmmc.xml' >


<module name="sdmmc" category="Ap">


    <reg name="apbi_ctrl_sdmmc" protect="rw">
       <bits name="L_Endian"  pos="2:0" access="rw" rst="000">
          <comment>Controls the big endian or little endian of the FIFO data.
              <br/>Take 32 bit data 0X0A0B0C0D for Example,bit[31:24]=Byte3,bit[23:16]=Byte2,bit[15:8]=Byte1,bit[7:0]=Byte0.
              <br/>"000": the order is not changed.
                <br/>Byte3="0A",Byte2="0B",Byte1="0C",Byte0="0D".
              <br/>"001": reversed on byte.
                <br/>Byte3="0D",Byte2="0C,Byte1="0B",Byte0="0A".
              <br/>"010": reversed on half word.
                <br/>Byte3="0C",Byte2="0D,Byte1="0A",Byte0="0B".
              <br/>"010": reversed on bit.
                <br/>Byte3="B0",Byte2="30,Byte1="D0",Byte0="50".
              <br/>"100": reversed on bit.
                <br/>Byte3="0A",Byte2="0X,Byte1="0D",Byte0="0C".
          </comment>
       </bits> 
       <bits name="Soft_rst_L" pos="3" access="rw" rst="1">
          <comment>For the software to clear FIFO in case there is an error in communication with SD controller and some data are left behind.
              <br/>Active Low.
          </comment>
       </bits>
     </reg>

     <hole size="32"/>

     <reg name="APBI_FIFO_TxRx"  protect="--">   
         <bits name="DATA_IN" pos="31:0" access="w">
           <comment>Write to the transmit FIFO
           </comment>
         </bits>
         <bits name="DATA_OUT" pos="31:0" access="r">
           <comment>Read in the receive FIFO
           </comment>
         </bits>
     </reg>



<hole size="16288"/>

<reg protect="rw" name="SDMMC_CONFIG">

	<bits access="rw" name="SDMMC_SENDCMD" pos="0" rst="0">
		<comment>SD/MMC operation begin register, active high.<br /> 
		When '1', the controller finishes the last command and goes into suspend status. At suspend status, the controller will not execute the next command until the bit is set '0'.
		</comment>
	</bits>
	
	<bits access="rw" name="SDMMC_SUSPEND" pos="1" rst="1">
		<comment>SD/MMC operation suspend register, active high.
		</comment>
	</bits>
	
	<bits access="rw" name="RSP_EN" pos="4" rst="0">
		<comment>'1'indicates having a response,'0'indicates no response.
		</comment>
	</bits>
	
    <bits access="rw" name="RSP_SEL" pos="6:5" rst="0">
        <options>
            <default/>
            <option name="R2" value="0b10"/>
            <option name="R3" value="0b01"/>
            <option name="OTHER" value="0b00"/>
        </options>
		<comment>Response select register,"10" means R2 response, "01" means R3 response, "00" means others response, "11" is reserved.
		</comment> 
	</bits>
	
    <bits access="rw" name="RD_WT_EN" pos="8" rst="0">
		<comment>'1' indicates data operation, which includes read and write.
		</comment>
	</bits>
	
	<bits access="rw" name="RD_WT_SEL" pos="9" rst="0">
        <options>
            <default/>
            <option name="READ" value="0"/>
            <option name="WRITE" value="1"/>
        </options>
		<comment>'1' means write operation,'0' means read operation.
		</comment>
	</bits>
	
	<bits access="rw" name="S_M_SEL" pos="10" rst="0">
        <options>
            <default/>
            <option name="SIMPLE"   value="0"/>
            <option name="MULTIPLE" value="1"/>
        </options>
		<comment>'1'means multiple block data operation.
		</comment>
	</bits>
	
</reg>
	
<reg protect="r" name="SDMMC_STATUS">

	<bits access="r" name="Not_SDMMC_OVER" pos="0" rst="0">
		<comment>'1' means the SD/MMC operation is not over.
		</comment>
	</bits>
		
	<bits access="r" name="BUSY" pos="1" rst="0">
		<comment>'1' means SD/MMC is busy.
		</comment>
	</bits>	

	<bits access="r" name="DL_BUSY" pos="2" rst="0">
		<comment>'1' means the data line is busy.
		</comment>
	</bits>
	
	<bits access="r" name="SUSPEND" pos="3" rst="1">
		<comment>'1' means the controller will not perform the new command when SDMMC_SENDCMD= '1'.
		</comment>
	</bits>

	
	
		

	<bits access="r" name="RSP_ERROR" pos="8" rst="0">
		<comment>Response CRC checks error register '1' means response CRC check error.
		</comment>
	</bits>
	
	<bits access="r" name="NO_RSP_ERROR" pos="9" rst="0">
		<comment>'1' means the card has no response to command. 
		</comment>
	</bits>
	
	<bits access="r" name="CRC_STATUS" pos="14:12" rst="0">
		<comment>CRC check for SD/MMC write operation <br /> 
		"101" transmission error<br />
		"010" transmission right<br />
		"111" flash programming error
		</comment>
	</bits>
	
	<bits access="r" name="DATA_ERROR" pos="23:16" rst="0">
		<comment>8 bits data CRC check, "00000000" means no data error, "00000001" means DATA0 CRC check error, "10000000" means DATA7 CRC check error, each bit match one data line.
		</comment>
	</bits>

	<bits access="r" name="DAT3_VAL" pos="24" rst="-">
		<comment>SDMMC DATA 3 value.
		</comment>
	</bits>
	
</reg>

<reg protect="rw" name="SDMMC_CMD_INDEX">

	<bits access="rw" name="COMMAND" pos="5:0" rst="0">
		<comment>SD/MMC command register.
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_CMD_ARG">

	<bits access="rw" name="ARGUMENT" pos="31:0" rst="0">
		<comment>SD/MMC command argument register, write data to the SD/MMC card.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_INDEX">

	<bits access="r" name="RESPONSE" pos="5:0" rst="0">
		<comment>SD/MMC response index register.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG3">

	<bits access="r" name="ARGUMENT3" pos="31:0" rst="0">
		<comment>Response argument of R1, R3 and R6, or 127 to 96 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG2">

	<bits access="r" name="ARGUMENT2" pos="31:0" rst="0">
		<comment>95 to 64 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG1">

	<bits access="r" name="ARGUMENT1" pos="31:0" rst="0">
		<comment>63 to 32 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG0">

	<bits access="r" name="ARGUMENT0" pos="31:0" rst="0">
		<comment>31 to 0 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_DATA_WIDTH">

	<bits access="rw" name="SDMMC_DATA_WIDTH" pos="3:0" rst="0">
		<comment>SD/MMC data width:<br />
		0x1: 1 data line<br />
		0x2: 2 reserved<br />
		0x4: 4 data lines<br />
		0x8: 8 data lines
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_BLOCK_SIZE">

	<bits access="rw" name="SDMMC_BLOCK_SIZE" pos="3:0" rst="0">
		<comment>SD/MMC size of one block:<br />
		0-1:reserved<br />
		2: 1 word<br />
		3: 2 words<br />
		4: 4 words<br />
		5: 8 words<br />
		6: 16 words<br />
 		       <br />
		11: 512 words<br />
		12-15 reserved
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_BLOCK_CNT">

	<bits access="rw" name="SDMMC_BLOCK_CNT" pos="15:0" rst="0">
		<comment>Block number that wants to transfer.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_INT_STATUS">

	<bits access="r" name="NO_RSP_INT" pos="0" rst="0">
		<comment>'1' means no response.
		</comment>
	</bits>

	<bits access="r" name="RSP_ERR_INT" pos="1" rst="0">
		<comment>'1' means CRC error of response.
		</comment>
	</bits>
	
	<bits access="r" name="RD_ERR_INT" pos="2" rst="0">
		<comment>'1' means CRC error of reading data.
		</comment>
	</bits>

	<bits access="r" name="WR_ERR_INT" pos="3" rst="0">
		<comment>'1' means CRC error of writing data.
		</comment>
	</bits>

	<bits access="r" name="DAT_OVER_INT" pos="4" rst="0">
		<comment>'1' means data transmission is over.
		</comment>
	</bits>

	<bits access="r" name="TXDMA_DONE_INT" pos="5" rst="0">
		<comment>'1' means tx dma done.
		</comment>
	</bits>

	<bits access="r" name="RXDMA_DONE_INT" pos="6" rst="0">
		<comment>'1' means rx dma done.
		</comment>
	</bits>
	
	<bits access="r" name="NO_RSP_SC" pos="8" rst="0">
		<comment>'1' means no response is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="RSP_ERR_SC" pos="9" rst="0">
		<comment>'1' means CRC error of response is the source of interrupt.
		</comment>
	</bits>
	
	<bits access="r" name="RD_ERR_SC" pos="10" rst="0">
		<comment>'1' means CRC error of reading data is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="WR_ERR_SC" pos="11" rst="0">
		<comment>'1' means CRC error of writing data is the source of interrupt.
		</comment>
	</bits>
	 
	<bits access="r" name="DAT_OVER_SC" pos="12" rst="0">
		<comment>'1' means the end of data transmission is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="TXDMA_DONE_SC" pos="13" rst="0">
		<comment>'1' means tx dma done is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="RXDMA_DONE_SC" pos="14" rst="0">
		<comment>'1' means rx dma done is the source of interrupt.
		</comment>
	</bits>    
	
</reg>



<reg protect="rw" name="SDMMC_INT_MASK">

	<bits access="rw" name="NO_RSP_MK" pos="0" rst="0">
		<comment>When no response, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="RSP_ERR_MK" pos="1" rst="0">
		<comment>When CRC error of response, '1' means INT is disable.
		</comment>
	</bits>
	
	<bits access="rw" name="RD_ERR_MK" pos="2" rst="0">
		<comment>When CRC error of reading data, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="WR_ERR_MK" pos="3" rst="0">
		<comment>When CRC error of writing data, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="DAT_OVER_MK" pos="4" rst="0">
		<comment>When data transmission is over, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="TXDMA_DONE_MK" pos="5" rst="0">
		<comment>when tx dma done, '1' means INT is disabled.
		</comment>
	</bits>

	<bits access="rw" name="RXDMA_DONE_MK" pos="6" rst="0">
		<comment>'1' means rx dma done, '1' means INT is disabled.
		</comment>
	</bits>    
</reg>


<reg protect="w" name="SDMMC_INT_CLEAR">

	<bits access="w" name="NO_RSP_CL" pos="0" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in NO_RSP_SC.
		</comment>
	</bits>

	<bits access="w" name="RSP_ERR_CL" pos="1" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RSP_ERR_SC.
		</comment>
	</bits>
	
	<bits access="w" name="RD_ERR_CL" pos="2" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RD_ERR_SC.
		</comment>
	</bits>

	<bits access="w" name="WR_ERR_CL" pos="3" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in WR_ERR_SC.
		</comment>
	</bits>

	<bits access="w" name="DAT_OVER_CL" pos="4" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in DAT_OVER_SC.
		</comment>
	</bits>

 	<bits access="w" name="TXDMA_DONE_CL" pos="5" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in TXDMA_DONE_SC.
		</comment>
	</bits>

	<bits access="w" name="RXDMA_DONE_CL" pos="6" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RXDMA_DONE_SC.
		</comment>
	</bits>   
</reg>

<reg protect="rw" name="SDMMC_TRANS_SPEED">

	<bits access="rw" name="SDMMC_TRANS_SPEED" pos="7:0" rst="0">
		<comment>Mclk = Pclk/(2*(SDMMC_TRANS_SPEED +1)).
		</comment>
	</bits>
</reg>

<reg protect="rw" name="SDMMC_MCLK_ADJUST">

	<bits access="rw" name="SDMMC_MCLK_ADJUST" pos="3:0" rst="0">
		<comment>This register may delay the mclk output. 
			 When MCLK_ADJUSTER = n, Mclk is outputted with  n Pclk.	
		</comment>
	</bits>

	<bits access="rw" name="CLK_INV" pos="4" rst="0">
		<comment>Invert Mclk.	
		</comment>
	</bits>

	<bits access="rw" name="SDMMC_MCLK_DISABLE" pos="8" rst="1">
		<comment>Disable Mclk.	
		</comment>
	</bits>

</reg>

</module>
</archive>

<archive relative='keypad.xml' >

<module name="keypad" category="Ap">
  <var name="KEY_NB" value="64">
    <comment> Number of key in the keypad
    </comment>
  </var>
  <var name="LOW_KEY_NB" value="32">
    <comment> Number of key in the low data register 
    </comment>
  </var>
  <var name="HIGH_KEY_NB" value="32">
    <comment> Number of key in the high data register
    </comment>
  </var>

  <reg protect="r" name="KP_DATA_L">
    <bits access="r" name="KP_DATA_L" pos="31:0" rst="0">
      <comment>For keys in column Idx_KeyOut(from 0 to 3) and in line Idx_KeyIn(from 0 to 7), the pressing status are stored in KP_DATA_L(Idx_KeyOut*8+Idx_KeyIn) :<br />0 = Released<br />1 = Pressed
      </comment>
      <options>
        <mask/>
        <shift/>
      </options>  
    </bits>

  </reg>

  <reg protect="r" name="KP_DATA_H">
    <bits access="r" name="KP_DATA_H" pos="31:0" rst="0">
      <comment>For keys in column Idx_KeyOut(from 4 to 7) and line Idx_KeyIn(from 0 to 7), the pressing status are stored in KP_DATA_H(Idx_KeyIn*8-32+Idx_KeyIn):<br />0 = Released<br />1 = Pressed
      </comment>
      <options>
        <mask/>
        <shift/>
      </options>  
    </bits>

  </reg>

  <reg protect="r" name="KP_STATUS">

    <bits access="r" name="KEYIN_STATUS" pos="7:0" rst="0">
      <comment>For keys in lines status <br />0 = Released<br />1 = Pressed
      </comment>
      <options>
        <mask/>
        <shift/>
      </options>  
  </bits>

    <bits access="r" name="KP_ON" pos="31" rst="0">
      <comment>Indicate Key ON pressing status :<br />0 = Release<br />1 = Pressed
      </comment>
      <options><default/><mask/><shift/></options>
    </bits>

  </reg>

  
  <reg protect="rw" name="KP_CTRL">
    <bits access="rw" name="KP_En" pos="0" rst="0">
        <comment>This bit enables key detection. If this bit is '0', the key detection function 
            is disabled. Key ON is an exception, it can be still detected and generate key interrupt
            even if KP_En = '0', however in this case, the debouncing time configuration in key
            control register is ignored and the key ON state is considerred to be stable if it keeps
            same in consecutive 2 cycles of 16KHz clock.<br />
        <br />0 = keypad disable<br />1 = keypad enable  
      </comment>
    </bits>
   
    <bits access="rw" name="KP_DBN_Time" pos="9:2" rst="0">
      <comment>De-bounce time = (KP_DBN_TIME + 1) * SCAN_TIME, SCAN_TIME = 0.3125 ms * Number of Enabled KeyOut (determined by KP_OUT_MASK). For example, if KP_DBN_TIME = 7, KP_OUT_MASK = "111111", then De-bounce time = (7+1)*0.3125*6=15 ms. The maximum debounce time is 480 ms.
      </comment>
    </bits>

   <bits access="rw" name="KP_ITV_Time" pos="15:10" rst="63">
      <comment>Configure interval of generating an IRQ if one key or several keys are pressed long time. Interval of IRQ generation = (KP_ITV_Time + 1) * (KP_DBN_TIME + 1) * SCAN_TIME. SCAN_TIME = 0.3125 ms * Number of Enabled KeyOut (determined by KP_OUT_MASK). For example, if KP_ITV_TIME = 7, KP_DBN_TIME = 7, KP_OUT_MASK = "111111", then De-bounce time = (7+1)*(7+1)*0.3125*6=120 ms. 
      </comment>
    </bits>
    
    <bits access="rw" name="KP_IN_MASK" pos="23:16" rst="63">
        <comment>each bit masks one input lines.<br />
            '1' = enabled <br /> '0' = disabled
            
            <br/>The Key In pins 0 to 5 are muxed with the boot mode pins, latched during Reset.
                <br/> Key_In 0: BOOT_MODE_NO_AUTO_PU.
                <br/> Key_In 1: BOOT_MODE_FORCE_MONITOR.
                <br/> Key_In 2: BOOT_MODE_UART_MONITOR_ENABLE.
                <br/> Key_In 3: BOOT_MODE_USB_MONITOR_DISABLE.
                <br/> Key_In 4: reserved

        </comment>
    </bits>

    <bits access="rw" name="KP_OUT_MASK" pos="31:24" rst="63">
        <comment>each bit masks one output lines.<br />
            '1' = enabled <br /> '0' = disabled </comment>
    </bits>

  </reg>

  <reg protect="rw" name="KP_IRQ_MASK">
    <bits access="rw" name="KP_EVT0_IRQ_MASK" pos="0" rst="0">
      <comment>This bit mask keypad irq generated by event0 (key press or key release event, not including all keys release event which is event1). 
        <br />0 = keypad event irq disable<br />1 = keypad event irq enable  
      </comment>
    </bits>
    
    <bits access="rw" name="KP_EVT1_IRQ_MASK" pos="1" rst="0">
      <comment>This bit mask keypad irq generated by event1 (all keys release event). 
        <br />0 = keypad event irq disable<br />1 = keypad event irq enable  
      </comment>
    </bits>
    
    <bits access="rw" name="KP_ITV_IRQ_MASK" pos="2" rst="0">
      <comment>This bit mask keypad irq generated by key pressed long time (generated each interval configured in KP_ITV_Time. 
        <br />0 = keypad interval irq disable<br />1 = keypad interval irq enable  
      </comment>
    </bits>

  </reg>

  <reg protect="r" name="KP_IRQ_CAUSE">
    <bits access="r" name="KP_EVT0_IRQ_CAUSE" pos="0" rst="0">
      <comment>keypad event0(key press or key release event, not including all keys release which is event1) IRQ cause. 
      </comment>
    </bits>

    <bits access="r" name="KP_EVT1_IRQ_CAUSE" pos="1" rst="0">
      <comment>keypad event1(all keys release event) IRQ cause. 
      </comment>
    </bits>

    <bits access="r" name="KP_ITV_IRQ_CAUSE" pos="2" rst="0">
      <comment>keypad interval irq cause. 
      </comment>
    </bits>
    
    <bits access="r" name="KP_EVT0_IRQ_STATUS" pos="16" rst="0">
      <comment>keypad event0(key press or key release event, not including all keys release which is event1) irq status. 
      </comment>
    </bits>

    <bits access="r" name="KP_EVT1_IRQ_STATUS" pos="17" rst="0">
      <comment>keypad event1(all keys release event) irq status. 
      </comment>
    </bits>
  
    <bits access="r" name="KP_ITV_IRQ_STATUS" pos="18" rst="0">
      <comment>keypad interval irq status. 
      </comment>
    </bits>

  </reg>
  
  <reg protect="w" name="KP_IRQ_CLR">
    <bits access="c" name="KP_IRQ_CLR" pos="0" rst="0">
      <comment>Write '1' to this bit clears key IRQ. </comment>
    </bits>
  </reg>

</module>
</archive>
<archive relative='pwm.xml' >

<module name="pwm" category="Ap">
    <reg name="PWT_Config" protect="rw">
        <bits name="PWT_Enable" pos="0" access="rw" rst="0">
            <comment>Enables the Pulse Width Tone output
                <br/>1 = Enable PWT output
                <br/>0 = Disable PWT output
            </comment>            
        </bits>
        <bits name="PWT_Start" pos="1" access="r" rst="0">
            <comment>Start Flag
            </comment>            
        </bits>
        <bits name="PWT_Duty" pos="13:4" access="rw" rst="all1">
            <comment>The PWT_Duty value can be used to set the approximate volume of the tone.
                <br/> The PWT_Duty value must be less than or equal to half the PWT_Period value and must be at least a value of 8, otherwise no tone will be generated.
            </comment>
        </bits>
        <bits name="PWT_Period" pos="26:16" access="rw" rst="all1">
            <comment>PWT_Period is the divider value to produce a tone of a given frequency.
                <br/> To calculate the PWT_Period value, Use the following formula:
                <br/>  PWT_Period = FBASE/FNOTE
                <br/> where FBASE is the frequency of the PWM module clock (it is based on the system frequency, 26, 39, 52, 78 or 104 MHz divided by 5).  FNOTE is the frequency of the desired tone.
            </comment>
        </bits>        
    </reg>
    <reg name="LPG_Config" protect="rw">
        <bits name="LPG_Reset_L"    pos="0"     access="rw" rst="0">
            <comment>Setting this bit to '0' will reset the Light Pulse Generator internal counters.
            </comment>
        </bits>
        <bits name="LPG_Test"    pos="1"     access="rw" rst="0">
            <comment>If 1, Test mode with square wave output
            </comment>
        </bits>
        <bits name="LPG_OnTime" pos="7:4"   access="rw" rst="0xf">
            <comment>Configures the duty cycle for the Light Pulse Generator by setting the ontime for the LPG output. The actual on-time is calculated as: Tick Period * LPG_OnTime * 256 where the Tick Period is nominally 1/16kHz.
            </comment>
            <options>
                <option name="undefined" value="0"/>
                <option name="15_6mS" value="1"/>
                <option name="31_2mS" value="2"/>
                <option name="46_8mS" value="3"/>
                <option name="62mS" value="4"/>
                <option name="78mS" value="5"/>
                <option name="94mS" value="6"/>
                <option name="110mS" value="7"/>
                <option name="125mS" value="8"/>
                <option name="140mS" value="9"/>
                <option name="156mS" value="10"/>
                <option name="172mS" value="11"/>
                <option name="188mS" value="12"/>
                <option name="200mS" value="13"/>
                <option name="218mS" value="14"/>
                <option name="234mS" value="15"/>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="LPG_Period"     pos="18:16" access="rw">
            <comment>Configures the main period of the light pulse generator. The period is calculated based on the following configurations:
            <br/>with the Tick Period ~ 1/16kHz<br/>
            </comment>
            <options>
                <option name="0_125s" value="0"><comment>Tick Period * 2048</comment></option>
                <option name="0_25s"  value="1"><comment>Tick Period * 4096</comment></option>
                <option name="0_5s"   value="2"><comment>Tick Period * 8192</comment></option>
                <option name="0_75s"  value="3"><comment>Tick Period * 12288</comment></option>
                <option name="1s"     value="4"><comment>Tick Period * 16384</comment></option>
                <option name="1_25s"  value="5"><comment>Tick Period * 20480</comment></option>
                <option name="1_5s"   value="6"><comment>Tick Period * 24576</comment></option>
                <option name="1_75s"  value="7"><comment>Tick Period * 28672</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name="PWL0_Config" protect="rw">
        <bits name="PWL_Min" pos="7:0" access="rw" rst="all1">
            <comment>Sets the lower boundary for PWL pulse.  When pulse mode is not used, this is the threshold value for the PWL0.  Reading this value will return the current value used for the threshold.
            </comment>
        </bits>
        <bits name="PWL_Max" pos="15:8" access="rw" rst="all1">
            <comment>Sets the upper boundary for PWL pulse.  When pulse mode is not used, this value is ignored.  Reading this value will return the LFSR value used for generating the PWL outputs.
            </comment>
        </bits>
        <bits name="PWL0_En_H" pos="16" access="rs" rst="0">
            <comment>When this bit is written with '1', the PWL 0 is enabled and the output is a PRBS whose average on-time is proportional to PWL_Min.  This bit is cleared when either of the Force bits are written.  Reading this bit will return the current state of the PWL0 enable.
            </comment>
        </bits>
        <bits name="PWL0_Force_L" pos="17" access="rc" rst="0">
            <comment>Writing a '1' to this bit will force the PWL0 to output a low value.  If the PWL0 was previously enabled, this will clear the bit.
            </comment>
        </bits>
        <bits name="PWL0_Force_H" pos="18" access="s" rst="no">
            <comment>Writing a '1' to this bit will force the PWL0 to output a high value.  If the PWL0 was previously enabled, this will clear the bit.
            </comment>
        </bits>
        <bits name="PWL_Pulse_En" pos="19" access="rw" rst="0">
            <comment>This will enable the PWL pulse mode.  The threshold will dynamically sweep between PWL_Min and PWL_Max at a rate depending on PWL_Pulse_Per.
            </comment>
        </bits>
        <bits name="PWL0_Set_OE" pos="20" access="rs" rst="0">
            <comment>Writing '1' to this bit will set the output enable.  Reading this bit will return the current status.
            </comment>
        </bits>
        <bits name="PWL0_Clr_OE" pos="21" access="c" rst="no">
            <comment>Writing '1' to this bit will clear the output enable.
            </comment>
        </bits>
        <bits name="PWL_Set_Mux" pos="22" access="rs" rst="0">
            <comment>Writing a '1' to this bit will swap the PWL0 and PWL1 outputs.  Reading this bit will return the current status.
            </comment>
        </bits>
        <bits name="PWL_Clr_Mux" pos="23" access="c" rst="no">
            <comment>Writing a '1' to this bit will unswap the PWL0/PWL1 outputs.
            </comment>
        </bits>
        <bits name="PWL_Pulse_Per" pos="31:24" access="rw" rst="all1">
            <comment>This value will adjust the pulse period when pulsing is enabled.
            </comment>
        </bits>
    </reg>
    <reg name="PWL1_Config" protect="rw">
        <bits name="PWL1_Threshold"         pos="7:0"   access="rw" rst="all1">
            <comment>Average duty cycle for the Pulse Width Light 1 output. The average duty cycle is calculated as PWL1_Threshold/256.
            </comment>
        </bits>
        <bits name="LFSR_Reg"               pos="15:8"  access="r" rst="0xa1">
            <comment>LFSR value for PWL.
            </comment>
        </bits>
        <bits name="PWL1_En_H" pos="16" access="rs" rst="0">
            <comment>When this bit is written with '1', the PWL 1 is enabled and the output is a PRBS whose average on-time is proportional to PWL1_Threshold.  This bit is cleared when either of the Force bits are written.  Reading this bit will return the current state of the PWL1 enable.
            </comment>
        </bits>
        <bits name="PWL1_Force_L" pos="17" access="rc" rst="0">
            <comment>Writing a '1' to this bit will force the PWL1 to output a low value.  If the PWL1 was previously enabled, this will clear the bit.
            </comment>
        </bits>
        <bits name="PWL1_Force_H" pos="18" access="s" rst="no">
            <comment>Writing a '1' to this bit will force the PWL1 to output a high value.  If the PWL1 was previously enabled, this will clear the bit.
            </comment>
        </bits>
        <bits name="PWL1_Set_OE" pos="20" access="rs" rst="0">
            <comment>Writing '1' to this bit will set the output enable.  Reading this bit will return the current status.
            </comment>
        </bits>
        <bits name="PWL1_Clr_OE" pos="21" access="c" rst="no">
            <comment>Writing '1' to this bit will clear the output enable.
            </comment>
        </bits>
    </reg>
    <reg name="Cfg_Clk_PWM"  protect="rw">
        <bits name="PWM_Divider"    pos="7:0"   access="rw" rst="all1">
            <comment>The Pwm reference clock frequency is the system clock divided by this register value + 1.
            </comment>
        </bits>
    </reg>
</module>
</archive>

<archive relative='i2c_master.xml' >


<module name="i2c_master" category="Ap">
    
    <reg protect="rw" name="CTRL">
        
 		<bits access="rw" name="EN" pos="0" rst="0">
			<comment> I2C master enable, high active. 
			</comment>
		</bits>
        
		<bits access="rw" name="IRQ_MASK" pos="8" rst="0">
			<comment> I2C master interrupt enable, high active. 
			</comment>
		</bits>
        
		<bits access="rw" name="Clock_Prescale" pos="31:16" rst="0xFFFF">
            <comment> This register is used to prescale the SCL clock line. Due to the structure of I2C interface, this module uses a 5*SCL clock frequency. Clock_Prescale must be programmed to this 5*SCL clock frequency (minus 1). Change the value of Clock_Prescale only when bit EN is cleared. <br /> <br /> Example:<br /> PCLK_MOD is 52 MHz, desired SCL is 100 KHz. <br /> Prescale = 52MHz / (5 * 100KHz) -1 = 103.
			</comment>
            <options><mask/></options>
		</bits>
	</reg>

    <reg protect="r" name="STATUS">
        
        <bits access="r" name="IRQ_Cause" pos="0" rst="0">
			<comment> IRQ Cause bit. This bit is set when one byte transfer has been completed or arbitration is lost, this bit is generated by bit IRQ_Status AND bit IRQ_MASK.
			</comment>
        </bits>
        
		<bits access="r" name="IRQ_Status" pos="4" rst="0">
			<comment> IRQ status bit. 
			</comment>
        </bits>
        
		<bits access="r" name="TIP" pos="8" rst="0">
			<comment> TIP, Transfer in progress.
				'1' when transferring data. '0' when transfer complete.
			</comment>
		</bits>
        
		<bits access="r" name="AL" pos="12" rst="0">
			<comment> AL,Arbitration lost.
				This bit is set when the I2C master lost arbitration.
			</comment>
		</bits>
        
		<bits access="r" name="Busy" pos="16" rst="0">
			<comment> Busy,I2C bus busy.
				'1' after START signal detected.
				'0' after STOP signal detected.
			</comment>
		</bits>
        
		<bits access="r" name="RxACK" pos="20" rst="0">
			<comment> RxACK, Received acknowledge from slave.
				'1'= "No ACK" received.
				'0'= ACK received.
			</comment>
		</bits>
    </reg>
    
	<reg protect="wr" name="TXRX_BUFFER">
        
		<bits access="w" name="TX_DATA" pos="7:0" rst="-">
			<comment> Byte to transmit via I2C. <br /> for Bit 0, In case of a data transfer this bit represents the data's LSB. In case of a slave address transfer this bit represents the RW bit. <br /> '1' = reading from slave. <br /> '0' = writing to slave.   
			</comment>
		</bits>

 		<bits access="r" name="RX_DATA" pos="7:0" rst="-">
			<comment> Last byte received via I2C. 
			</comment>
		</bits>
        
	</reg>

	<reg protect="w" name="CMD">

		<bits access="w" name="ACK" pos="0" rst="0">
			<comment> ACK,when master works as a receiver,sent ACK(ACK='0') or NACK(ACK='1').
			</comment>
		</bits>

		<bits access="w" name="RD" pos="4" rst="0">
			<comment> RD,read from slave, this bit is auto cleared.
			</comment>
		</bits>

		<bits access="w" name="STO" pos="8" rst="0">
			<comment> STO,generate stop condition, this bit is auto cleared.
			</comment>
		</bits>
        
		<bits access="w" name="WR" pos="12" rst="0">
			<comment> WR,write to slave, this bit is auto cleared.
			</comment>
		</bits>

		<bits access="w" name="STA" pos="16" rst="0">
			<comment> STA,generate (repeated) start condition, this bit is auto cleared.
			</comment>
		</bits>
    </reg>

  	<reg protect="w" name="IRQ_CLR">  
        
		<bits access="c" name="IRQ_Clr" pos="0" rst="0">
			<comment> When write '1', clears a pending I2C interrupt.
			</comment>
        </bits>
    </reg>
    

</module>
</archive>
<archive relative='timer_ap.xml' >


<module name="timer_ap" category="Ap">
    <var name = "NB_INTERVAL" value="1"/>
    <var name = "INT_TIMER_NB_BITS" value="56"/>
    <var name = "HW_TIMER_NB_BITS" value="64"/>

    <reg name="OSTimer_LoadVal_L" protect="rw">
        <bits name="OS_LoadVal_L" pos="31:0" access="rw" rst="0">
            <comment>Value loaded to OS timer low 31 bits.
            </comment>
        </bits>
    </reg>
    <reg name="OSTimer_Ctrl" protect="rw">
        <bits name="OS_LoadVal_H" pos="23:0" access="rw" rst="0">
            <comment>Value loaded to OS timer high 24 bits.
            </comment>
            <options>
            <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="Enable" pos="24" access="rw" rst="0">
            <comment>Write '1' to this bit will enable OS timer.
                <br/>When read, the value is what we have written to this bit, it changes immediately  after been written.
            </comment>
        </bits>
        <bits name="Enabled" pos="25" access="r" rst="0">
            <comment>Read this bit will get the information if OS timer is really enabled or not. This bit will change only after the next front of 16 KHz system clock.
                <br/>
                <br/>'1' indicates OS timer enabled.
                <br/>'0' indicates OS timer not enabled.
            </comment>
        </bits>
        <bits name="Cleared" pos="26" access="r" rst="0">
            <comment>Read this bit will get the information if OS timer interruption clear operation is finished or not.
                <br/>
                <br/>'1' indicates OS timer interruption clear operation is on going.
                <br/>'0' indicates no OS timer interruption clear operation is on going.
            </comment>
        </bits>
        <bits name="Repeat" pos="28" access="rw" rst="0">
            <comment>Write '1' to this bit will set OS timer to repeat mode.
                <br/>When read, get the information if OS timer is in repeat mode.
                <br/>
                <br/>'1' indicates OS timer in repeat mode.
                <br/>'0' indicates OS timer not in repeat mode.
            </comment>
        </bits>
        <bits name="Wrap" pos="29" access="rw" rst="0">
            <comment>Write '1' to this bit will set OS timer to wrap mode.
                <br/>When read, get the information if OS timer is in wrap mode.
                <br/>
                <br/>'1' indicates OS timer in wrap mode.
                <br/>'0' indicates OS timer not in wrap mode.
            </comment>
        </bits>
        <bits name="Load" pos="30" access="rw" rst="0">
            <comment>Write '1' to this bit will load the initial value to OS timer.
            </comment>
        </bits>
    </reg>
    <reg name="OSTimer_CurVal_L" protect="rw">
        <bits name="OS_CurVal_L" pos="31:0" access="r" rst="-">
            <comment>Current value of OS timer. The value is low 32 bits.
            </comment>
        </bits>
    </reg>
    <reg name="OSTimer_CurVal_H" protect="rw">
        <bits name="OS_CurVal_H" pos="23:0" access="r" rst="-">
            <comment>Current value of OS timer. The value is high 24 bits and the first 8 bits are sign extension of the most important bit. A negative value indicates that the timer has wraped.
            </comment>
            <options>
            <mask/><shift/><default/>
            </options>
        </bits>
    </reg>
    <reg name="OSTimer_LockVal_L" protect="rw">
        <bits name="OS_LockVal_L" pos="31:0" access="r" rst="-">
            <comment>Locked value of OS timer low 32 bits on this reading OSTimer_LockVal_L.
            </comment>
            <options>
            <mask/><shift/><default/>
            </options>
        </bits>
    </reg>
    <reg name="OSTimer_LockVal_H" protect="rw">
        <bits name="OS_LockVal_H" pos="23:0" access="r" rst="-">
            <comment>Locked value of OS timer high 24 bits on last reading OSTimer_LockVal_L.
            </comment>
            <options>
            <mask/><shift/><default/>
            </options>
        </bits>
    </reg>
    <reg name="HWTimer_Ctrl" protect="rw">
        <bits name="Interval_En" pos="8" access="rw" rst="0">
            <comment>This bit enables interval IRQ mode.
                <br/>
                <br/>'0': hw delay timer does not generate interval IRQ.
                <br/>'1': hw delay timer generate an IRQ each interval.
            </comment>
        </bits>
        <bits name="Interval" pos="1:0" access="rw" rst="00">
            <comment> interval of generating an HwTimer IRQ. 
                <br/>
                <br/>"00": interval of 1/8 second.
                <br/>"01": interval of 1/4 second.
                <br/>"10": interval of 1/2 second.
                <br/>"11": interval of 1 second.
            </comment>
        </bits>
    </reg>
    <reg name="HWTimer_CurVal_L" protect="rw">
        <bits name="HW_CurVal_L" pos="31:0" access="r" rst="0">
            <comment>Current value of the hardware delay timer low 32 bits. The value is incremented every 61 us or 0.5us. This timer is running all the time and wrap at value 0xFFFFFFFF.
            </comment>
        </bits>
    </reg>
    <reg name="HWTimer_CurVal_H" protect="rw">
        <bits name="HW_CurVal_H" pos="31:0" access="r" rst="0">
            <comment>Current value of the hardware delay timer high 32 bits. The value is incremented every 61 us or 0.5us. This timer is running all the time and wrap at value 0xFFFFFFFF.
            </comment>
        </bits>
    </reg>
    <reg name="HWTimer_LockVal_L" protect="rw">
        <bits name="HW_LockVal_L" pos="31:0" access="r" rst="0">
            <comment>Locked value of the hardware delay timer low 32 bits on this reading HWTimer_LockVal_L.
            </comment>
        </bits>
    </reg>
    <reg name="HWTimer_LockVal_H" protect="rw">
        <bits name="HW_LockVal_H" pos="31:0" access="r" rst="0">
            <comment>Locked value of the hardware delay timer high 32 bits on last reading HWTimer_LockVal_L.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Mask_Set" protect="rw">
        <bits name="OSTimer_Mask" pos="0" access="rs" rst="0">
            <comment>Set mask for OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Mask" pos="1" access="rs" rst="0">
            <comment>Set mask for hardwre delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Mask" pos="2" access="rs" rst="0">
            <comment>Set mask for hardwre delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Mask_Clr" protect="rw">
        <bits name="OSTimer_Mask" pos="0" access="rc" rst="0">
            <comment>Clear mask for OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Mask" pos="1" access="rc" rst="0">
            <comment>Clear mask for hardwre delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Mask" pos="2" access="rc" rst="0">
            <comment>Clear mask for hardwre delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Clr" protect="rw">
        <bits name="OSTimer_Clr" pos="0" access="c">
            <comment>Clear OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Clr" pos="1" access="c">
            <comment>Clear hardware delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Clr" pos="2" access="c">
            <comment>Clear hardware delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Cause" protect="rw">
        <bits name="OSTimer_Cause" pos="0" access="r" rst="0">
            <comment>OS timer IRQ cause.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Cause" pos="1" access="r" rst="0">
            <comment>hardware delay timer wrap IRQ cause.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Cause" pos="2" access="r" rst="0">
            <comment>hardware delay timer interval IRQ cause.
            </comment>
        </bits>
        <bits name="OSTimer_Status" pos="16" access="r" rst="0">
            <comment>OS timer IRQ status.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Status" pos="17" access="r" rst="0">
            <comment>hardware delay timer wrap IRQ status.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Status" pos="18" access="r" rst="0">
            <comment>hardware delay timer interval IRQ status.
            </comment>
        </bits>
        <bitgroup name="Other_Tims_irq">
            <entry ref="HWTimer_Wrap_Cause"/>
            <entry ref="HWTimer_Itv_Cause"/>
        </bitgroup>
    </reg>

</module>

</archive>

<archive relative='apb1_ifc.xml' >

<include file="globals.xml"/>
<module name="apb1_ifc" category="Ap">
  <var name="AP_APB1_IFC_AHB_MAXSPACE" value="20" />
  <var name="AP_APB1_IFC_ADDR_ALIGN" value="2" />

  

  <struct count="2" name="ch">
    <comment>
        The Channel 0 conveys data from the AIF to the memory.<br/>
        The Channel 1 conveys data from the memory to the AIF.
        <br/>These Channels only exist with Voice Option.
    </comment>
    <reg protect="rw" name="control">
      <bits access="w" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer. </comment>
      </bits>

      <bits access="w" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit disable the channel.
        <br />When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled. </comment>
      </bits>

      <bits access="rw" name="auto_disable" pos="4" rst="0">
        <comment>Automatic channel Disable. When this bit is set, the channel is automatically disabled at the next interrupt. 
        </comment>
      </bits>
    </reg>

    <reg protect="r" name="status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>When 1 the channel is enabled</comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>When 1 the fifo is empty </comment>
      </bits>

      <bits access="r" name="cause_ief" pos="8" rst="0">
        <comment>Cause interrupt End of FIFO. </comment>
      </bits>

      <bits access="r" name="cause_ihf" pos="9" rst="0">
        <comment>Cause interrupt Half of FIFO. </comment>
      </bits>

      <bits access="r" name="cause_i4f" pos="10" rst="0">
        <comment>Cause interrupt Quarter of FIFO. </comment>
      </bits>
      
      <bits access="r" name="cause_i3_4f" pos="11" rst="0">
        <comment>Cause interrupt Three Quarter of FIFO. </comment>
      </bits>

      <bits access="r" name="ief" pos="16" rst="0">
        <comment>End of FIFO interrupt status bit. </comment>
      </bits>

      <bits access="r" name="ihf" pos="17" rst="0">
        <comment>Half of FIFO interrupt status bit. </comment>
      </bits>

      <bits access="r" name="i4f" pos="18" rst="0">
        <comment>Quarter of FIFO interrupt status bit. </comment>
      </bits>

      <bits access="r" name="i3_4f" pos="19" rst="0">
        <comment>Three Quarter of FIFO interrupt status bit.</comment>
      </bits>
    </reg>

    <reg protect="rw" name="start_addr">
      <bits access="rw" name="start_addr"
            pos="AP_NB_BITS_ADDR-1:AP_APB1_IFC_ADDR_ALIGN" rst="0xFFFFFFFF" display="hex">
        <comment>AHB Start Address. This field represent the start address of the FIFO located in RAM.
        </comment>
      </bits>
     </reg>

    <reg protect="rw" name="Fifo_Size">
      <bits access="rw" name="Fifo_Size" pos="19:4" rst="all1" display="hex">
        <comment>Fifo size in bytes, max 1MBytes.
            <br />The size of the fifo must be a multiple of 16 (The four LSB are always zero). 
        </comment>
      </bits>
    </reg>
    <hole size="32" />
    <reg protect="rw" name="int_mask">
      <bits access="rw" name="end_fifo" pos="8" rst="0">
        <comment>END FIFO Mask interrupt. When one this interrupt is enabled.
        </comment>
      </bits>

      <bits access="rw" name="half_fifo" pos="9" rst="0">
        <comment>HALF FIFO Mask interrupt. When one this interrupt is enabled.
        </comment>
      </bits>

      <bits access="rw" name="quarter_fifo" pos="10" rst="0">
        <comment>QUARTER FIFO Mask interrupt. When one this interrupt is
        enabled. </comment>
      </bits>
      
      <bits access="rw" name="three_quarter_fifo" pos="11" rst="0">
        <comment>THREE QUARTER FIFO Mask interrupt. When one this interrupt is
        enabled. </comment>
      </bits>
    </reg>

    <reg protect="rw" name="int_clear">
      <bits access="c" name="end_fifo" pos="8" rst="0">
        <comment>Write one to clear end of fifo interrupt. </comment>
      </bits>

      <bits access="c" name="half_fifo" pos="9" rst="0">
        <comment>Write one to clear half of fifo interrupt. </comment>
      </bits>

      <bits access="c" name="quarter_fifo" pos="10" rst="0">
        <comment>Write one to clear Quarter fifo interrupt. </comment>
      </bits>

      <bits access="c" name="three_quarter_fifo" pos="11" rst="0">
        <comment>Write one to clear Three Quarter fifo interrupt. </comment>
      </bits>
    </reg>

    <reg protect="r" name="cur_ahb_addr">
      <bits access="r" name="cur_ahb_addr" pos="AP_NB_BITS_ADDR-1:0" rst="0" display="hex">
        <comment>Current AHB address value. The nine MSB bit is constant and
        equal to the PAGE_ADDR field in the IFC_CH_AHB_START_ADDR register.
        </comment>
      </bits>
    </reg>
  </struct>

</module>
</archive>

<archive relative='apb2_ifc.xml' >


<include file="globals.xml"/>

<var name="AP_APB2_IFC_ADDR_ALIGN" value="0" />
<var name="AP_APB2_IFC_TC_LEN" value="23" />
<var name="AP_APB2_IFC_STD_CHAN_NB" value="8" />
<var name="AP_APB2_IFC_RFSPI_CHAN" value="0" />

<module name="apb2_ifc" category="Ap">
  

  <reg protect="w" name="get_ch">
    <bits access="rw" name="ch_to_use" pos="3:0" rst="0">
      <comment>This field indicates which standard channel to use.
      <br /> Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
      <br /> After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
      <br />0000 = use Channel0
      <br />0001 = use Channel1
      <br />0010 = use Channel2 
      <br /> ...
      <br />0111 = use Channel7
      <br />1111 = all channels are busy</comment>
      <options><mask/><shift/><default/></options>
    </bits>
  </reg>

  <reg protect="r" name="dma_status">
    <bits access="r" name="ch_enable" pos="AP_APB2_IFC_STD_CHAN_NB+AP_APB2_IFC_RFSPI_CHAN-1:0" rst="0">
      <comment>This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
      <br />0000_0000 = All channels disabled 
      <br />0000_0001 = Ch0 enabled 
      <br />0000_0010 = Ch1 enabled 
      <br />0000_0100 = Ch2 enabled 
      <br />0000_0101 = Ch0 and Ch2 enabled 
      <br />0000_0111 = Ch0, Ch1 and Ch2 enabled 
      <br />1111_1111 = all channels enabled</comment>
    </bits>

    <bits access="r" name="ch_busy" pos="AP_APB2_IFC_STD_CHAN_NB-1+16:16" rst="0">
      <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
    </bits>
  </reg>

  <reg protect="r" name="debug_status">
    <bits access="r" name="dbg_status" pos="0" rst="0">
      <comment>Debug Channel Status .<br />0= The debug channel is running
      (not idle) <br />1= The debug channel is in idle mode</comment>
    </bits>
  </reg>

  <hole size="32" />

  

  <struct count="AP_APB2_IFC_STD_CHAN_NB" name="std_ch">
    <reg protect="rw" name="control">
      <bits access="w" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer. </comment>
      </bits>

      <bits access="w" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit disable the channel.
        <br />When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled. </comment>
      </bits>

      <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
        <comment>Read FIFO data exchange high 8-bit and low 8-bit.
        <br />0: Exchange;
        <br />1: No exchange. </comment>
      </bits>

      <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
        <comment>Write FIFO data exchange high 8-bit and low 8-bit.
        <br />0: No exchange;
        <br />1: Exchange. </comment>
      </bits>

      <bits access="rw" name="autodisable" pos="4" rst="1">
        <comment>Set Auto-disable mode<br /> 0 = when TC reach zero the
        channel is not automatically released.<br /> 1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.</comment>
      </bits>
      
      <bits access="rw" name="Size" pos="6:5" rst="all0">
        <comment>Peripheral Size
            <br /> 0= 8-bit peripheral
            <br /> 1= 16-bit peripheral
            <br /> 2= 32-bit peripheral
        </comment>
        <options>
            <option name="Byte"      value="0"></option>
            <option name="Half_Word" value="1"></option>
            <option name="Word"      value="2"></option>
            <mask/><shift/><default/>
        </options>
      </bits>

      <bits access="rw" name="req_src" pos="12:8" rst="0xf" display="hex">
        <options linkenum="Sys_Ifc_Request_IDs"> 
          <shift/><mask/><default/>
        </options>

        <comment>Select DMA Request source</comment>
      </bits>

        <bits access="rw" name="flush" pos="16" rst="0">
        <comment>When one, flush the internal FIFO channel. 
        <br />This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel. 
        <br /> Before writting back this bit to zero the internal fifo must empty.
        </comment>
        
      </bits>
    </reg>

    <reg protect="r" name="status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>Enable bit, when '1' the channel is running  </comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>The internal channel fifo is empty </comment>
      </bits>
    </reg>

    <reg protect="rw" name="start_addr">
      <bits access="rw" name="start_addr"
            pos="AP_NB_BITS_ADDR-1:AP_APB2_IFC_ADDR_ALIGN" rst="all1" display="hex">
        <comment>AHB Address. This field represent the start address of the
        transfer.
        <br />For a 32-bit peripheral, this address must be aligned 32-bit.
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="tc">
      <bits access="rw" name="tc" pos="AP_APB2_IFC_TC_LEN-1:0" rst="all1" display="hex">
        <comment>Transfer Count, this field indicated the transfer size in bytes to perform.
        <br />During a transfer a write in this register add the new value to the current TC. 
        <br />A read of this register return the current current transfer count.
        </comment>
      </bits>
    </reg>
  </struct>
  
</module>

</archive>
<archive relative='ap_irq.xml' >


<include file="globals.xml"/>

<module name="ap_irq" category="Ap">
    
    
    <enum name="XCPU_Irq_Lines">
        <entry name="XCpu_Main_Irq_Line"><comment>XCPU Irq Lines</comment></entry>
        
        <entry name="XCpu_Page_Spy_Irq_Line" value="3"/>
        <entry name="XCpu_Debug_Irq_Line" value="4"/>
        <entry name="XCpu_Host_Irq_Line"/>
    </enum>


    <reg name="Cause" protect="rw">
        <comment>If cause is not null and interrupt are enabled then the interrupt line 0 is driven on the system CPU.
            <br/>The cause for the Irq sources, one bit for each module's irq source.
            <br/>The cause is the actual Irq source masked by the mask register.
        </comment>
        <bits name="Cause" pos="AP_NB_IRQ-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="AP_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Status" protect="rw">
        <comment>The status for the level Irq sources, one bit for each module's irq source.
            <br/>The status reflect the actual Irq source.
        </comment>
        <bits name="Status" pos="AP_NB_IRQ-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="AP_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Mask_Set" protect="rw">
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Set" pos="AP_NB_IRQ-1:0" access="rs" rst="0" cut="1" cutprefix="" cutenum="AP_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Mask_Clear" protect="rw">
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Clr" pos="AP_NB_IRQ-1:0" access="rc" rst="0" cut="1" cutprefix="" cutenum="AP_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="NonMaskable" protect="rw">
        <bits name="Main_IRQ" pos="10" access="r" rst="0">
            <comment>This is the Main Irq source it drive the system CPU interrupt line 0.
                <br/>This bit comes from the modules irq and is masked by the Mask and SC registers.
            </comment>
        </bits>
        <bits name="Page_Spy_IRQ" pos="13" access="r" rst="0">
            <comment>This is the Page Spy Irq source it drive the system CPU interrupt line 3.
                <br/>This bit is controlled by the page spy module.
            </comment>
        </bits>
        <bits name="Debug_IRQ" pos="14" access="rw" rst="0">
            <comment>This is the debug Irq source, the value written here drives the system CPU interrupt line 4.
            </comment>
        </bits>
        <bits name="Host_IRQ" pos="15" access="r" rst="0">
            <comment>This is the Host Irq source it drive the system CPU interrupt line 5.
                <br/>This bit is controlled by the host internal register.
            </comment>
        </bits>
        <bits name="IntEnable_Status" pos="31" access="r" rst="1">
            <comment>Status of the Interrupt enable semaphore bit.
            </comment>
        </bits>
   </reg>
    <reg name="SC" protect="">
        <bits name="IntEnable" pos="0" access="rw" rst="1">
            <comment>Interrupt enable semaphore, used for critical section.
                <br/>Read returns its value and then clears it to '0' disabling interrupts.
                <br/>Write the read value to restore the previous state, this will exit the critical section.
            </comment>
        </bits>
    </reg>
    <reg name="WakeUp_Mask" protect="rw">
        <comment>Each bit to '1' in that registers allows the correcponding interrupt to wake up the A5 CPU (i.e.: Reenable it's clock, see CLOCK_AP_ENABLE and CLOCK_AP_DISABLE registers in sys_ctrl_ap registers section)
        </comment>
        <bits name="WakeUp_Mask" pos="AP_NB_IRQ-1:0" access="rw" rst="0" cut="1" cutprefix="" cutenum="AP_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Cpu_Sleep" protect="rw">
        <bits name="Sleep" pos="0" access="w" rst="0">
            <comment>Writing '1' to this bit will put the XCPU to sleep (i.e.: Disable it's clock, see CLOCK_AP_ENABLE and CLOCK_AP_DISABLE registers in sys_ctrl registers section)
            </comment>
        </bits>
    </reg>
    <reg name="Pulse_Mask_Set" protect="rw">
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Pulse_Mask_Set" pos="AP_NB_IRQ_PULSE-1:0" access="rs" rst="0" cut="1" cutprefix="" cutenum="AP_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Mask_Clr" protect="rw">
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Pulse_Mask_Clr" pos="AP_NB_IRQ_PULSE-1:0" access="rc" rst="0" cut="1" cutprefix="" cutenum="AP_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Clear" protect="rw">
        <comment>Writing '1' clears the corresponding Pulse IRQ.
            <br/>Pulse IRQ are set by the modules and cleared here.
        </comment>
        <bits name="Pulse_Clr" pos="AP_NB_IRQ_PULSE-1:0" access="c" rst="0" cut="1" cutprefix="" cutenum="AP_Irq_Id" cutstart="0"/>
    </reg>
    <reg name="Pulse_Status" protect="rw">
        <comment>The status for the Pulse Irq sources, one bit for each module's irq source.
            <br/>The status reflect the actual Irq source.
        </comment>
        <bits name="Status" pos="AP_NB_IRQ_PULSE-1:0" access="r" rst="0" cut="1" cutprefix="" cutenum="AP_Irq_Id" cutstart="0"/>
    </reg>

</module>

</archive>

<archive relative='gouda.xml' >


<include file='globals.xml'/>

<module name="gouda" category="Ap">
  <var name="GD_MAX_OUT_WIDTH" value="320" />
      <comment>Maximum output width in pixels</comment>
  <var name="GD_NB_BITS_LCDPOS" value="10" />
      <comment>Number of bits coding position in virtual screen</comment>
  <var name="GD_FP_FRAC_SIZE" value="8" />
      <comment>Number of bits of fractional part of internal fixed point values</comment>
  <var name="GD_FIXEDPOINT_SIZE" value="2+GD_FP_FRAC_SIZE" />
      <comment>Number of bits of internal fixed point values</comment>
  <var name="GD_NB_BITS_STRIDE" value="13" />
      <comment>Number of bits for stride storage</comment>

  
  <reg protect="rw" name="gd_command">
    <bits access="rw" name="start" pos="0" rst="0x0">
      <comment>Starts the image transfer. Autoreset</comment>
    </bits>
  </reg>

  <reg protect="r" name="gd_status">
    <bits access="r" name="ia_busy" pos="0" rst="0x0">
      <comment>High while image accelerator is busy</comment>
    </bits>
    <bits access="r" name="lcd_busy" pos="4" rst="0x0">
      <comment>High while LCD controller is busy</comment>
    </bits>
  </reg>

  <reg protect="rc" name="gd_eof_irq">
    <bits access="rc" name="eof_cause" pos="0" rst="0x0">
        <comment>High when End Of Frame IRQ has been generated.
            <br />To clear it, write 1 in this bit or in eof_status.
        </comment>
    </bits>
    <bits name="vsync_rise" pos="2" access="ro" rst="0x0">
        <comment>Vsync rise interrupt.
        </comment>
    </bits>
    <bits name="vsync_fall" pos="3" access="ro" rst="0x0">
        <comment>Vsync fall interrupt
        </comment>
    </bits>
    <bits name="dpi_overflow" pos="4" access="ro" rst="0x0">
        <comment>Dpi overflow interrupt
        </comment>
    </bits>
    <bits name="dpi_frameover" pos="5" access="ro" rst="0x0">
        <comment>Frame over interrupt.
        </comment>
    </bits>
    <bits name="mipi_int" pos="6" access="ro" rst="0x0">
        <comment>interrupt.
        </comment>
    </bits>
    <bits access="rc" name="eof_status" pos="16" rst="0x0">
      <comment>Unmasked version of eof_cause.
            <br />To clear it, write 1 in this bit or in eof_status.
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_eof_irq_mask">
    <bits access="rw" name="eof_mask" pos="0" rst="0x0">
        <comment>EOF interrupt generation mask:
            <br />0: EOF IRQ disabled
            <br />1: EOF IRQ enabled
        </comment>
    </bits>
    <bits name="vsync_rise_mask" pos="1" access="ro" rst="0x0">
        <comment>Vsync rise interrupt.
        </comment>
    </bits>
    <bits name="vsync_fall_mask" pos="2" access="ro" rst="0x0">
        <comment>Vsync fall interrupt.
        </comment>
    </bits>
    <bits name="dpi_overflow_mask" pos="3" access="ro" rst="0x0">
        <comment>Dpi overflow interrupt.
        </comment>
    </bits>
    <bits name="dpi_frameover_mask" pos="4" access="ro" rst="0x0">
        <comment>Frame over interrupt.
        </comment>
    </bits>
    <bits name="mipi_int_mask" pos="5" access="ro" rst="0x0">
        <comment>Mipi interrupt
        </comment>
    </bits>
  </reg>

  
  <reg protect="rw" name="gd_roi_tl_ppos">
    <bits access="rw" name="x0" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
        <comment>LCD Region Of Interest Top-Left pixel x-axis </comment>
    </bits>
    <bits access="rw" name="y0" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
        <comment>LCD Region Of Interest Top-Left pixel y-axis </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_roi_br_ppos">
    <bits access="rw" name="x1" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
        <comment>LCD Region Of Interest Bottom-Right pixel x-axis </comment>
    </bits>
    <bits access="rw" name="y1" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
        <comment>LCD Region Of Interest Bottom-Right pixel y-axis </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_roi_bg_color">
    <bits access="rw" name="b" pos="7:0" rst="0x0">
        <comment>Blue component of the ROI background color</comment>
    </bits>
    <bits access="rw" name="g" pos="15:8" rst="0x0">
        <comment>Green component of the ROI background color</comment>
    </bits>
    <bits access="rw" name="r" pos="23:16" rst="0x0">
        <comment>Red component of the ROI background color</comment>
    </bits>
    <bits name="alpha" pos="31:24" access="rw" rst="0x0">
        <comment>.
        </comment>
    </bits>
  </reg>

  
  <reg protect="rw" name="gd_vl_input_fmt">
    <bits access="rw" name="format" pos="1:0" rst="0x0">
        <comment>Input image format
            <br />00b: RGB565 pixel packed
            <br />01b: YUV4:2:2 pixel packed (UYVY)
            <br />10b: YUV4:2:2 pixel packed (YUYV)
            <br />11b: YUV4:2:0 planar (IYUV)
        </comment>
    </bits>
    <bits access="rw" name="stride" pos="GD_NB_BITS_STRIDE+1:2" rst="0x0">
        <comment>Image stride in bytes (of Y component for planar formats).
            <br />This is the length from the beginning of a line to the beginning of the next line (can be different from image width * pixel size).
        </comment>
    </bits>
    <bits access="rw" name="active" pos="31" rst="0x0">
        <comment>Defines Layer's activity:
            <br />0: Layer disabled
            <br />1: Layer active
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_tl_ppos">
    <bits access="rw" name="x0" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
        <comment>Video Layer (layer 0) Top-Left pixel x-axis position</comment>
    </bits>
    <bits access="rw" name="y0" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
        <comment>Video Layer (layer 0) Top-Left pixel y-axis position</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_br_ppos">
    <bits access="rw" name="x1" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
        <comment>Video Layer (layer 0) Bottom-Right pixel x-axis position</comment>
    </bits>
    <bits access="rw" name="y1" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
        <comment>Video Layer (layer 0) Bottom-Right pixel y-axis position</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_extents">
    <bits access="rw" name="max_line" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
        <comment>Number of lines of source image (idem gd_vl_br_ppos.y1 when
                 vertical scaling factor is one).
        </comment>
    </bits>
    <bits access="rw" name="max_col" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
        <comment>Number of columns of source image (idem gd_vl_br_ppos.x1 when
                 vertical scaling factor is one).
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_blend_opt">
    <bits access="rw" name="chroma key b" pos="4:0" rst="0x0">
        <comment>Blue component of the Chroma Key</comment>
        <options><mask/></options>
    </bits>
    <bits access="rw" name="chroma key g" pos="10:5" rst="0x0">
        <comment>Green component of the Chroma Key</comment>
        <options><mask/></options>
    </bits>
    <bits access="rw" name="chroma key r" pos="15:11" rst="0x0">
        <comment>Red component of the Chroma Key</comment>
        <options><mask/></options>
    </bits>
    <bitgroup name="chroma key color">
        <entry ref="chroma key b"/>
        <entry ref="chroma key g"/>
        <entry ref="chroma key r"/>
    </bitgroup>
    <bits access="rw" name="chroma key enable" pos="16" rst="0x0">
        <comment>Enables the Chroma Keying</comment>
        <options><mask/></options>
    </bits>
    <bits access="rw" name="chroma key mask" pos="19:17" rst="0x0">
        <comment>Allows a range of color for the Chroma Keying:
            <br />000b: exact color match
            <br />001b: disregard 1 LSBit of each color component for matching
            <br />011b: disregard 2 LSBit of each color component for matching
            <br />111b: disregard 3 LSBit of each color component for matching
        </comment>
        <options><mask/></options>
    </bits>
    <bits access="rw" name="alpha" pos="27:20" rst="0x0">
        <comment>Layer Alpha blending coefficient</comment>
        <options><mask/></options>
    </bits>
    <bits access="rw" name="rotation" pos="29:28" rst="0x0">
        <comment>Layer rotation selection
            <br />00b: No rotation
            <br />01b: 90  degrees rotation (clockwise)
            <br />10b: reserved
            <br />11b: reserved
        </comment>
        <options><mask/></options>
    </bits>
    <bits access="rw" name="depth" pos="31:30" rst="0x0">
        <comment>Layer depth
            <br />00b: Video layer behind all Overlay layers
            <br />01b: Video layer between Overlay layers 1 and 0
            <br />10b: Video layer between Overlay layers 2 and 1
            <br />11b: Video layer on top of all Overlay layers
        </comment>
        <options><mask/></options>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_y_src">
    <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:1" rst="0x0">
        <comment>Dword-aligned address of the Y component (or RGB) of the source image</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_u_src">
    <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
        <comment>Dword-aligned address of the U component of the source image</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_v_src">
    <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
        <comment>Dword-aligned address of the V component of the source image</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_vl_resc_ratio">
    <bits access="rw" name="xPitch" pos="GD_FIXEDPOINT_SIZE-1:0" rst="0x0">
        <comment>Video layer rescaling ratio upon x-axis. This is a 2.8 fixed point number representing the input/output width ratio.</comment>
    </bits>
    <bits access="rw" name="yPitch" pos="GD_FIXEDPOINT_SIZE+15:16" rst="0x0">
        <comment>Video layer rescaling ratio upon y-axis. This is a 2.8 fixed point number representing the input/output height ratio.</comment>
    </bits>
  </reg>

  
  <struct count="3" name="Overlay_Layer">
    <comment>
        The Overlay layers have a fixed depth relative to their index. Overlay layer 0 is the first to be drawn (thus the deepest), overlay layer 2 is the last to be drawn.
    </comment>
  <reg protect="rw" name="gd_ol_input_fmt">
    <bits access="rw" name="format" pos="1:0" rst="0x0">
        <comment>Input image format
            <br />0: RGB565 pixel packed
            <br />1: ARGB8888 pixel packed
            <br />others: reserved
        </comment>
    </bits>
    <bits access="rw" name="stride" pos="GD_NB_BITS_STRIDE+1:2" rst="0x0">
        <comment>Image stride in 16-bits word.
            <br />This is the length from the beginning of a line to the beginning of the next line (can be different from image width * pixel size).
        </comment>
    </bits>
    <bits access="rw" name="active" pos="31" rst="0x0">
        <comment>Defines Layer's activity:
            <br />0: Layer disabled
            <br />1: Layer active
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_ol_tl_ppos">
    <bits access="rw" name="x0" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
        <comment>Overlay Layer (layer X+1) Top-Left pixel x-axis position</comment>
    </bits>
    <bits access="rw" name="y0" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
        <comment>Overlay Layer (layer X+1) Top-Left pixel y-axis position</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_ol_br_ppos">
    <bits access="rw" name="x1" pos="GD_NB_BITS_LCDPOS-1:0" rst="0x0">
        <comment>Overlay Layer (layer X+1) Bottom-Right pixel x-axis position</comment>
    </bits>
    <bits access="rw" name="y1" pos="GD_NB_BITS_LCDPOS+15:16" rst="0x0">
        <comment>Overlay Layer (layer X+1) Bottom-Right pixel y-axis position</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_ol_blend_opt">
    <bits access="rw" name="chroma key b" pos="4:0" rst="0x0">
        <comment>Blue component of the Chroma Key</comment>
    </bits>
    <bits access="rw" name="chroma key g" pos="10:5" rst="0x0">
        <comment>Green component of the Chroma Key</comment>
    </bits>
    <bits access="rw" name="chroma key r" pos="15:11" rst="0x0">
        <comment>Red component of the Chroma Key</comment>
    </bits>
    <bitgroup name="chroma key color">
        <entry ref="chroma key b"/>
        <entry ref="chroma key g"/>
        <entry ref="chroma key r"/>
    </bitgroup>
    <bits access="rw" name="chroma key enable" pos="16" rst="0x0">
        <comment>Enables the Chroma Keying</comment>
    </bits>
    <bits access="rw" name="chroma key mask" pos="19:17" rst="0x0">
        <comment>Allows a range of color for the Chroma Keying:
            <br />000b: exact color match
            <br />001b: disregard 1 LSBit of each color component for matching
            <br />011b: disregard 2 LSBit of each color component for matching
            <br />111b: disregard 3 LSBit of each color component for matching
        </comment>
    </bits>
    <bits access="rw" name="alpha" pos="27:20" rst="0x0">
        <comment>Layer Alpha blending coefficient</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_ol_rgb_src">
    <bits access="rw" name="addr" pos="NB_BITS_ADDR-1:2" rst="0x0">
        <comment>Dword-aligned address of the source image</comment>
    </bits>
  </reg>
  </struct>

  
  <reg protect="rw" name="gd_lcd_ctrl">
    <bits access="rw" name="Destination" pos="1:0" rst="0x0">
        <comment>Destination Selection
        </comment>
        <options>
            <option name="LCD CS 0" value ="0"></option>
            <option name="LCD CS 1" value ="1"></option>
            <option name="Memory LCD type" value ="2"></option>
            <option name="Memory RAM" value ="3"></option>
        </options>
    </bits>
    <bits access="rw" name="Output Format" pos="6:4" rst="0x0">
       <comment>Output format
            <br />000b:  8-bit - RGB3:3:2 - 1cycle/1pixel - RRRGGGBB
            <br />001b:  8-bit - RGB4:4:4 - 3cycle/2pixel - RRRRGGGG/BBBBRRRR/GGGGBBBB
            <br />010b:  8-bit - RGB5:6:5 - 2cycle/1pixel - RRRRRGGG/GGGBBBBB
            <br />011b:  reserved
            <br />100b: 16-bit - RGB3:3:2 - 1cycle/2pixel - RRRGGGBBRRRGGGBB
            <br />101b: 16-bit - RGB4:4:4 - 1cycle/1pixel - XXXXRRRRGGGGBBBB
            <br />110b: 16-bit - RGB5:6:5 - 1cycle/1pixel - RRRRRGGGGGGBBBBB
            <br />111b:  reserved
            <br />
            <br /> The MSB select also the AHB access size (8-bit or 16-bit) when Memory destination is selected.
            <br /> Must set to RGB565 when RAM type destination selected
        </comment>
        <options>
            <option name="8-bit;RGB332" value ="0"></option>
            <option name="8-bit;RGB444" value ="1"></option>
            <option name="8-bit;RGB565" value ="2"></option>
            <option name="16-bit;RGB332" value ="4"></option>
            <option name="16-bit;RGB444" value ="5"></option>
            <option name="16-bit;RGB565" value ="6"></option>
        </options>
    </bits>
    <bits access="rw" name="CS0 Polarity" pos="8" rst="0x0">
       <comment>Change Polarity of CS0 signal
            <br /> 0: no change
            <br /> 1: Inverted
        </comment>
    </bits>
    <bits access="rw" name="CS1 Polarity" pos="9" rst="0x0">
       <comment>Change Polarity of CS1 signal
            <br /> 0: no change
            <br /> 1: Inverted
        </comment>
    </bits>
    <bits access="rw" name="RS Polarity" pos="10" rst="0x0">
       <comment>Change Polarity of RS signal
            <br /> 0: no change
            <br /> 1: Inverted
        </comment>
    </bits>
    <bits access="rw" name="WR Polarity" pos="11" rst="0x0">
       <comment>Change Polarity of WR signal
            <br /> 0: no change
            <br /> 1: Inverted
        </comment>
    </bits>
    <bits access="rw" name="RD Polarity" pos="12" rst="0x0">
       <comment>Change Polarity of RD signal
            <br /> 0: no change
            <br /> 1: Inverted
        </comment>
    </bits>

    <bits access="rw" name="Nb Command" pos="20:16" rst="0x0">
       <comment>Number of command to be send to the LCD command (up to 31)
        </comment>
    </bits>
    <bits access="w" name="Start command" pos="24" rst="0x0">
       <comment>Start command transfer only. Autoreset
       </comment>
    </bits>
  </reg>
  <reg protect="rw" name="gd_lcd_timing">
        <comment>All value are in cycle number of system clock
        </comment>
    <bits access="rw" name="TAS" pos="2:0" rst="0x0">
        <comment>Address setup time (RS to WR, RS to RD)
        </comment>
    </bits>
    <bits access="rw" name="TAH" pos="6:4" rst="0x0">
        <comment>Adress hold time
        </comment>
    </bits>
    <bits access="rw" name="PWL" pos="13:8" rst="0x0">
        <comment>Pulse Width Low level, between 2 and 63.
        </comment>
    </bits>
    <bits access="rw" name="PWH" pos="21:16" rst="0x0">
        <comment>Pulse Width High level, between 2 and 63 (must be > (TAH+TAS) ).
        </comment>
    </bits>
  </reg>
  <reg protect="rw" name="gd_lcd_mem_address">
    <bits access="rw" name="addr_dst" pos="NB_BITS_ADDR-1:2" rst="all0">
        <comment>Address destination pointer when memory destination is selected.
                 <br />The addr_dst[1] which correspond to the M_A[0] on the memory interface is used to select between command/data.
        </comment>
    </bits>
  </reg>
  <reg protect="rw" name="gd_lcd_stride_offset">
    <bits access="rw" name="stride_offset" pos="10:0" rst="all0">
        <comment>Address offset (in Bytes) skipped at the end of each line when memory destination is selected.
                 <br />This 2D feature allows for in-memory image compositing.
        </comment>
    </bits>
  </reg>
  <reg protect="rw" name="gd_lcd_single_access">
    <bits access="rw" name="lcd_data" pos="15:0" rst="all0">
        <comment>data to write or data readen (the readen data is ready when the lcd is not busy)
        </comment>
    </bits>
    <bits access="rw" name="type" pos="16" rst="0x0">
        <comment>Acesss type selection
            <br />0: Command
            <br />1: Data
        </comment>
    </bits>
    <bits access="w" name="start_write" pos="17" rst="0x0">
        <comment>Start a single write access. Autoreset
       </comment>
    </bits>
    <bits access="w" name="start_read" pos="18" rst="0x0">
        <comment>Start a single read access (only when LCD output selected). Autoreset.
       </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gd_spilcd_config">
    <bits access="rw" name="spi_lcd_select" pos="0" rst="0"> </bits>
    <bits access="rw" name="spi_device_id" pos="6:1" rst="all0"> </bits>
    <bits access="rw" name="spi_clk_divider" pos="14:7" rst="all0"> </bits>
    <bits access="rw" name="spi_dummy_cycle" pos="17:15" rst="all0"> </bits>
    <bits access="rw" name="spi_line" pos="19:18" rst="all0"> </bits>
    <bits access="rw" name="spi_rx_byte" pos="22:20" rst="all0"> </bits>
    <bits access="rw" name="spi_rw" pos="23" rst="0"> </bits>
  </reg>
  <reg protect="ro" name="gd_spilcd_rd">
    <bits access="ro" name="spi_lcd_rd" pos="31:0" rst="all0">
        <comment>
        </comment>
    </bits>
  </reg>
    <reg name="GD_VL_FIX_RATIO" protect="rw">
        <bits name="mirror" pos="18" access="rw" rst="0x0">
            <comment>Mirror enable.
            </comment>
        </bits>
        <bits name="l_yfixen" pos="17" access="rw" rst="0x0">
            <comment>.
            </comment>
        </bits>
        <bits name="l_xfixen" pos="16" access="rw" rst="0x0">
            <comment>.
            </comment>
        </bits>
        <bits name="l_yratio" pos="15:8" access="rw" rst="0x0">
            <comment>.
            </comment>
        </bits>
        <bits name="l_xratio" pos="7:0" access="rw" rst="0x0">
            <comment>.
            </comment>
        </bits>
    </reg>

    <reg name="DCT_SHIFTR_Y_reg0" protect="rw">
        <bits name="counter_en" pos="31" access="rw" rst="0x0">
            <comment>Use to delay between rgb data over and fetch new data.
            </comment>
        </bits>
        <bits name="delay_counter" pos="23:0" access="rw" rst="0x0">
            <comment>.
            </comment>
        </bits>
    </reg>

    <reg name="DCT_SHIFTR_Y_reg1" protect="rw">
        <bits name="VL_cKeyMask" pos="28:24" access="rw" rst="0x0">
            <comment>Video layer ckey color mask.
            </comment>
        </bits>
        <bits name="VL_cKeyColor.R" pos="23:16" access="rw" rst="0x0">
            <comment>Video layer ckey color R.
            </comment>
        </bits>
        <bits name="VL_cKeyColor.G" pos="15:8" access="rw" rst="0x0">
            <comment>Video layer ckey color G.
            </comment>
        </bits>
        <bits name="VL_cKeyColor.B" pos="7:0" access="rw" rst="0x0">
            <comment>Video layer ckey color B.
            </comment>
        </bits>
    </reg>

    <reg name="DCT_CHOOSE_Y_reg0" protect="rw">
        <bits name="OL0_cKeyMask" pos="28:24" access="rw" rst="0x0">
            <comment>Overlay 0 ckey color mask.
            </comment>
        </bits>
        <bits name="OL0_cKeyColor.R" pos="23:16" access="rw" rst="0x0">
            <comment>Overlay 0 ckey color R.
            </comment>
        </bits>
        <bits name="OL0_cKeyColor.G" pos="15:8" access="rw" rst="0x0">
            <comment>Overlay 0 ckey color G.
            </comment>
        </bits>
        <bits name="OL0_cKeyColor.B" pos="7:0" access="rw" rst="0x0">
            <comment>Overlay 0 ckey color B.
            </comment>
        </bits>
    </reg>

    <reg name="DCT_CHOOSE_Y_reg1" protect="rw">
        <bits name="OL1_cKeyMask" pos="28:24" access="rw" rst="0x0">
            <comment>Overlay 1 ckey color mask.
            </comment>
        </bits>
        <bits name="OL1_cKeyColor.R" pos="23:16" access="rw" rst="0x0">
            <comment>Overlay 1 ckey color R.
            </comment>
        </bits>
        <bits name="OL1_cKeyColor.G" pos="15:8" access="rw" rst="0x0">
            <comment>Overlay 1 ckey color G.
            </comment>
        </bits>
        <bits name="OL1_cKeyColor.B" pos="7:0" access="rw" rst="0x0">
            <comment>Overlay 1 ckey color B.
            </comment>
        </bits>
    </reg>

    <reg name="DCT_SHIFTR_UV_reg0" protect="rw">
        <bits name="OL2_cKeyMask" pos="28:24" access="rw" rst="0x0">
            <comment>Overlay 2 ckey color mask.
            </comment>
        </bits>
        <bits name="OL2_cKeyColor.R" pos="23:16" access="rw" rst="0x0">
            <comment>Overlay 2 ckey color R.
            </comment>
        </bits>
        <bits name="OL2_cKeyColor.G" pos="15:8" access="rw" rst="0x0">
            <comment>Overlay 2 ckey color G.
            </comment>
        </bits>
        <bits name="OL2_cKeyColor.B" pos="7:0" access="rw" rst="0x0">
            <comment>Overlay 2 ckey color B.
            </comment>
        </bits>
    </reg>

    <reg name="DCT_SHIFTR_UV_reg1" protect="rw">
        <bits name="vsync_toggle_hsync_cnt" pos="10:0" access="rw" rst="0x0">
            <comment>For vsync to hsync setup.
            </comment>
        </bits>
    </reg>

    <reg name="DCT_CHOOSE_UV_reg0" protect="rw">
    </reg>
    <reg name="DCT_CHOOSE_UV_reg1" protect="rw">
    </reg>
    <reg name="DCT_CONFIG" protect="rw">
        <bits name="dct_compress_sel" pos="0" access="rw" rst="0x0">
            <comment>0: 5/16;  1: 6/16.
            </comment>
        </bits>
    </reg>
    <reg name="DPI_CONFIG" protect="rw">
        <bits name="r_dpi_data_enable" pos="16" access="ro" rst="0x0">
            <comment>Dpi data line in useuse to mux data line with nand.
            </comment>
        </bits>
        <bits name="outoff_data_out" pos="15" access="ro" rst="0x0">
            <comment>Status.
            </comment>
        </bits>
        <bits name="outoff_clk_out" pos="14" access="ro" rst="0x0">
            <comment>Status.
            </comment>
        </bits>
        <bits name="outoff_all_out" pos="13" access="ro" rst="0x0">
            <comment>Status.
            </comment>
        </bits>

        <bits name="r_rgb_format" pos="12" access="rw" rst="0x0">
            <comment>0:24bit 1:16bit.
            </comment>
        </bits>
        <bits name="r_ddr_format" pos="11" access="rw" rst="0x0">
            <comment>0:8bit ddr data bus 1:12bit ddr data bus.
            </comment>
        </bits>
        <bits name="r_ddr_en" pos="10" access="rw" rst="0x0">
            <comment>Rgb data output ddr enable.
            </comment>
        </bits>
        <bits name="r_dsi_enable" pos="9" access="rw" rst="0x0">
            <comment>Mipi enable.
            </comment>
        </bits>
        <bits name="r_outoff_data" pos="8" access="rw" rst="0x0">
            <comment>Rgb panel disable output data.
            </comment>
        </bits>
        <bits name="r_outoff_clk" pos="7" access="rw" rst="0x0">
            <comment>Rgb panel disable output clock.
            </comment>
        </bits>
        <bits name="r_outoff_all" pos="6" access="rw" rst="0x0">
            <comment>Rgb panel disable output all.
            </comment>
        </bits>
        <bits name="r_pix_fmt" pos="5:4" access="rw" rst="0x0">
            <comment>00:rgb565  01:rgb888   10:xrgb8888   11:rgbx8888.
            </comment>
        </bits>
        <bits name="r_rgb_order" pos="3" access="rw" rst="0x0">
            <comment>0:RGB 1:BGR.
            </comment>
        </bits>
        <bits name="r_frame2_enable" pos="2" access="rw" rst="0x0">
            <comment>Frame2 use.
            </comment>
        </bits>
        <bits name="r_frame1_enable" pos="1" access="rw" rst="0x0">
            <comment>Frame1 use.
            </comment>
        </bits>
        <bits name="r_rgb_enable" pos="0" access="rw" rst="0x0">
            <comment>Rgb panel enable.
            </comment>
        </bits>
    </reg>
    <reg name="DPI_FRAM0_ADDR" protect="rw">
    </reg>
    <reg name="DPI_FRAM0_CON" protect="rw">
        <bits name="r_frame0_line_step" pos="28:16" access="rw" rst="0x0">
            <comment>Frame0 line step,in byte.
            </comment>
        </bits>
        <bits name="r_frame0_valid" pos="0" access="rw" rst="0x0">
            <comment>Frame 0 valid.
            </comment>
        </bits>
    </reg>

    <reg name="DPI_FRAM1_ADDR" protect="rw">
    </reg>
    <reg name="DPI_FRAM1_CON" protect="rw">
        <bits name="r_frame1_line_step" pos="28:16" access="rw" rst="0x0">
            <comment>Frame1 line step,in byte.
            </comment>
        </bits>
        <bits name="r_frame1_valid" pos="0" access="rw" rst="0x0">
            <comment>Frame 1 valid.
            </comment>
        </bits>
    </reg>

    <reg name="DPI_FRAM2_ADDR" protect="rw">
    </reg>
    <reg name="DPI_FRAM2_CON" protect="rw">
        <bits name="r_frame2_line_step" pos="28:16" access="rw" rst="0x0">
            <comment>Frame2 line step,in byte.
            </comment>
        </bits>
        <bits name="r_frame2_valid" pos="0" access="rw" rst="0x0">
            <comment>Frame 2 valid.
            </comment>
        </bits>
    </reg>

    <reg name="DPI_SIZE" protect="rw">
        <bits name="r_v_size" pos="26:16" access="rw" rst="0x0">
            <comment>Vertical pix num.
            </comment>
        </bits>
        <bits name="r_h_size" pos="10:0" access="rw" rst="0x0">
            <comment>Horizontal pix num.
            </comment>
        </bits>
    </reg>
    <reg name="DPI_FIFO_CTRL" protect="rw">
        <bits name="r_data_fifo_lowthres" pos="25:16" access="rw" rst="0x0">
            <comment>Data fifo threshold when req axi.
            </comment>
        </bits>
        <bits name="r_fifo_rst_auto" pos="1" access="rw" rst="0x0">
            <comment>Dpi fifo auto reset enable when occur overflow .
            </comment>
        </bits>
        <bits name="r_fifo_rst" pos="0" access="rw" rst="0x0">
            <comment>Dpi fifo reset.
            </comment>
        </bits>
    </reg>
    <reg name="DPI_THROT" protect="rw">
        <bits name="r_throttle_period" pos="25:16" access="rw" rst="0x0">
            <comment>Throttle period.
            </comment>
        </bits>
        <bits name="r_throttle_en" pos="0" access="rw" rst="0x0">
            <comment>Dpi dma throttle enable.
            </comment>
        </bits>
    </reg>
    <reg name="DPI_POL" protect="rw">
        <bits name="r_de_pol" pos="11" access="rw" rst="0x0">
            <comment>Data enable pol.
            </comment>
        </bits>
        <bits name="r_vsync_pol" pos="10" access="rw" rst="0x0">
            <comment>Vsync pol.
            </comment>
        </bits>
        <bits name="r_hsync_pol" pos="9" access="rw" rst="0x0">
            <comment>Hsync pol.
            </comment>
        </bits>
        <bits name="r_dot_clk_pol" pos="8" access="rw" rst="0x0">
            <comment>Dot clock pol.
            </comment>
        </bits>
        <bits name="r_dot_clk_div" pos="7:0" access="rw" rst="0x0">
            <comment>Dot clock divider.
            </comment>
        </bits>
    </reg>
    <reg name="DPI_TIME0" protect="rw">
        <bits name="r_front_porch_start_vsync_timer" pos="26:16" access="rw" rst="0x0">
            <comment>vsync back porch + vsync display period.
            </comment>
        </bits>
        <bits name="r_back_porch_end_vsync_timer" pos="10:0" access="rw" rst="0x0">
            <comment>vsync back porch num.
            </comment>
        </bits>
    </reg>
    <reg name="DPI_TIME1" protect="rw">
        <bits name="r_vsync_include_hsync_th_low" pos="26:16" access="rw" rst="0x0">
            <comment>vsync low pulse width.
            </comment>
        </bits>
        <bits name="r_vsync_include_hsync_th_high" pos="10:0" access="rw" rst="0x0">
            <comment>vsync period - 1.
            </comment>
        </bits>
    </reg>
    <reg name="DPI_TIME2" protect="rw">
        <bits name="r_hsync_include_dotclk_th_low" pos="26:16" access="rw" rst="0x0">
            <comment>hsync low pulse width.
            </comment>
        </bits>
        <bits name="r_hsync_include_dotclk_th_high" pos="10:0" access="rw" rst="0x0">
            <comment>hsync period -1.
            </comment>
        </bits>
    </reg>
    <reg name="DPI_TIME3" protect="rw">
        <bits name="r_rgb_data_enable_end_timer" pos="26:16" access="rw" rst="0x0">
            <comment>data enable end.
            </comment>
        </bits>
        <bits name="r_rgb_data_enable_start_timer" pos="10:0" access="rw" rst="0x0">
            <comment>data enable start.
            </comment>
        </bits>
    </reg>
    <reg name="DPI_STATUS" protect="ro">
        <bits name="current_frame" pos="5:4" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="frame_runing" pos="3" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Frame2_over" pos="2" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="frame1_over" pos="1" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Frame0_over" pos="0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="g_2D_CTRL" protect="rw">
        <bits name="r_draw_mode" pos="4:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="r_draw_enable" pos="2" access="rw" rst="0x0">
            <comment>Draw enable.
            </comment>
        </bits>
        <bits name="r_rop4_enable" pos="1" access="rw" rst="0x0">
            <comment>Rop4 enable.
            </comment>
        </bits>
        <bits name="r_rop3_enable" pos="0" access="rw" rst="0x0">
            <comment>Rop3 enable.
            </comment>
        </bits>
    </reg>
    <reg name="g_2D_ROP_CODE" protect="rw">
        <bits name="r_rop3_code0" pos="15:8" access="rw" rst="0x0">
            <comment>r_rop3_code0.
            </comment>
        </bits>
        <bits name="r_rop3_code1" pos="7:0" access="rw" rst="0x0">
            <comment>r_rop3_code1.
            </comment>
        </bits>
    </reg>
    <reg name="g_2D_DRAW_COLOR" protect="rw">
        <bits name="r_draw_color.A" pos="31:24" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="r_draw_color.R" pos="23:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="r_draw_color.G" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="r_draw_color.B" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="g_2D_DRAW_P0" protect="rw">
    </reg>
    <reg name="g_2D_DRAW_P1" protect="rw">
    </reg>
    <reg name="g_2D_DRAW_P2" protect="rw">
    </reg>
    <reg name="OUTCOLOR_CFG" protect="rw">
        <bits name="r_alpha_out_fix" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="r_alpha_out_fixen" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="GD_OL_INPUT_FMT_3" protect="rw">
    </reg>
    <reg name="GD_OL_TL_PPOS_3" protect="rw">
    </reg>
    <reg name="GD_OL_BR_PPOS_3" protect="rw">
    </reg>
    <reg name="GD_OL_BLEND_OPT_3" protect="rw">
    </reg>
    <reg name="GD_OL_RGB_SRC_3" protect="rw">
    </reg>
    <reg name="DITHER_CTRL" protect="rw">
        <bits name="r_dither_mode" pos="1" access="rw" rst="0x0">
            <comment>0:rgb565  1:rgb666
            </comment>
        </bits>
        <bits name="r_dither_en" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="DITHER_MATRIX0_0" protect="rw">
    </reg>
    <reg name="DITHER_MATRIX0_1" protect="rw">
    </reg>
    <reg name="DITHER_MATRIX1" protect="rw">
    </reg>
    <reg name="TECON" protect="rw">
        <bits name="te_count2" pos="27:16" access="rw" rst="0x0">
            <comment>Count value to detect vsync pulse
            </comment>
        </bits>
        <bits name="te_mode" pos="2" access="rw" rst="0x0">
            <comment>0:vsync te only 1:vsync and hsync te
            </comment>
        </bits>
        <bits name="te_edge_sel" pos="1" access="rw" rst="0x0">
            <comment>Pol select
            </comment>
        </bits>
        <bits name="te_en" pos="0" access="rw" rst="0x0">
            <comment>Te enable.
            </comment>
        </bits>
    </reg>
    <reg name="TECON2" protect="rw">
    </reg>

<hole size="(256-81-1)*32"/>

    <reg name="dsi_00h" protect="rw">
          <bits name="XX" pos="31:2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dsipll_pu" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="pu_dsi" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
   <reg name="dsi_04h" protect="rw">
          <bits name="XX" pos="31:2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="o_dsi_lprx_lpcd_enable" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dsi_enable_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="dsi_08h" protect="rw">
          <bits name="XX" pos="31:2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dsi_config_reg" pos="1:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="dsi_0ch" protect="rw">
           <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="pixel_num_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="dsi_10h" protect="rw">
          <bits name="XX" pos="31:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="pixel_type_reg" pos="2:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="dsi_14h" protect="rw">
          <bits name="XX" pos="31:2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dsi_tx_mode_reg" pos="1:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="dsi_18h" protect="rw">
          <bits name="XX" pos="31:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="bllp_enable_per_l_reg" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="vci_reg" pos="1:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_1ch" protect="rw">
            <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="line_byte_num_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="dsi_20h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="hsa_num_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="dsi_24h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="hbp_num_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="dsi_28h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="hfp_num_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="dsi_2ch" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="rgb_num_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="dsi_30h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="vsa_line_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="dsi_34h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="vbp_line_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="dsi_38h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="vfp_line_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="dsi_3ch" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="vat_line_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="dsi_40h" protect="rw">
          <bits name="XX" pos="31:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits><bits name="dsi_cmd_num_reg" pos="4:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="dsi_44h" protect="rw">
          <bits name="XX" pos="31:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits><bits name="dsi_cmd_merge_en_reg" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dsi_cmd_2_en_reg" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dsi_cmd_1_en_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="dsi_48h" protect="rw">
          <bits name="XX" pos="31:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dphy_tst_enable_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>

<hole size="5*32"/>

   <reg name="dsi_60h" protect="rw">
          <bits name="XX" pos="31:4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="esc_pause_num_reg" pos="3:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_64h" protect="rw">
            <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="phy_lp_tx_rate_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_68h" protect="rw">
          <bits name="XX" pos="31:6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits><bits name="mipi_dsi_sel_reg" pos="5:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>

<hole size="37*32"/>

   <reg name="dsi_100h" protect="rw">
          <bits name="XX" pos="31:2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="hs_clk_always_reg" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="hs_mode_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_104h" protect="rw">
          <bits name="XX" pos="31:4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="last_bit_hold_invt_reg" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="last_bit_hold_swap_reg" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="sync_word_swap_reg" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="data_swap_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="dsi_108h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="t_lp_00_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_10ch" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="t_lp_01_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_110h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="t_lp_10_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_114h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
          <bits name="t_lp_11_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_118h" protect="rw">

          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="t_zero_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_11ch" protect="rw">

          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="t_sync_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_120h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="t_eot_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_124h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="clk_lp_00_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_128h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="clk_lp_01_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_12ch" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="clk_lp_11_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_130h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="clk_eot_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_134h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="t_bta_lpx_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_138h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="t_bta_cd_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_13ch" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="t_bta_00_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_140h" protect="rw">
          <bits name="XX" pos="31:16" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="t_bta_timeout_reg" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_144h" protect="rw">
          <bits name="XX" pos="31:11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="hz_bit_dr" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="hz_bit_reg" pos="9:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="vreg_bit" pos="4:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="phase_selg" pos="2:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="dsi_148h" protect="rw">
          <bits name="XX" pos="31:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="cd_bit" pos="4:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="rx_bit" pos="2:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="ulps_enable" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>

<hole size="13*32"/>

  <reg name="dsi_180h" protect="rw">
          <bits name="dsi_cmd_1_0_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_184h" protect="rw">
          <bits name="dsi_cmd_1_1_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_188h" protect="rw">
          <bits name="dsi_cmd_1_2_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_18ch" protect="rw">
          <bits name="dsi_cmd_1_3_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_190h" protect="rw">
          <bits name="dsi_cmd_1_4_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_194h" protect="rw">
          <bits name="dsi_cmd_1_5_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_198h" protect="rw">
          <bits name="dsi_cmd_1_6_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_19ch" protect="rw">
          <bits name="dsi_cmd_1_7_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1a0h" protect="rw">
          <bits name="dsi_cmd_1_8_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1a4h" protect="rw">
          <bits name="dsi_cmd_1_9_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1a8h" protect="rw">
          <bits name="dsi_cmd_1_a_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1ach" protect="rw">
          <bits name="dsi_cmd_1_b_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1b0h" protect="rw">
          <bits name="dsi_cmd_1_c_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1b4h" protect="rw">
          <bits name="dsi_cmd_1_d_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1b8h" protect="rw">
          <bits name="dsi_cmd_1_e_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1bch" protect="rw">
          <bits name="dsi_cmd_2_f_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1c0h" protect="rw">
          <bits name="dsi_cmd_2_0_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1c4h" protect="rw">
          <bits name="dsi_cmd_2_1_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1c8h" protect="rw">
          <bits name="dsi_cmd_2_2_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1cch" protect="rw">
          <bits name="dsi_cmd_2_3_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1d0h" protect="rw">
          <bits name="dsi_cmd_2_4_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1d4h" protect="rw">
          <bits name="dsi_cmd_2_5_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1d8h" protect="rw">
          <bits name="dsi_cmd_2_6_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1dch" protect="rw">
          <bits name="dsi_cmd_2_7_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1e0h" protect="rw">
          <bits name="dsi_cmd_2_8_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1e4h" protect="rw">
          <bits name="dsi_cmd_2_9_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1e8h" protect="rw">
          <bits name="dsi_cmd_2_a_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1ech" protect="rw">
          <bits name="dsi_cmd_2_b_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1f0h" protect="rw">
          <bits name="dsi_cmd_2_c_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1f4h" protect="rw">
          <bits name="dsi_cmd_2_d_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1f8h" protect="rw">
          <bits name="dsi_cmd_2_e_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>
  <reg name="dsi_1fch" protect="rw">
          <bits name="dsi_cmd_2_f_reg" pos="31:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
  </reg>

</module>




<module name="gouda_sram" category="Ap">
  <var name="GD_NB_WORKBUF_WORDS"  value="GD_MAX_OUT_WIDTH*2" />
  <var name="GD_NB_LCD_CMD_WORDS"  value="32" />
  <var name="GD_SRAM_SIZE"  value="(GD_NB_WORKBUF_WORDS+GD_NB_LCD_CMD_WORDS)*2" />
  <var name="GD_SRAM_ADDR_WIDTH"  value="10" />

    <memory name="sram_array" size="GD_SRAM_SIZE">
        <comment>Gouda internal Sram space
        </comment>
    </memory>
</module>

</archive>

<archive relative='camera.xml' >

<var name="FIFORAM_SIZE" value="80"/>
<module name="camera" category="Ap">

    <reg name="CTRL" protect="rw">
        <bits access="rw" name="Enable" pos="0" rst="0">
            <options>
                <default/>
                <option name="ENABLE"  value="1"/>
                <option name="DISABLE" value="0"/>
            </options>
            <comment> Enable camera controller,high active.
            </comment>
        </bits>
        <bits access="rw" name="DctEnable" pos="1" rst="0">
            <options>
                <default/>
                <option name="ENABLE"  value="1"/>
                <option name="DISABLE" value="0"/>
            </options>
            <comment> Enable Dct module, high active.
            </comment>
        </bits>
        <bits access="rw" name="Buf_Enable" pos="2" rst="0">
            <options>
                <default/>
                <option name="ENABLE"  value="1"/>
                <option name="DISABLE" value="0"/>
            </options>
            <comment> Enable pre-cal-average two neighbor pix, high active.
            </comment>
        </bits>
        <bits access="rw" name="DataFormat" pos="5:4" rst="0">
            <options>
                <default/>
                <option name="RGB565"  value="0"/>
                <option name="YUV422"  value="1"/>
                <option name="JPEG"    value="2"/>
                <option name="RESERVE" value="3"/>
            </options>
            <comment> "0" = RGB565.
                <br/> "1" = YUV422.
                <br/> "2" = Compressed Data.
                <br/> "3" = Reserved.
            </comment>
        </bits>
        <bits access="rw" name="RESET_Pol" pos="8" rst="1">
            <options>
                <default/>
                <option name="INVERT" value="1"/>
                <option name="NORMAL" value="0"/>
            </options>
            <comment> '0' = keep output camera reset polarity.
                <br/> '1' = invert output camera reset polarity.
            </comment>
        </bits>
        <bits access="rw" name="PWDN_Pol" pos="9" rst="0">
            <options>
                <default/>
                <option name="INVERT" value="1"/>
                <option name="NORMAL" value="0"/>
            </options>
            <comment> '0' = keep output camera power down polarity.
                <br/> '1' = invert output camera power down polarity.
            </comment>
        </bits>
        <bits access="rw" name="VSYNC_Pol" pos="10" rst="0">
            <options>
                <default/>
                <option name="INVERT" value="1"/>
                <option name="NORMAL" value="0"/>
            </options>
            <comment> '0' = keep input VSYNC polarity.
                <br/> '1' = invert input VSYNC polarity.
            </comment>
        </bits>
        <bits access="rw" name="HREF_Pol" pos="11" rst="0">
            <options>
                <default/>
                <option name="INVERT" value="1"/>
                <option name="NORMAL" value="0"/>
            </options>
            <comment> '0' = keep input HREF polarity so data is sampled when HREF high.
                <br/> '1' = invert input HREF polarity so data is sampled when HREF low.
            </comment>
        </bits>
        <bits access="rw" name="VSYNC_Drop" pos="14" rst="1">
            <options>
                <default/>
                <option name="DROP"   value="1"/>
                <option name="NORMAL" value="0"/>
            </options>
            <comment> '0' = VSYNC irq always exists when Frame decimation is enabled.
                <br/> '1' = VSYNC irq will drop when Frame data are dropped in decipation.
            </comment>
        </bits>
        <bits access="rw" name="DecimFrm" pos="17:16" rst="0">
            <options>
                <default/>
                <option name="ORIGINAL" value="0"/>
                <option name="DIV_2"    value="1"/>
                <option name="DIV_3"    value="2"/>
                <option name="DIV_4"    value="3"/>
            </options>
            <comment> "0"= All frame data will be sent.
                <br/> "1"= only one frame out of two (1/2) will be sent.
                <br/> "2"= only one frame out of three (1/3) will be sent.
                <br/> "3"= only one frame out of four (1/4) will be sent.
            </comment>
        </bits>
        <bits access="rw" name="DecimCol" pos="19:18" rst="0">
            <options>
                <default/>
                <option name="ORIGINAL" value="0"/>
                <option name="DIV_2"    value="1"/>
                <option name="DIV_3"    value="2"/>
                <option name="DIV_4"    value="3"/>
            </options>
            <comment> "0"= Pixel Decimation Disabled.
                <br/> "1"= Pixel Decimation 1/2.
                <br/> "2"= Pixel Decimation 1/3.
                <br/> "3"= Pixel Decimation 1/4.
            </comment>
        </bits>
        <bits access="rw" name="DecimRow" pos="21:20" rst="0">
            <options>
                <default/>
                <option name="ORIGINAL" value="0"/>
                <option name="DIV_2"    value="1"/>
                <option name="DIV_3"    value="2"/>
                <option name="DIV_4"    value="3"/>
            </options>
            <comment> "0"= line Decimation Disabled.
                <br/> "1"= line Decimation 1/2.
                <br/> "2"= line Decimation 1/3.
                <br/> "3"= line Decimation 1/4.
            </comment>
        </bits>
        <bits name="Reorder"  pos="26:24" access="rw" rst="0">
            <comment>Controls the Re-ordering of the FIFO data.
                <br/> In following table, for input data, right comes before left. So YUYV means V comes first.
                <br/> for output data, right data is the LSB. So YUYV means V is stored in low 8-bit (byte0) of 32-bit word.
                <br/>
                <br/> If Bit 26 is '1', byte2 and byte0 is Y.
                <br/> If Bit 25 is '1', both byte2/byte3 and byte1/byte0 interchange.
                <br/> If Bit 24 is '1', byte U and V should interchange. (UV bytes can be decided using bit 26).
                <br/>
                <br/> input YUYV, output YUYV: "000"
                <br/> input YVYU, output YUYV: "001"
                <br/> input UYVY, output YUYV: "110"
                <br/> input VYUY, output YUYV: "111"
                <br/>
                <br/> input YUYV, output UYVY: "010"
                <br/> input YVYU, output UYVY: "011"
                <br/> input UYVY, output UYVY: "100"
                <br/> input VYUY, output UYVY: "101"
                <br/>
                <br/> input YUYV, output YVYU: "001"
                <br/> input YVYU, output YVYU: "000"
                <br/> input UYVY, output YVYU: "111"
                <br/> input VYUY, output YVYU: "110"
                <br/>
                <br/> input YUYV, output VYUY: "011"
                <br/> input YVYU, output VYUY: "010"
                <br/> input UYVY, output VYUY: "101"
                <br/> input VYUY, output VYUY: "100"
                <br/>
                <br/> Decimation will reorder data flow also. Input UYVY becomes YUVY after decimation.
                      This reorder is corrected using Bit 26 infomation.
            </comment>
        </bits>
        <bits access="rw" name="CropEn" pos="28" rst="0">
            <options>
                <default/>
                <option name="ENABLE"  value="1"/>
                <option name="DISABLE" value="0"/>
            </options>
            <comment> "0"= Cropping Disabled.
                <br/> "1"= Cropping Enabled.
                <br/> Note: this bit should set to '0' when bit field "DataFormat" is "10" (compressed data)
            </comment>
        </bits>
        <bits access="rw" name="Bist Mode" pos="30" rst="0">
            <options>
                <default/>
                <option name="BIST"   value="1"/>
                <option name="NORMAL" value="0"/>
            </options>
            <comment>
                In Bist Mode, FIFO RAM are read and write by its address, FIFO mode is disabled.
            </comment>
        </bits>
        <bits access="rw" name="TEST" pos="31" rst="0">
            <options>
                <default/>
                <option name="TEST"  value="1"/>
                <option name="NORMAL" value="0"/>
            </options>
            <comment>
                Debug only. A RGB565 test card is sent to system bus instead of real data from sensor.
            </comment>
        </bits>
     </reg>
    <reg protect="ro" name="STATUS">
        <bits access="ro" name="OVFL" pos="0" rst="0">
            <comment> '1' = FIFO over-write IRQ status.
                <br/> Write to corresponding bit in IRQ CLEAR register will clear this bit.
            </comment>
        </bits>
        <bits access="ro" name="VSYNC_R" pos="1" rst="0">
            <comment> '1' = VSYNC rising edge IRQ status
                <br/> Write to corresponding bit in IRQ CLEAR register will clear this bit.
            </comment>
        </bits>
        <bits access="ro" name="VSYNC_F" pos="2" rst="0">
            <comment> '1' = VSYNC falling edge IRQ status
                <br/> Write to corresponding bit in IRQ CLEAR register will clear this bit.
            </comment>
        </bits>
        <bits access="ro" name="DMA DONE" pos="3" rst="0">
            <comment> '1' = DMA Done IRQ status
                <br/> Write to corresponding bit in IRQ CLEAR register will clear this bit.
            </comment>
        </bits>
        <bits access="ro" name="FIFO EMPTY" pos="4" rst="1">
            <comment> '1' = FIFO Empty status, not clear-able.
            </comment>
        </bits>
        <bits access="ro" name="SPI OVFL" pos="5" rst="0">
            <comment> '1' = SPI CAM Overflow
            </comment>
        </bits>
    </reg>
     <reg name="DATA"  protect="--">
         <bits name="RX_DATA" pos="31:0" access="r">
           <comment>Read in the receive FIFO
           </comment>
         </bits>
     </reg>

    <reg protect="wr" name="IRQ MASK">
        <bits access="wr" name="OVFL" pos="0" rst="0">
            <comment> '1' = FIFO over-write enable
            </comment>
        </bits>
        <bits access="wr" name="VSYNC_R" pos="1" rst="0">
            <comment> '1' = VSYNC rising edge enable
            </comment>
        </bits>
        <bits access="wr" name="VSYNC_F" pos="2" rst="0">
            <comment> '1' = VSYNC falling edge enable
            </comment>
        </bits>
        <bits access="wr" name="DMA DONE" pos="3" rst="0">
            <comment> '1' = DMA Done enable
            </comment>
        </bits>

    </reg>

    <reg protect="rw" name="IRQ CLEAR">
        <bits access="wo" name="OVFL" pos="0" rst="0">
            <comment> Write '1' to clear FIFO over-write interrupt
            </comment>
        </bits>
        <bits access="wo" name="VSYNC_R" pos="1" rst="0">
            <comment> Write '1' to clear VSYNC rising edge interrupt
            </comment>
        </bits>
        <bits access="wo" name="VSYNC_F" pos="2" rst="0">
            <comment> Write '1' to clear VSYNC falling edge interrupt
            </comment>
        </bits>
        <bits access="wo" name="DMA DONE" pos="3" rst="0">
            <comment> Write '1' to clear DMA Done interrupt
            </comment>
        </bits>
    </reg>

    <reg protect="ro" name="IRQ CAUSE">
        <bits access="ro" name="OVFL" pos="0" rst="0">
            <comment> '1' = FIFO over-write cause
            </comment>
        </bits>
        <bits access="ro" name="VSYNC_R" pos="1" rst="0">
            <comment> '1' = VSYNC rising edge cause
            </comment>
        </bits>
        <bits access="ro" name="VSYNC_F" pos="2" rst="0">
            <comment> '1' = VSYNC falling edge cause
            </comment>
        </bits>
        <bits access="ro" name="DMA DONE" pos="3" rst="0">
            <comment> '1' = DMA Done cause
            </comment>
        </bits>
    </reg>

    <reg protect="rw" name="CMD SET">
        <bits name="PWDN" pos="0" access="rs" rst="1">
            <comment> Power down pin of CMOS sensor .
            </comment>
        </bits>
        <bits name="RESET" pos="4" access="rs" rst="1">
            <comment> Reset pin of CMOS sensor.
                    <br/>Active Low.
            </comment>
        </bits>
       <bits name="FIFO RESET" pos="8" access="s" rst="0">
          <comment>For the software to clear FIFO. This bit is auto-reset to 0.
          </comment>
       </bits>
    </reg>

    <reg protect="rw" name="CMD CLR">
        <bits name="PWDN" pos="0" access="rc" rst="1">
            <comment> Power down pin of CMOS sensor .
            </comment>
        </bits>
        <bits name="RESET" pos="4" access="rc" rst="1">
            <comment> Reset pin of CMOS sensor.
            </comment>
        </bits>
    </reg>

    <reg protect="rw" name="DSTWINCOL">
        <bits name="DstWinColStart" pos="11:0" access="wr" rst="0">
            <comment> start pixel of cropped window.
            </comment>
        </bits>
        <bits name="DstWinColEnd" pos="27:16" access="wr" rst="0">
            <comment> end pixel of cropped window.
            </comment>
        </bits>
    </reg>

    <reg protect="rw" name="DSTWINROW">
        <bits name="DstWinRowStart" pos="11:0" access="wr" rst="0">
            <comment> start line of cropped window.
            </comment>
        </bits>
        <bits name="DstWinRowEnd" pos="27:16" access="wr" rst="0">
            <comment> end line of cropped window.
            </comment>
        </bits>
    </reg>

    <reg name="Cfg_Clk_Camera_Out" protect="rw">
        <bits name="Clk_Camera_Out_En" pos="0" access="rw" rst="0">
            <comment>Clk camera out enable. </comment>
           <options>
               <option name="disable" value="0"></option>
               <option name="enable" value="1"></option>
           </options>
        </bits>
        <bits name="Clk_Camera_Div_Src_Sel" pos="4" access="rw" rst="0">
            <comment>Selects from which clock the Clk camera is generated.</comment>
           <options>
               <option name="156 MHz" value="0"></option>
               <option name=" 26 MHz" value="1"></option>
           </options>
        </bits>
        <bits name="Clk_Camera_Out_Div" pos="11:8" access="rw" rst="15">
            <comment>Clock camera out divider. clock frequency = selected clock source frequency / (value + 2). See bit 4 CLK_CAMERA_OUT_SRC_SEL for source selection.
            </comment>
            <options>
                <default/><mask/><shift/>
            </options>
        </bits>
        <bits name="Clk_Camera_Out_Src_Sel" pos="13:12" access="rw" rst="0">
            <comment>Selection between the output of the divider, the 32K clock, or the 26M clock.</comment>
            <options>
                <option name="From divider" value="0"></option>
                <option name="From 32K" value="1"></option>
                <option name="From 26M" value="2"></option>
            </options>
        </bits>
        <bits access="rw" name="PIXCLK_Pol" pos="28" rst="0">
            <options>
                <default/>
                <option name="INVERT" value="1"/>
                <option name="NORMAL" value="0"/>
            </options>
            <comment> '0' = keep pix clk polarity.
                <br/> '1' = invert pix clk polarity.
            </comment>
        </bits>
    </reg>

    <reg protect="rw" name="SCALE_CONFIG">
        <bits name="SCALE_EN" pos="0" access="wr" rst="0">
            <options>
                <default/>
                <option name="ENABLE"  value="1"/>
                <option name="DISABLE" value="0"/>
            </options>
            <comment> Enable camera scaler,high active.
            </comment>
        </bits>
        <bits name="SCALE_COL" pos="9:8" access="wr" rst="0">
            <options>
                <default/>
                <option name="ORIGINAL"  value="0"/>
                <option name="DIV_2"     value="1"/>
                <option name="NOUSE"     value="2"/>
                <option name="DIV_4"     value="3"/>
            </options>
            <comment> scaler col.
            </comment>
        </bits>
        <bits name="SCALE_ROW" pos="17:16" access="wr" rst="0">
            <options>
                <default/>
                <option name="ORIGINAL"  value="0"/>
                <option name="DIV_2"     value="1"/>
                <option name="NOUSE"     value="2"/>
                <option name="DIV_4"     value="3"/>
            </options>
            <comment> scaler row.
            </comment>
        </bits>
    </reg>

    <reg protect="rw" name="SPI_CAMERA_REG0">
        <bits access="wr" name="SPI_CAMERA_REGISTER0" pos="31:0" rst="0">
            <comment> spi camera config resiger0
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="SPI_CAMERA_REG1">
        <bits access="wr" name="SPI_CAMERA_REGISTER1" pos="31:0" rst="0">
            <comment> spi camera config resiger1
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="SPI_CAMERA_REG2">
        <bits access="wr" name="SPI_CAMERA_REGISTER2" pos="31:0" rst="0">
            <comment> spi camera config resiger2
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="SPI_CAMERA_REG3">
        <bits access="wr" name="SPI_CAMERA_REGISTER3" pos="31:0" rst="0">
            <comment> spi camera config resiger3
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="SPI_CAMERA_REG4">
        <bits access="wr" name="SPI_CAMERA_REGISTER4" pos="31:0" rst="0">
            <comment> spi camera config resiger4
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="SPI_CAMERA_REG5">
        <bits access="wr" name="SPI_CAMERA_REGISTER5" pos="31:0" rst="0">
            <comment> spi camera config resiger5
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="SPI_CAMERA_REG6">
        <bits access="wr" name="SPI_CAMERA_REGISTER6" pos="31:0" rst="0">
            <comment> spi camera config resiger6
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="SPI_CAMERA_OBS0">
        <bits access="wr" name="SPI_CAMERA_OBS_REGISTER0" pos="31:0" rst="0">
            <comment> spi camera obs resiger0
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="SPI_CAMERA_OBS1">
        <bits access="wr" name="SPI_CAMERA_OBS_REGISTER1" pos="31:0" rst="0">
            <comment> spi camera obs resiger1
            </comment>
        </bits>
    </reg>


    <reg name="csi_config_reg0" protect="rw">
        <bits name="csi_module_enable" pos="31" access="rw" rst="0x1">
            <comment>CSI module function enable bit, also controls the analog pd logic. If 1'b1, module enable.
            </comment>
        </bits>
        <bits name="data_lane_choose_bit" pos="30" access="rw" rst="0x0">
            <comment>Data lane choose bit. If 1'b0, use data1 lane for single lane input; If 1'b1, use data2 lane.
            </comment>
        </bits>
        <bits name="ecc_bypass" pos="29" access="rw" rst="0x1">
            <comment>If 1'b1, bypass the ecc error check function.
            </comment>
        </bits>
        <bits name="line_packet_enable" pos="28" access="rw" rst="0x0">
            <comment>If 1'b1, allow line packet transation.
            </comment>
        </bits>
        <bits name="hs_sync_find_en" pos="27" access="rw" rst="0x0">
            <comment>Hs sync method choose bit.
            </comment>
        </bits>
        <bits name="rdata_bit_inv_en" pos="26" access="rw" rst="0x0">
            <comment>If 1'b1, fifo rdata bit order revserse.
            </comment>
        </bits>
        <bits name="sync_bypass" pos="25" access="rw" rst="0x0">
            <comment>If 1'b1, asyncfifo r/w sync bypass.
            </comment>
        </bits>
        <bits name="trail_data_wrong_choose_bit" pos="24" access="rw" rst="0x0">
            <comment>If 1'b1, trail data check bit postion change.
            </comment>
        </bits>
        <bits name="clk_lp_inv" pos="23" access="rw" rst="0x0">
            <comment>Data lane low power mode sample clk edge choose bit.
            </comment>
        </bits>
        <bits name="data_lp_inv" pos="22" access="rw" rst="0x0">
            <comment>Data lane low power mode outp/outn exchange control bit.
            </comment>
        </bits>
        <bits name="data_lp_in_choose_bit[1:0]" pos="21:20" access="rw" rst="0x0">
            <comment>Low power data choose bit.
                     bit[1]=1? data_lp_psyn : data_lp_p;
                     bit[0]=1? data_lp_nsyn : data_lp_n;
            </comment>
        </bits>
        <bits name="vc_id_set[1:0]" pos="19:18" access="rw" rst="0x0">
            <comment>Virtual channel ID set bit.
            </comment>
        </bits>
        <bits name="cur_frame_line_num[9:0]" pos="17:8" access="rw" rst="0x240">
            <comment>Num of useful lines per frame.
            </comment>
        </bits>
        <bits name="num_d_term_en[7:0]" pos="7:0" access="rw" rst="0x16">
            <comment>Num of sys clks before eable the HS line termination, starting from when Dn changing to 1'b0.
            </comment>
        </bits>
    </reg>
    <reg name="csi_config_reg1" protect="rw">
        <bits name="lp_cmd_clr" pos="31" access="rw" rst="0x0">
            <comment>Low power mode cmd clear flag. Using when command byte having been taken by system. If 1'b1, LP command will be reset to 8'b0.
            </comment>
        </bits>
        <bits name="lp_data_clr" pos="30" access="rw" rst="0x0">
            <comment>Low power mode transmission data  clear flag. Using when lp data having been taken by system. If 1'b1, LP data will be reset to all zero.
            </comment>
        </bits>
        <bits name="lp_cmd_interrupt_clr" pos="29" access="rw" rst="0x0">
            <comment>Lp command interrupt clear.
            </comment>
        </bits>
        <bits name="lp_data_interrupt_clr" pos="28" access="rw" rst="0x0">
            <comment>Lp data interrupt clear.
            </comment>
        </bits>
        <bits name="data1_terminal_enable_dr" pos="27" access="rw" rst="0x0">
            <comment>Data lane1 terminal enable direct reg. If 1'b1, data1_terminal_enable using register value.
            </comment>
        </bits>
        <bits name="data1_terminal_enable_reg" pos="26" access="rw" rst="0x0">
            <comment>data1_terminal_enable setting bit.
            </comment>
        </bits>
        <bits name="data2_terminal_enable_reg" pos="25" access="rw" rst="0x0">
            <comment>Data2_terminal_enable setting bit.
            </comment>
        </bits>
        <bits name="hs_data1_enable_dr" pos="24" access="rw" rst="0x0">
            <comment>Data lane1 hs data enable direct reg. If 1'b1, hs_data1_enable using register value.
            </comment>
        </bits>
        <bits name="hs_data1_enable_choose_bit" pos="23" access="rw" rst="0x0">
            <comment>If 1'b1, hs_data1_enable using the data1_terminal_enable value, else, data1 enable will be set to 1'b1 earlier than terminal enable when starting HS transmission.
            </comment>
        </bits>
        <bits name="hs_data1_enable_reg" pos="22" access="rw" rst="0x0">
            <comment>hs_data1_enable setting bit.
            </comment>
        </bits>
        <bits name="hs_data2_enable_reg" pos="21" access="rw" rst="0x0">
            <comment>hs_data2_enable setting bit.
            </comment>
        </bits>
        <bits name="vsync_csi_inv_bit" pos="20" access="rw" rst="0x0">
            <comment>Vsync polarity choose bit. If 1'b0, high enable. If 1'b1, low enable.
            </comment>
        </bits>
        <bits name="hsync_csi_inv_bit" pos="19" access="rw" rst="0x0">
            <comment>Hsync polarity choose bit. If 1'b0, high enable. If 1'b1, low enable.
            </comment>
        </bits>
        <bits name="den_csi_inv_bit" pos="18" access="rw" rst="0x0">
            <comment>Data enable polarity choose bit. If 1'b0, high enable. If 1'b1, low enable.
            </comment>
        </bits>
        <bits name="hs_enable_mask_en" pos="17" access="rw" rst="0x0">
            <comment>If 1'b1, the hs data will continue be be read out from the fifo when phy HS trans stop, designed for the case when sys clk freq lower than CSI HS byte clk.
            </comment>
        </bits>
        <bits name="rinc_mask_en" pos="16" access="rw" rst="0x0">
            <comment>Rinc 8809 old mode: If 1'b1, rinc depends only on hs_rdata_stop_flag; If 1'b0, rinc also depends on sync/useful/trail phy data state. Rinc signal mask enable bit.
            </comment>
        </bits>
        <bits name="rclr_mask_en" pos="15" access="rw" rst="0x0">
            <comment>Rclr signal mask enable bit. If 1'b1, fifo rclr only when lp_01; If 1'b0, fifo rclr when phy data state idle or stop.
            </comment>
        </bits>
        <bits name="clk_lp_ck_inv" pos="14" access="rw" rst="0x0">
            <comment>ck_lp_outp, ck_lp_outn signal exchange bit.
            </comment>
        </bits>
        <bits name="data_clk_lp_posedge_choose[2:0]" pos="13:11" access="rw" rst="0x0">
            <comment>Data lane lp clk delay choose bit.
            </comment>
        </bits>
        <bits name="lp_data_length_choose_bit[2:0]" pos="10:8" access="rw" rst="0x0">
            <comment>Low power transmission data length choose bit: 3'b000: 8 bits; 3'b001: 16 bits; 3'b010: 24 bits;
                     3'b011: 32 bits; 3'b100: 40 bits; 3'b101: 48 bits; 3'b110: 56 bits; 3'b111: 64 bits; (max).
            </comment>
        </bits>
        <bits name="num_hs_settle[7:0]" pos="7:0" access="rw" rst="0x28">
            <comment>Define the timing interval duing which the HS receiver shall ignore any clock Lane HS transitons.
            </comment>
        </bits>
    </reg>
    <reg name="csi_config_reg2" protect="rw">
        <bits name="num_c_term_en[15:0]" pos="31:16" access="rw" rst="0x0040">
            <comment>Num of sys clks before eable the clock lane HS termination, starting from when Dn changing to 1'b0.
            </comment>
        </bits>
        <bits name="num_hs_settle_clk[15:0]" pos="15:0" access="rw" rst="0x0040">
            <comment>Clock lane HS clk settle timing setting.
            </comment>
        </bits>
    </reg>
    <reg name="csi_config_reg3" protect="rw">
        <bits name="single_data_lane_en" pos="31" access="rw" rst="0x1">
            <comment>If 1'b1, single data lane mode; If 1'b0, dual data lane used.
            </comment>
        </bits>
        <bits name="clk_x2_sel" pos="30" access="rw" rst="0x0">
            <comment>Analog phy hs_clk freq ctrl bit.
                     If 1'b1, hs_clk freq = single_lane_bit_trans_freq/4, used in two data lane mode;
                     If 1'b0, hs_clk freq = single_lane_bit_trans_freq/8, used in single data lane mode;
            </comment>
        </bits>
        <bits name="clk_edge_sel" pos="29" access="rw" rst="0x0">
            <comment>Analog phy hs_clk sample edge ctrl bit.
            </comment>
        </bits>
        <bits name="pu_lprx_clk_reg" pos="28" access="rw" rst="0x1">
            <comment>LP clk lane pow up control reg
            </comment>
        </bits>
        <bits name="pu_lprx_d1_reg" pos="27" access="rw" rst="0x1">
            <comment>LP d1 lane pow up control reg
            </comment>
        </bits>
        <bits name="pu_lprx_d2_reg" pos="26" access="rw" rst="0x1">
            <comment>LP d2 lane pow up control reg
            </comment>
        </bits>
        <bits name="data1_hs_no_mask" pos="25" access="rw" rst="0x0">
            <comment>If 1'b1, hs_data1 from phy direct in fifo; If 1'b0, hs_data1 will fix to 8'b0 when hs_data_enable = 1'b0;
            </comment>
        </bits>
        <bits name="data2_hs_no_mask" pos="24" access="rw" rst="0x0">
            <comment>If 1'b1, hs_data2 from phy direct in fifo; If 1'b0, hs_data2 will fix to 8'b0 when hs_data_enable = 1'b0;
            </comment>
        </bits>
        <bits name="data1_lane_bit_reverse" pos="23" access="rw" rst="0x0">
            <comment>If 1'b1, data1_hs_out[7:0] bit reverse
            </comment>
        </bits>
        <bits name="data2_lane_bit_reverse" pos="22" access="rw" rst="0x0">
            <comment>If 1'b1, data2_hs_out[7:0] bit reverse
            </comment>
        </bits>
        <bits name="two_lane_bit_reverse" pos="21" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="csi_channel_sel" pos="20" access="rw" rst="0x0">
            <comment>Phy channel choose bit. If 1'b0, channel 1; If 1'b1, channel 2;
            </comment>
        </bits>
        <bits name="ecc_error_dr" pos="19" access="rw" rst="0x1">
            <comment>Ecc error direct reg control bit
            </comment>
        </bits>
        <bits name="ecc_error_flag_reg" pos="18" access="rw" rst="0x0">
            <comment>Ecc error reg
            </comment>
        </bits>
        <bits name="observe_reg_5_low8_choose" pos="17" access="rw" rst="0x1">
            <comment>If 1'b1, csi_observe_reg_5[7:0] = data_id[7:0]; If 1'b0, csi_observe_reg_5[7:0] = lp_cmd_out[7:0];
            </comment>
        </bits>
        <bits name="clk_terminal_enable_dr" pos="16" access="rw" rst="0x0">
            <comment>Clk terminal enable direct reg choose bit.
            </comment>
        </bits>
        <bits name="clk_terminal_enable_reg" pos="15" access="rw" rst="0x0">
            <comment>clk_terminal_enable setting register;
            </comment>
        </bits>
        <bits name="hs_clk_enable_dr" pos="14" access="rw" rst="0x0">
            <comment>Hs clock enable direct reg choose bit.
            </comment>
        </bits>
        <bits name="hs_clk_enable_choose_bit" pos="13" access="rw" rst="0x0">
            <comment>If 1, hs_clk_enable using clk_terminal_enable value;
            </comment>
        </bits>
        <bits name="hs_clk_enable_reg" pos="12" access="rw" rst="0x0">
            <comment>hs_clk_enable setting register;
            </comment>
        </bits>
        <bits name="avdd1v8_2v8_sel_reg" pos="11" access="rw" rst="0x0">
            <comment>avdd1v8_2v8 choose bit. If 1'b0, avdd 1v8.
            </comment>
        </bits>
        <bits name="pd_dr" pos="10" access="rw" rst="0x0">
            <comment>Analog power direct reg.
            </comment>
        </bits>
        <bits name="pd_hsrx_reg" pos="9" access="rw" rst="0x0">
            <comment>Pd_hsrx register.
            </comment>
        </bits>
        <bits name="pd_lprx_reg" pos="8" access="rw" rst="0x0">
            <comment>Pd_lprx register.
            </comment>
        </bits>
        <bits name="clk_lp_in_choose_bit[1:0]" pos="7:6" access="rw" rst="0x0">
            <comment>Low power clk choose bit. bit[1]=1? clk_lp_psyn : clk_lp_p; bit[0]=1? clk_lp_nsyn : clk_lp_n;
            </comment>
        </bits>
        <bits name="dly_sel_data1_reg[1:0]" pos="5:4" access="rw" rst="0x0">
            <comment>Data1 lane delay choose bit;
            </comment>
        </bits>
        <bits name="dly_sel_data2_reg[1:0]" pos="3:2" access="rw" rst="0x0">
            <comment>Data2 lane delay choose bit;
            </comment>
        </bits>
        <bits name="dly_sel_clk_reg[1:0]" pos="1:0" access="rw" rst="0x0">
            <comment>Clk lane delay choose bit;
            </comment>
        </bits>
    </reg>
    <reg name="csi_config_reg4" protect="rw">
        <bits name="num_hs_clk_useful_en" pos="31" access="rw" rst="0x1">
            <comment>If 1'b1, use num_hs_clk_useful value; If 1'b0, hs clk num unlimited, until clk lane pull up.
            </comment>
        </bits>
        <bits name="num_hs_clk_useful[30:0]" pos="30:0" access="rw" rst="0x7fff">
            <comment>Clock lane useful timing setting.
            </comment>
        </bits>
    </reg>
    <reg name="csi_config_reg5" protect="rw">
        <bits name="csi_rinc_new_mode_dis" pos="31" access="rw" rst="0x0">
            <comment>If 1'b0, rinc new mode, fifo read only available when hs_enable equals 1'b1, that means, all available data in fifo must be received before LP11 comes, in order to make data clean; If 1'b1, rinc use 8809 mode.
            </comment>
        </bits>
       <bits name="crc_error_flag_dr" pos="30" access="rw" rst="0x1">
            <comment>Crc error direct reg contorl bit ; If 1'b1, use reg value; If 1'b0, use logic calc value
            </comment>
        </bits>
       <bits name="crc_error_flag_reg" pos="29" access="rw" rst="0x0">
            <comment>Crc error reg; If 1'b1,crc error occur.
            </comment>
        </bits>
       <bits name="csi_observe_choose_bit[4:0]" pos="28:24" access="rw" rst="0x0">
            <comment>csi_observe_bus signal choose bit. 0~9 available. For debug use.
            </comment>
        </bits>
       <bits name="sync_id_dr" pos="23" access="rw" rst="0x1">
            <comment>Sync ID direct reg control bit. If 1'b1, use reg value; If 1'b0, use protocol default value;
            </comment>
        </bits>
       <bits name="sync_id_reg[7:0]" pos="22:15" access="rw" rst="0xb8">
            <comment>Sync ID direct reg.
            </comment>
        </bits>
       <bits name="data_type_re_check_en" pos="14" access="rw" rst="0x1">
            <comment>If 1'b1, when unexpected datatype datapacket in, hs state machine will bypass this packet, jump to waiting for next data packet check; If 1'b0, hs state will jump to IDLE and waiting for next Frame start.
            </comment>
        </bits>
       <bits name="reserved" pos="13:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="csi_config_reg6" protect="rw">
        <bits name="data_type_dr" pos="31" access="rw" rst="0x1">
            <comment>Frame/Line start/end packet direct reg control bit; If 1'b1, use [29:6] reg value; If 1'b1; use logic fix value.
            </comment>
        </bits>
        <bits name="data_type_dp_dr" pos="30" access="rw" rst="0x0">
            <comment>Data type packet direct reg control bit; If 1'b1, data type use [5:0] reg value, data transfer format follow raw8. If 1'b0, data type use CSI transfer value.
            </comment>
        </bits>
        <bits name="data_type_fs_reg[5:0]" pos="29:24" access="rw" rst="0x0">
            <comment>Frame start data type ID reg.
            </comment>
        </bits>
        <bits name="data_type_fe_reg[5:0]" pos="23:18" access="rw" rst="0x1">
            <comment>Frame end data type ID reg.
            </comment>
        </bits>
        <bits name="data_type_ls_reg[5:0]" pos="17:12" access="rw" rst="0x2">
            <comment>Line start data type ID reg.
            </comment>
        </bits>
        <bits name="data_type_le_reg[5:0]" pos="11:6" access="rw" rst="0x3">
            <comment>Line end data type ID reg.
            </comment>
        </bits>
        <bits name="data_type_dp_reg[5:0]" pos="5:0" access="rw" rst="0x40">
            <comment>Data type ID reg.
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="CSI_CONFIG_REG7">
        <bits access="wr" name="CSI_CONFIG_REGISTER7" pos="31:0" rst="0">
            <comment> csi camera config resiger7
            </comment>
        </bits>
    </reg>

    <reg name="csi_observe_reg4" protect="ro">
        <bits name="fifo_wempty" pos="31" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="fifo_wfull" pos="30" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="fifo_wfull_almost" pos="29" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="phy_data_state[14:0]" pos="28:14" access="ro" rst="0x0">
            <comment>Data lane phy control state.
            </comment>
        </bits>
        <bits name="hs_data_state[13:0]" pos="13:0" access="ro" rst="0x0">
            <comment>Data lane HS control state.
            </comment>
        </bits>
    </reg>
    <reg name="csi_observe_reg5" protect="ro">
        <bits name="err_data_zero_flag" pos="31" access="ro" rst="0x0">
            <comment>If 1'b1, no ecc error in stream head.
            </comment>
        </bits>
        <bits name="err_data_corrected_flag" pos="30" access="ro" rst="0x0">
            <comment>If 1'b1, infer single ecc error in data part , and could be corrected.
            </comment>
        </bits>
        <bits name="err_ecc_corrected_flag" pos="29" access="ro" rst="0x0">
            <comment>If 1'b1.,infer single ecc error in ecc trans part , and could be corrected.
            </comment>
        </bits>
        <bits name="hs_data_error_flag" pos="28" access="ro" rst="0x0">
            <comment>If 1'b1, ecc err or crc err occurs.
            </comment>
        </bits>
        <bits name="fifo_rcount[8:0]" pos="27:19" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="phy_clk_state[8:0]" pos="18:10" access="ro" rst="0x0">
            <comment>Clk lane phy control state.
            </comment>
        </bits>
        <bits name="lp_cmd_interrupt_flag" pos="9" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="lp_data_interrupt_flag" pos="8" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="lp_cmd_out[7:0]" pos="7:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="csi_observe_reg6" protect="ro">
        <bits name="lp_data_out[63:32]" pos="31:0" access="ro" rst="0x0">
            <comment>LP trans data high 32 bits.
            </comment>
        </bits>
    </reg>
    <reg name="csi_observe_reg7" protect="ro">
        <bits name="lp_data_out[31:0]" pos="31:0" access="ro" rst="0x0">
            <comment>LP trans data low 32 bits.
            </comment>
        </bits>
    </reg>


    <reg protect="rw" name="CSI_ENABLE">
        <bits access="wr" name="CSI_ENABLE" pos="31:0" rst="0">
            <comment> csi camera enable
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="DCT_SHIFTR_Y_REG0">
        <bits access="wr" name="DCT_SHIFTR_Y_REG0" pos="31:0" rst="0">
            <comment> DCT shift
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="DCT_SHIFTR_Y_REG1">
        <bits access="wr" name="DCT_SHIFTR_Y_REG1" pos="31:0" rst="0">
            <comment> DCT shift
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="DCT_CHOOSE_Y_REG0">
        <bits access="wr" name="DCT_CHOOSE_Y_REG0" pos="31:0" rst="0">
            <comment> DCT choose
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="DCT_CHOOSE_Y_REG1">
        <bits access="wr" name="DCT_CHOOSE_Y_REG1" pos="31:0" rst="0">
            <comment> DCT choose
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="DCT_SHIFTR_UV_REG0">
        <bits access="wr" name="DCT_SHIFTR_UV_REG0" pos="31:0" rst="0">
            <comment> DCT shift
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="DCT_SHIFTR_UV_REG1">
        <bits access="wr" name="DCT_SHIFTR_UV_REG1" pos="31:0" rst="0">
            <comment> DCT shift
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="DCT_CHOOSE_UV_REG0">
        <bits access="wr" name="DCT_CHOOSE_UV_REG0" pos="31:0" rst="0">
            <comment> DCT choose
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="DCT_CHOOSE_UV_REG1">
        <bits access="wr" name="DCT_CHOOSE_UV_REG1" pos="31:0" rst="0">
            <comment> DCT choose
            </comment>
        </bits>
    </reg>
    <reg protect="rw" name="DCT_CONFIG">
        <bits access="wr" name="DCT_CONFIG" pos="31:0" rst="0">
            <comment> DCT config
            </comment>
        </bits>
    </reg>
    <reg name="AXI_CONFIG" protect="rw">
        <bits name="l_axi_en" pos="5" access="rw" rst="0x0">
            <comment>axi enable.
            </comment>
        </bits>
        <bits name="l_dma_use" pos="4" access="rw" rst="0x0">
            <comment>Dma mode, 0Directly AXI; 1rotation DMA.
            </comment>
        </bits>
        <bits name="l_burst_len" pos="3:0" access="rw" rst="0x0">
            <comment>Axi burst length
            </comment>
        </bits>
    </reg>
    <reg name="FRAME_START_ADDR" protect="rw">
        <bits name="l_frame_start_addr" pos="31:0" access="rw" rst="0x0">
            <comment>MFrame start addressmust DW alignbit[2:0] = 000
            </comment>
        </bits>
    </reg>
    <reg name="FRAME_SIZE" protect="rw">
        <bits name="l_frame_size" pos="31:0" access="rw" rst="0x0">
            <comment>Frame size in byte.
            </comment>
        </bits>
    </reg>
    <reg name="TC_COUNT" protect="ro">
        <bits name="l_tc_count" pos="31:0" access="ro" rst="0x0">
            <comment>Current tc count.
            </comment>
        </bits>
    </reg>

    <hole size="2592"/>
    <struct count="FIFORAM_SIZE" name="FIFORAM">
    <reg name="RAMData" protect="r">
        <bits name="Data" pos="31:0" access="r" rst="0">
            <comment> Direct FIFO Ram Access. They are enabled only in Bist Mode.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    </struct>

</module>
</archive>

<archive relative='dma_ap.xml' >

<module name="dma_ap" category="Ap">

    <reg name="dma_get_channel" protect="rw">
    </reg>
    <reg name="dma_status" protect="rw">
    </reg>
    <reg name="dma_control" protect="rw">
        <bits name="Reserved" pos="31:26" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="DMA_DST_SELECT" pos="25" access="rw" rst="0x0">
            <comment>0: DST DATA To AXI Device; 1: DST DATA To Nand Flash; BIT24 and BIT25 1.
            </comment>
        </bits>
        <bits name="DMA_SRC_SELECT" pos="24" access="rw" rst="0x0">
            <comment>0: SRC DATA From AXI Device; 1: SRC DATA From Nand Flash; BIT24 and BIT25 1.
            </comment>
        </bits>
        <bits name="Reserved" pos="23:22" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dst_Address_Mgt" pos="21:20" access="rw" rst="0x0">
            <comment>Dst address select, 00: normal; 01: const dst address; 10: Alternative address.
            </comment>
        </bits>
        <bits name="Reserved" pos="19:17" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="FCS_Enable" pos="16" access="rw" rst="0x0">
            <comment>These bits are used for FCS, default 0.
            </comment>
        </bits>
        <bits name="Reserved" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="GEA_Direction" pos="14" access="rw" rst="0x0">
            <comment>These bits are used for GEA, default 0.
            </comment>
        </bits>
        <bits name="GEA_ALGO" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="GEA_Enable" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="USE_PATTERN_BIT" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="INT_CLEAR_BIT" pos="2" access="rw" rst="0x0">
            <comment>1:	Clear INTERRUPT
            </comment>
        </bits>
        <bits name=" INT_MASK_BIT" pos="1" access="rw" rst="0x0">
            <comment>0:	DISABLE INTERRUPT; 1: ENABLE INTERRUPT
            </comment>
        </bits>
        <bits name="START_BIT" pos="0" access="rw" rst="0x0">
            <comment>0: DISABLE DMA; 1: START DMA.
            </comment>
        </bits>
    </reg>
    <reg name="dma_src_addr" protect="rw">
    </reg>
    <reg name="dma_dst_addr" protect="rw">
    </reg>
    <reg name="dma_sd_dst_addr" protect="rw">
    </reg>
    <reg name="dma_xfer_size" protect="rw">
    </reg>
    <reg name="dma_pattern" protect="rw">
    </reg>
    <reg name="dma_gea_kc_low" protect="rw">
    </reg>
    <reg name="dma_gea_kc_high" protect="rw">
    </reg>
    <reg name="dma_gea_gea_messkey" protect="rw">
    </reg>
    <reg name="dma_gea_fcs" protect="rw">
    </reg>
    <reg name="dma_LLI_counter" protect="rw">
    </reg>
    <reg name="dma_Image_Rotate_Ctrl" protect="rw">
        <bits name="Reserved" pos="31:29" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Image_rotate_type" pos="28:26" access="rw" rst="0x0">
            <comment>0: rotate 0; 1: rotate 90; 2: rotate 180; 3: rotate 270; 4: right/left mirror; 5: up/down mirror.
            </comment>
        </bits>
        <bits name="Image_rotate_enable" pos="25" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Image_format" pos="24" access="rw" rst="0x0">
            <comment>1: 32 bits per pixel; 0: 16 bits per pixel.
            </comment>
        </bits>
        <bits name=" Image_row(pixel)" pos="23:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name=" Image_column(pixel)" pos="11:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="dma_LLI1_SRC_ADDR" protect="rw">
    </reg>
    <reg name="dma_LLI1_DST_ADDR" protect="rw">
    </reg>
    <reg name="dma_LLI1_TRANSFER_SIZE" protect="rw">
    </reg>
    <reg name="dma_LLI2_SRC_ADDR" protect="rw">
    </reg>
    <reg name="dma_LLI2_DST_ADDR" protect="rw">
    </reg>
    <reg name="dma_LLI2_TRANSFER_SIZE" protect="rw">
    </reg>
    <reg name="dma_LLI3_SRC_ADDR" protect="rw">
    </reg>
    <reg name="dma_LLI3_DST_ADDR" protect="rw">
    </reg>
    <reg name="dma_LLI3_TRANSFER_SIZE" protect="rw">
    </reg>
    <reg name="dma_LLI4_SRC_ADDR" protect="rw">
    </reg>
    <reg name="dma_LLI4_DST_ADDR" protect="rw">
    </reg>
    <reg name="dma_LLI4_TRANSFER_SIZE" protect="rw">
    </reg>
    <reg name="dma_LLI5_SRC_ADDR" protect="rw">
    </reg>
    <reg name="dma_LLI5_DST_ADDR" protect="rw">
    </reg>
    <reg name="dma_LLI5_TRANSFER_SIZE" protect="rw">
    </reg>
</module>
</archive>

<archive relative='nand_ctrl.xml' >

<module name="nand_ctrl" category="Ap">
    <hole size="256*32"/>
    <reg name="direct_command_address" protect="rw">
        <bits name="direct_command" pos="31:24" access="rw" rst="XX">
            <comment>Direct command.
            </comment>
        </bits>
        <bits name="sector_mask_bits" pos="23:20" access="rw" rst="XX">
            <comment>Sector mask bits for 2K page Flash, active high. Bit23: Sector 0 mask; Bit22: Sector 1 mask; Bit21: Sector 2 mask; Bit20: Sector 3 mask.
            </comment>
        </bits>
        <bits name="page_addr" pos="19:0" access="rw" rst="XX">
            <comment>Page (sector) address, for those command without address input requirement, the LSB 24 bits are don't care.
            </comment>
        </bits>
    </reg>
    <hole size="2*32"/>
    <reg name="column_address" protect="rw">
        <bits name="Unusable" pos="31:13" access="rw" rst="XX">
            <comment>
            </comment>
        </bits>
        <bits name="column_address_register_bits" pos="12:0" access="rw" rst="0x0">
            <comment>Flash/SM column address register.
            </comment>
        </bits>
    </reg>

    <reg name="configuration_A" protect="rw">
    	  <bits name="Unusable" pos="31:19" access="rw" rst="XX">
            <comment>
            </comment>
        </bits>
        <bits name="io_bit_16" pos="18" access="rw" rst="0x0">
            <comment>1: 16-bit io  0:8-bit io
            </comment>
        </bits>
        <bits name="data_inv_at_mem" pos="17" access="rw" rst="0x0">
            <comment>0 : data is negative as in the nand flash controller memory; 1 : data is the same as in the nand flash controller memory
            </comment>
        </bits>
        <bits name="data_inv_at_io" pos="16" access="rw" rst="0x0">
            <comment>0: data is negative as device; 1: data is same as device in the nand flash data io port
            </comment>
        </bits>
        <bits name="Flash Memory Access Timing select code" pos="15:8" access="rw" rst="0x8c">
            <comment>0: 0x39, 0x59: for 64Mbits, 128Mbits, 256Mbits small page (512Bytes) Flash (0x59 support COPY-BACK command) 0x69: for 512Mbits, 1Gbits, 2Gbits small page (512Bytes) Flash 0x7B : for 1GBit large page (2048Bytes) Flash 0x8B: for 2Gbits, 4Gbits, 8Gbits,16Gbits, 32Gbits large page (2048Bytes) Flash
            </comment>
        </bits>
        <bits name="chip select 3" pos="7" access="rw" rst="0x01">
            <comment> active low
            </comment>
        </bits>
        <bits name="chip select 2" pos="6" access="rw" rst="0x01">
            <comment>active low
            </comment>
        </bits>
        <bits name="chip select 1" pos="5" access="rw" rst="0x01">
            <comment> active low
            </comment>
        </bits>
        <bits name="chip select 0" pos="4" access="rw" rst="0x0">
            <comment>1: active low
            </comment>
        </bits>
        <bits name="Flash/SM access cycle select" pos="3:0" access="rw" rst="0x0100">
            <comment> 000: sysclk/3(not support, for 16bit data width device); 001:sysclk/4; 010: sysclk/5; 011: sysclk/6; 100: sysclk/7; 101: sysclk/8; 101: sysclk/9; 111: sysclk/10; Note: the access cycle must be not less than the min Flash/SM access cycle
            </comment>
        </bits>
    </reg>
     <reg name="configuration_B" protect="rw">
    	  <bits name="Unusable" pos="31:11" access="rw" rst="XX">
            <comment>
            </comment>
        </bits>
        <bits name="BCH enable" pos="7" access="rw" rst="0x0">
            <comment>active high
            </comment>
        </bits>
        <bits name="Mode" pos="3:0" access="rw" rst="0x0">
            <comment>00: 2K mode (for SLC); 10: 1K mode (for MLC)
            </comment>
        </bits>
   </reg>
    <hole size="1*32"/>
   <reg name="Busy Flag" protect="rw">
    	  <bits name="Unusable" pos="31:2" access="rw" rst="XX">
            <comment>
            </comment>
        </bits>
        <bits name="Flash Controller busy" pos="1" access="ro" rst="0x0">
            <comment>active high
            </comment>
        </bits>
        <bits name="External Flash busy" pos="0" access="ro" rst="0x0">
            <comment>active high
            </comment>
        </bits>
   </reg>
   <reg name="Controller Interrupt Status" protect="rw">
    	  <bits name="Unusable" pos="31:12" access="rw" rst="XX">
            <comment>
            </comment>
        </bits>
        <bits name="CRC check fail 2" pos="11" access="rw" rst="0x0">
            <comment>active high, cleared by CPU write 1
            </comment>
        </bits>
        <bits name="CRC check fail 1" pos="10" access="rw" rst="0x0">
            <comment>active high, cleared by CPU write 1
            </comment>
        </bits>
        <bits name="CRC check fail 0" pos="9" access="rw" rst="0x0">
            <comment>active high, cleared by CPU write 1
            </comment>
        </bits>
        <bits name="ECC (data) error 2" pos="8" access="rw" rst="0x0">
            <comment>active high, cleared by CPU write 1
            </comment>
        </bits>
        <bits name="ECC (data) error 1" pos="7" access="rw" rst="0x0">
            <comment>active high, cleared by CPU write 1
            </comment>
        </bits>
        <bits name="ECC (data) error 0" pos="6" access="rw" rst="0x0">
            <comment>active high, cleared by CPU write 1
            </comment>
        </bits>
        <bits name="CRC check fail " pos="5" access="rw" rst="0x0">
            <comment>active high, cleared by CPU write 1
            </comment>
        </bits>
        <bits name="Operation done for multi-block/command operation," pos="4" access="rw" rst="0x0">
            <comment>active high, cleared by CPU write 1
            </comment>
        </bits>
        <bits name="Busy timeout" pos="3" access="rw" rst="0x0">
            <comment>active high, cleared by CPU write 1
            </comment>
        </bits>
        <bits name="Erase error" pos="2" access="rw" rst="0x0">
            <comment>active high, cleared by CPU write 1
            </comment>
        </bits>
        <bits name="Program error" pos="1" access="rw" rst="0x0">
            <comment>active high, cleared by CPU write 1
            </comment>
        </bits>
        <bits name="ECC (data) error" pos="10" access="rw" rst="0x0">
            <comment>active high, cleared by CPU write 1
            </comment>
        </bits>
   </reg>
   <reg name="ID Code A" protect="rw">
    	  <bits name="Unusable" pos="31:24" access="ro" rst="0x0">
            <comment>Byte 8 of Flash/SM ID code
            </comment>
        </bits>
        <bits name="Unusable" pos="23:16" access="ro" rst="0x0">
            <comment>Byte 7 of Flash/SM ID code
            </comment>
        </bits>
        <bits name="Unusable" pos="15:8" access="ro" rst="0x0">
            <comment>Byte 6 of Flash/SM ID code
            </comment>
        </bits>
        <bits name="Unusable" pos="7:0" access="ro" rst="0x0">
            <comment>Byte 5 of Flash/SM ID code
            </comment>
        </bits>
   </reg>
   <reg name="ID Code B" protect="rw">
    	  <bits name="Unusable" pos="31:24" access="ro" rst="0x0">
            <comment>Byte 4 of Flash/SM ID code
            </comment>
        </bits>
        <bits name="Unusable" pos="23:16" access="ro" rst="0x0">
            <comment>Byte 3 of Flash/SM ID code
            </comment>
        </bits>
        <bits name="Unusable" pos="15:8" access="ro" rst="0x0">
            <comment>Byte 2 of Flash/SM ID code
            </comment>
        </bits>
        <bits name="Unusable" pos="7:0" access="ro" rst="0x0">
            <comment>Byte 1 of Flash/SM ID code
            </comment>
        </bits>
   </reg>
   <reg name="DMA REQ Enable" protect="rw">
    	  <bits name="Unusable" pos="31:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Read DMA request enable" pos="1" access="ro" rst="0x0">
            <comment>0:disable 1:enable
            </comment>
        </bits>
        <bits name="Write DMA request enable" pos="0" access="ro" rst="0x0">
            <comment>0:disable 1:enable
            </comment>
        </bits>
   </reg>
   <reg name="COMMAND Definition A" protect="rw">
    	  <bits name="Copy back program first cycle command definition" pos="31:24" access="rw" rst="0x85">
            <comment>(For supporting SMIC copy back: 0x86)
            </comment>
        </bits>
        <bits name="Copy back program second cycle command definition" pos="23:16" access="rw" rst="0x10">
            <comment>(For supporting SMIC copy back: 0x16)
            </comment>
        </bits>
        <bits name="Program second cycle command definition" pos="15:8" access="rw" rst="0x10">
            <comment>(may use to  support SMIC extended memory page program if necessary)
            </comment>
        </bits>
        <bits name="Erase second cycle command definition" pos="7:0" access="rw" rst="0xd0">
            <comment>(For supporting SMIC block erase:0xD1)
            </comment>
        </bits>
   </reg>
   <reg name="COMMAND Definition B" protect="rw">
    	  <bits name="Single command 5C mapping definition" pos="31:24" access="rw" rst="0x50">
            <comment>(can be used to  support other special command)
            </comment>
        </bits>
        <bits name="Single command 5B mapping definition" pos="23:16" access="rw" rst="0x01">
            <comment>(For supporting SMIC factory bad block table read: 0x58)
            </comment>
        </bits>
        <bits name="Single command 5A mapping definition" pos="15:8" access="rw" rst="0x0">
            <comment>(For supporting SMIC factory bad block table read: x5A)
            </comment>
        </bits>
        <bits name="Read second cycle command definition" pos="7:0" access="rw" rst="0x30">
            <comment>(For supporting SMIC block erase:0xD1)
            </comment>
        </bits>
   </reg>
    <hole size="1*32"/>

   <reg name="NAND FLASH Status" protect="rw">
    	  <bits name="Unusable" pos="31:1" access="rw" rst="-">
            <comment>
            </comment>
        </bits>
        <bits name="data_inv" pos="0" access="rw" rst="0x0">
            <comment>0: data is negative as device  1: data is same as device
            </comment>
        </bits>
   </reg>
   <reg name="Features Control" protect="rw">
    	  <bits name="Reserved" pos="31:16" access="rw" rst="0x00">
            <comment>
            </comment>
        </bits>
        <bits name="The address when activating the synchronous interface" pos="15:8" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="unusable" pos="7:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Number of features" pos="2:0" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="NAND FLASH Features Data" protect="rw">
    	  <bits name="Get features data" pos="31:24" access="rw" rst="0x00">
            <comment>Features data P4
            </comment>
        </bits>
        <bits name="Get features data" pos="23:16" access="rw" rst="0x00">
            <comment>Features data P3
            </comment>
        </bits>
        <bits name="Get features data" pos="15:8" access="rw" rst="0x00">
            <comment>Features data P2
            </comment>
        </bits>
        <bits name="Get features data" pos="7:0" access="rw" rst="0x00">
            <comment>Features data P1
            </comment>
        </bits>
   </reg>
   <reg name="NAND FLASH synchronous delay number" protect="rw">
    	  <bits name="Reserved" pos="31:8" access="ro" rst="0x00">
            <comment>Features data P4
            </comment>
        </bits>
        <bits name="Dqs delay number" pos="7:4" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="synchronous" pos="3" access="ro" rst="0x00">
            <comment>1: the interface is synchronous  0: the interface is asynchronous
            </comment>
        </bits>
        <bits name="Number of cycles to wait tadl" pos="2:0" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
   </reg>
   <reg name="NAND FLASH last 2 bytes mark" protect="rw">
    	  <bits name="Reserved" pos="31:29" access="ro" rst="0x00">
            <comment>Features data P4
            </comment>
        </bits>
        <bits name="mark2" pos="28:16" access="rw" rst="0x10DE">
            <comment>Mark the last 2 bytes in reading. In accordance with the page size
            </comment>
        </bits>
        <bits name="Rserved" pos="15:13" access="ro" rst="0x00">
            <comment>
            </comment>
        </bits>
        <bits name="mark1" pos="12:0" access="rw" rst="0x10DD">
            <comment>Mark the last 2 bytes in writing. In accordance with the page size
            </comment>
        </bits>
   </reg>
</module>
</archive>

<archive relative='memory_burst_adapter.xml' >

<module name="memory_burst_adapter" category="testbench">
    <reg16 name="Burst Config" protect="rw">
        <comment>This register is accessible only when CRE is set to 1.
            <br/>When read and write are not both in same mode, a cycle with CS high must be insterted between read and write access.
        </comment>
        <bits name="Read_Mode" pos="0" access="rw" rst="0">
            <options>
                <option name="Asynchronous" value="0"/>
                <option name="Synchronous" value="1"/>
            </options>
        </bits>
        <bits name="Write_Mode" pos="1" access="rw" rst="0">
            <comment>For write burst mode, WE must be asserted with CS in order to detect writes.
            </comment>
            <options>
                <option name="Asynchronous" value="0"/>
                <option name="Synchronous" value="1"/>
            </options>
        </bits>
        <bits name="Burst_Lat" pos="7:4" access="rw" rst="0">
            <comment>Initial burst latency
            </comment>
        </bits>
        <bits name="Page_Size" pos="10:8" access="rw" rst="0">
                <options>
                    <option name="4HW" value="0"><comment>4 half words </comment></option>
                    <option name="8HW" value="1"><comment>8 half words </comment></option>
                    <option name="16HW" value="2"><comment>16 half words </comment></option>
                    <option name="32HW" value="3"><comment>32 half words </comment></option>
                    <option name="64HW" value="4"><comment>64 half words </comment></option>
                    <option name="128HW" value="5"><comment>128 half words </comment></option>
                    <option name="256HW" value="6"><comment>256 half words </comment></option>
                    <option name="FULL" value="7"><comment>Full page (in burst mode, else reserved)</comment></option>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
                <comment>Page size for bursts access.
                </comment>
        </bits>
    </reg16>
    <reg16 name="Scratch" protect="rw">
        <bits name="Scratch" pos="15:0" access="rw" rst="0">
        </bits>
    </reg16>

</module>
</archive>

<archive relative='pmu.xml' >


<module name="pmu" category="added_func">
    <reg name="pmu_00H_Revision_ID" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="ChipID" pos="15:4" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="RevID" pos="3:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>    
    <reg name="pmu_01H_IRQ_settings" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="eomirq" pos="15" access="ro" rst="0x0">
            <comment>End of measurement interrupt.
            </comment>
        </bits>  
        <bits name="penirq" pos="14" access="ro" rst="0x0">
            <comment>touch interrupt.
            </comment>
        </bits> 
        <bits name="Penirq_key" pos="13" access="ro" rst="0x0">
            <comment>Masked eomirq.
            </comment>
        </bits> 
        <bits name="Clear_penirq_key" pos="12" access="ro" rst="0x0">
            <comment>Masked penirq.
            </comment>
        </bits> 
        <bits name="Eomirq_clear" pos="11" access="rw" rst="0x0">
            <comment>Clear eomirq
            </comment>
        </bits> 
        <bits name="Penirq_clear" pos="10" access="rw" rst="0x0">
            <comment>Clear penirq.
            </comment>
        </bits> 
        <bits name="eomirq_mask" pos="9" access="rw" rst="0x0">
            <comment>1: mask eomirq; 0: don't mask eomirq.
            </comment>
        </bits> 
        <bits name="Penirq_mask" pos="8" access="rw" rst="0x0">
            <comment>1: masked penirq; 0: don't mask penirq.
            </comment>
        </bits> 
        <bits name="Int_chr" pos="7" access="ro" rst="0x0">
            <comment>Charger on interrupt.
            </comment>
        </bits>  
        <bits name="Penirq_key_mask" pos="6" access="ro" rst="0x0">
            <comment>Masked intirq.
            </comment>
        </bits> 
        <bits name="Clear_int_chr" pos="5" access="rw" rst="0x0">
            <comment>Clear chrirq.
            </comment>
        </bits> 
        <bits name="Int_chr_mask" pos="4" access="rw" rst="0x0">
            <comment>1: mask chrirq; 0: don't mask penirq.
            </comment>
        </bits> 
        <bits name="Reserved" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Resetn_efuse" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="reserved" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Pd_mode_sel" pos="0" access="rw" rst="0x0">
            <comment>0: ldo power control by default profile; 1: ldo power control by software.
            </comment>
        </bits>                                                                                          
    </reg>  
    <reg name="pmu_02H_ldo_settings" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Vsim0_enable" pos="15" access="rw" rst="0x0">
            <comment>SIM CARD 1 LDO enable.
            </comment>
        </bits>  
        <bits name="Vsim1_enable" pos="14" access="rw" rst="0x0">
            <comment>SIM CARD 2 LDO enable.
            </comment>
        </bits> 
        <bits name="Vsim2_enable" pos="13" access="rw" rst="0x0">
            <comment>SIM CARD 3 LDO enable.
            </comment>
        </bits> 
        <bits name="Vsim3_enable" pos="12" access="rw" rst="0x0">
            <comment>SIM CARD 4 LDO enable.
            </comment>
        </bits> 
        <bits name="Vmc_enable" pos="11" access="rw" rst="0x1">
            <comment>Memory card LDO enable.
            </comment>
        </bits> 
        <bits name="Va_enable" pos="10" access="rw" rst="0x1">
            <comment>ABB LDO enable.
            </comment>
        </bits> 
        <bits name="Vasw_enable" pos="9" access="rw" rst="0x1">
            <comment>Tranceiver LDO enable.
            </comment>
        </bits> 
        <bits name="Gpadc_enable" pos="8" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="Vibr_enable" pos="7" access="rw" rst="0x0">
            <comment>Vibrator LDO enable.
            </comment>
        </bits>  
        <bits name="Vmic_enable" pos="6" access="rw" rst="0x0">
            <comment>Microphone LDO enable.
            </comment>
        </bits> 
        <bits name="Vcam_enable" pos="5" access="rw" rst="0x1">
            <comment>Cameral LDO enable.
            </comment>
        </bits> 
        <bits name="Vlcd_enable" pos="4" access="rw" rst="0x1">
            <comment>LCD LDO enable.
            </comment>
        </bits> 
        <bits name="Tsc_enable" pos="3" access="rw" rst="0x1">
            <comment>Touch Screen LDO enable.
            </comment>
        </bits> 
        <bits name="Key_enable" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Bt_enable" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Fm_enable" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                          
    </reg> 
    <reg name="pmu_03H_LDO_ACTIVE_SETTING_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pu_buck1_act" pos="15" access="rw" rst="0x1">
            <comment>BB core DCDC power for ACTIVE MODE, 1: power on; 0: power off.
            </comment>
        </bits>  
        <bits name="Pfm_mode_sel_buck1_act" pos="14" access="rw" rst="0x0">
            <comment>DCDC1 mode select for ACTIVE MODE. 1: pfm mode, used for light load; 0: pwm mode, used for heavy load.
            </comment>
        </bits> 
        <bits name="Pu_buck1_ldo_act" pos="13" access="rw" rst="0x0">
            <comment>BB core LDO power for ACTIVE MODE 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vm_act" pos="12" access="rw" rst="0x1">
            <comment>BB Memory power for ACTIVE MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vio_act" pos="11" access="rw" rst="0x1">
            <comment>BB IO power for ACTIVE MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_va_act" pos="10" access="rw" rst="0x1">
            <comment>ABB power for ACTIVE MODE, 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vasw_act" pos="9" access="rw" rst="0x1">
            <comment>Tranceiver power for ACTIVE MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vcam_act" pos="8" access="rw" rst="0x1">
            <comment>Cameral power for ACTIVE MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vlcd_act" pos="7" access="rw" rst="0x1">
            <comment>LCD power for ACTIVE MODE. 0: power on; 1: power off.
            </comment>
        </bits>  
        <bits name="Pu_vmc_act" pos="6" access="rw" rst="0x1">
            <comment>SD/MMC power for ACTIVE MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vibr_act" pos="5" access="rw" rst="0x1">
            <comment>vibrator power for ACTIVE MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vusb_act" pos="4" access="rw" rst="0x1">
            <comment>USB power for ACTIVE MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vmic_act" pos="3" access="rw" rst="0x1">
            <comment>Microphone power for ACTIVE MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_bl_led_act" pos="2" access="rw" rst="0x1">
            <comment>Backlight Led power for ACTIVE MODE. 0: power on; 1: power off
            </comment>
        </bits> 
        <bits name="Pu_spimem_act" pos="1" access="rw" rst="0x1">
            <comment>SPI Memory power for ACTIVE MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Lp_mode_b_act" pos="0" access="rw" rst="0x1">
            <comment>LDO Mode for ACTIVE MODE. 0: LP Mode; 1: Normal Mode.
            </comment>
        </bits>                                                                                          
    </reg>  
    <reg name="pmu_04H_LDO_ACTIVE_SETTING_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Vrtc_vbit_act" pos="15:13" access="rw" rst="0x4">
            <comment>Reserved bit.
            </comment>
        </bits>  
        <bits name="Vio_vsel_act" pos="12" access="rw" rst="0x0">
            <comment>VIO LDO voltage select; 0: 2.8V; 1: 1.8V.
            </comment>
        </bits> 
        <bits name="Vasw_vsel_act" pos="11" access="rw" rst="0x1">
            <comment>VRF LDO voltage select. 0: 2.8V; 1: 1.8V.
            </comment>
        </bits> 
        <bits name="Vcam_vsel_act" pos="10" access="rw" rst="0x1">
            <comment>Vcam LDO voltage select. 0: 2.8V; 1: 1.8V..
            </comment>
        </bits> 
        <bits name="Vlcd_vsel_act" pos="9" access="rw" rst="0x1">
            <comment>Vlcd LDO voltage select. 0: 2.8V; 1: 1.8V.
            </comment>
        </bits> 
        <bits name="Vmc_vsel_act" pos="8" access="rw" rst="0x1">
            <comment>Vmc LDO voltage select. 0: 2.8V; 1: 1.8V.
            </comment>
        </bits> 
        <bits name="Vibr_vsel_act" pos="7" access="rw" rst="0x0">
            <comment>Vvib LDO voltage select. 0: 2.8V; 1: 1.8V.
            </comment>
        </bits>  
        <bits name="Pu_vrf28_act" pos="6" access="rw" rst="0x1">
            <comment>RF module power, 1: power off..
            </comment>
        </bits> 
        <bits name="Pu_vboost_act" pos="5" access="rw" rst="0x1">
            <comment>Boost DCDC for led. 1: power up; 0: power off.
            </comment>
        </bits> 
        <bits name="Pu_buck2_act" pos="4" access="rw" rst="0x1">
            <comment>DCDC2 Power. 1: power on; 0: power off.
            </comment>
        </bits> 
        <bits name="Pfm_mode_sel_buck2_act" pos="3" access="rw" rst="0x0">
            <comment>DCDC2 mode. 1: pfm mode, for low power; 0: pwm mode.
            </comment>
        </bits> 
        <bits name="Pu_buck2_ldo_act" pos="2" access="rw" rst="0x0">
            <comment>LDO parallel with DCDC2.
            </comment>
        </bits> 
        <bits name="Pu_rgb_led_act" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="V_res_bit_act" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                          
    </reg>
    <reg name="pmu_05H_LDO_ACTIVE_SETTING_3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
        <bits name="Vbackup_vbit_act" pos="14:12" access="rw" rst="0x4">
            <comment>Vcore LDO current control.
            </comment>
        </bits> 
        <bits name="Vspimem_ibit_act" pos="11:9" access="rw" rst="0x7">
            <comment>SPI Memory voltage control.
            </comment>
        </bits> 
        <bits name="Vm_ibit_act" pos="8:6" access="rw" rst="0x4">
            <comment>Memory LDO current control.
            </comment>
        </bits> 
        <bits name="Vio_ibit_act" pos="5:3" access="rw" rst="0x4">
            <comment>IO LDO current control
            </comment>
        </bits> 
        <bits name="pu_cp_act" pos="2" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="Vrtc_dcdc1_en_act" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
        <bits name="Vrtc_dcdc2_en_act" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>                                                                          
    </reg> 
    <reg name="pmu_06H_LDO_ACTIVE_SETTING_4" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pulldown_vibr" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
        <bits name="Vasw_ibit" pos="14:12" access="rw" rst="0x4">
            <comment>RF LDO current control.
            </comment>
        </bits> 
        <bits name="Vcam_ibit" pos="11:9" access="rw" rst="0x4">
            <comment>Cameral LDO current control.
            </comment>
        </bits> 
        <bits name="Vlcd_ibit" pos="8:6" access="rw" rst="0x4">
            <comment>LCD LDO current control.
            </comment>
        </bits> 
        <bits name="Vmc_ibit" pos="5:3" access="rw" rst="0x4">
            <comment>SD/MMC LDO current control.
            </comment>
        </bits> 
        <bits name="Vibr_ibit" pos="2:0" access="rw" rst="0x4">
            <comment>Vibrator LDO current control
            </comment>
        </bits>                                                        
    </reg>  
    <reg name="pmu_07H_LDO_ACTIVE_SETTING_5" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Vsim0_vsel_act" pos="15" access="rw" rst="0x1">
            <comment>1: 1.8V; 0: 2.8V.
            </comment>
        </bits>  
        <bits name="Vsim1_vsel_act" pos="14" access="rw" rst="0x1">
            <comment>1: 1.8V; 0: 2.8V.
            </comment>
        </bits> 
        <bits name="Vsim2_vsel_act" pos="13" access="rw" rst="0x1">
            <comment>1: 1.8V;0: 2.8V.
            </comment>
        </bits> 
        <bits name="Vsim3_vsel_act" pos="12" access="rw" rst="0x1">
            <comment>1: 1.8V; 0: 2.8V.
            </comment>
        </bits> 
        <bits name="Vusb_ibit_act" pos="11:9" access="rw" rst="0x4">
            <comment>USB LDO current control.
            </comment>
        </bits> 
        <bits name="Va_ibit" pos="8:6" access="rw" rst="0x4">
            <comment>Vibrator LDO current control
            </comment>
        </bits>     
        <bits name="Vrgb_led_vsel" pos="5:2" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Vrgb_led_ibit" pos="1:0" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>                                                                   
    </reg>           
    <reg name="pmu_08H_LDO_LP_SETTING_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pu_buck1_lp" pos="15" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>  
        <bits name="Pfm_mode_sel_buck1_lp" pos="14" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="Pu_buck1_ldo_lp" pos="13" access="rw" rst="0x0">
            <comment>BB core LDO power for LP MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vm_lp" pos="12" access="rw" rst="0x1">
            <comment>BB Memory power for LP MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vio_lp" pos="11" access="rw" rst="0x1">
            <comment>BB IO power for LP MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_va_lp" pos="10" access="rw" rst="0x0">
            <comment>ABB power for LP MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vasw_lp" pos="9" access="rw" rst="0x0">
            <comment>Tranceiver power for LP MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vcam_lp" pos="8" access="rw" rst="0x0">
            <comment>Cameral power for LP MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vlcd_lp" pos="7" access="rw" rst="0x0">
            <comment>LCD power for LP MODE. 0: power on; 1: power off.
            </comment>
        </bits>  
        <bits name="Pu_vmc_lp" pos="6" access="rw" rst="0x1">
            <comment>SD/MMC power for LP MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vibr_lp" pos="5" access="rw" rst="0x0">
            <comment>vibrator power for LP MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vusb_lp" pos="4" access="rw" rst="0x1">
            <comment>USB power for LP MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_vmic_lp" pos="3" access="rw" rst="0x0">
            <comment>Microphone power for LP MODE. 0: power on; 1: power off.
            </comment>
        </bits> 
        <bits name="Pu_bl_led_lp" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Pu_spimem_lp" pos="1" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="Lp_mode_b_lp" pos="0" access="rw" rst="0x1">
            <comment>LDO Mode for LP MODE. 0: LP Mode; 1: Normal Mode.
            </comment>
        </bits>                                                                                          
    </reg>  
    <reg name="pmu_09H_LDO_LP_SETTING_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Vrtc_vbit_lp" pos="15:13" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits> 
        <bits name="Vio_vsel_lp" pos="12" access="rw" rst="0x0">
            <comment>VIO LDO voltage select. 0: 2.8V; 1: 1.8V..
            </comment>
        </bits> 
        <bits name="Vasw_vsel_lp" pos="11" access="rw" rst="0x0">
            <comment>RF LDO voltage select. 0: 2.8V; 1: 1.8V.
            </comment>
        </bits> 
        <bits name="Vcam_vsel_lp" pos="10" access="rw" rst="0x1">
            <comment>Cameral LDO voltage select. 0: 2.8V; 1: 1.8V.
            </comment>
        </bits> 
        <bits name="Vlcd_vsel_lp" pos="9" access="rw" rst="0x1">
            <comment>LCD LDO voltage select. 0: 2.8V; 1: 1.8V.
            </comment>
        </bits> 
        <bits name="Vmc_vsel_lp" pos="8" access="rw" rst="0x1">
            <comment>SD/MMC LDO voltage select. 0: 2.8V; 1: 1.8V.
            </comment>
        </bits> 
        <bits name="Vibr_vsel_lp" pos="7" access="rw" rst="0x1">
            <comment>Vibrator LDO voltage select. 0: 2.8V; 1: 1.8V.
            </comment>
        </bits>  
        <bits name="Pu_vrf28_lp" pos="6" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="Pu_vboost_lp" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Pu_buck2_lp" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Pfm_mode_sel_buck2_lp" pos="3" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="Pu_buck2_ldo_lp" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Pu_rgb_led_lp" pos="1" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="V_res_bit_lp" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                          
    </reg>  
    <reg name="pmu_0aH_LDO_LP_SETTING_3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Vbackup_vbit_lp" pos="14:12" access="rw" rst="0x4">
            <comment>Vmem LDO current control.
            </comment>
        </bits> 
        <bits name="Vspimem_ibit_lp" pos="11:9" access="rw" rst="0x7">
            <comment>Spi Memory current control.
            </comment>
        </bits> 
        <bits name="Vm_ibit_lp" pos="8:6" access="rw" rst="0x4">
            <comment>Vmem LDO current control.
            </comment>
        </bits> 
        <bits name="Vio_ibit_lp" pos="5:3" access="rw" rst="0x4">
            <comment>VIO LDO current control.
            </comment>
        </bits> 
        <bits name="pu_cp_lp" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Vrtc_dcdc1_en_lp" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
        <bits name="Vrtc_dcdc2_en_lp" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                       
    </reg>
    <reg name="pmu_0bH_LDO_LP_SETTING_4" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Va_cc_disable" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Vrgbled_cc_disabl" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Vibr_cc_disable" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Vusb_cc_disable" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Reserved" pos="11:4" access="rw" rst="0x92">
            <comment>
            </comment>
        </bits> 
        <bits name="Vrf28_vsel" pos="3" access="rw" rst="0x0">
            <comment>1:1.8V; 0: 2.8V;
            </comment>
        </bits> 
        <bits name="Vrf28_ibit" pos="2:0" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>                                                        
    </reg>  
    <reg name="pmu_0cH_LDO_LP SETTING_5" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Vsim0_vsel_lp" pos="15" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="Vsim1_vsel_lp" pos="14" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="Vsim2_vsel_lp" pos="13" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="Vsim3_vsel_lp" pos="12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="Vusb_ibit_lp" pos="11:9" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits> 
        <bits name="Reserved" pos="8:0" access="rw" rst="0x1e6">
            <comment>1:1.8V; 0: 2.8V;
            </comment>
        </bits>                                          
    </reg>  
    <reg name="pmu_0dH_LDO_POWER_ON_SETTING_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pu_buck3_act" pos="15" access="rw" rst="0x1">
            <comment>RTC LDO voltage. 0: 1.2V; 1: 1.6V.
            </comment>
        </bits> 
        <bits name="Pu_buck3_ldo_act" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Pfm_mode_sel_buck3_act" pos="13" access="rw" rst="0x1">
            <comment>Vcore DCDC power control in POWER_ON_MODE. 1 : power off; 0: power on.
            </comment>
        </bits> 
        <bits name="pu_buck4_act" pos="12" access="rw" rst="0x0">
            <comment>Memory LDO power control in POWER_ON_MODE. 1 : power off; 0: power on.
            </comment>
        </bits> 
        <bits name="Pu_buck4_ldo_act" pos="11" access="rw" rst="0x0">
            <comment>VIO LDO power control in POWER_ON_MODE. 1 : power off; 0: power on.
            </comment>
        </bits> 
        <bits name="Pfm_mode_sel_buck4_act" pos="10" access="rw" rst="0x0">
            <comment>ABB LDO power control in POWER_ON_MODE. 1 : power off; 0: power on.
            </comment>
        </bits>  
        <bits name="Pu_buck3_lp" pos="9" access="rw" rst="0x0">
            <comment>RF LDO power control in POWER_ON_MODE. 1 : power off; 0: power on.
            </comment>
        </bits>
        <bits name="Pu_buck3_ldo_lp" pos="8" access="rw" rst="0x0">
            <comment>Cameral LDO power control in POWER_ON_MODE. 1 : power off; 0: power on.
            </comment>
        </bits>
        <bits name="Pfm_mode_sel_buck3_lp" pos="7" access="rw" rst="0x0">
            <comment>LCD LDO power control in POWER_ON_MODE. 1 : power off; 0: power on.
            </comment>
        </bits>
        <bits name="Pu_buck4_lp" pos="6" access="rw" rst="0x0">
            <comment>SD/MMC LDO power control in POWER_ON_MODE. 1 : power off; 0: power on.
            </comment>
        </bits>
        <bits name="Pu_buck4_ldo_lp" pos="5" access="rw" rst="0x1">
            <comment>vibrator LDO power control in POWER_ON_MODE. 1 : power off; 0: power on.
            </comment>
        </bits>
        <bits name="Pfm_mode_sel_buck4_lp" pos="4" access="rw" rst="0x0">
            <comment>USB LDO power control in POWER_ON_MODE. 1 : power off; 0: power on.
            </comment>
        </bits> 
        <bits name="Reserved" pos="3:0" access="rw" rst="0xd">
            <comment>
            </comment>
        </bits>                                                                                                
    </reg>  
    <reg name="pmu_0eH_LDO_POWER_ON_SETTING_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pu_xtal" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Ck32k_xtal_clk_en" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Pu_lpo_32k" pos="13" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="Ck32k_lpo_clk_en" pos="12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="Ck32k_26mxtal_clk_en" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Reserved" pos="10:0" access="rw" rst="0x516">
            <comment>
            </comment>
        </bits>                                          
    </reg>            
    <reg name="pmu_0fH_LDO_POWER_ON_SETTING_3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Bg_chopper_en_b" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Bg_ref_sel" pos="14" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="Bg_res_tc_bit" pos="13:9" access="rw" rst="0xf">
            <comment>
            </comment>
        </bits> 
        <bits name="Bg_ts_i_ctrl" pos="8:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Bg_freq_bit" pos="4:3" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits> 
        <bits name="Reserved" pos="2:0" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>                                          
    </reg>    
    <reg name="pmu_10H_LDO_POWER_ON_SETTING_4" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Vs_sel_buck1" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Reserved" pos="14:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Asw_excap_en" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Cam_excap_en" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Io_excap_en" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Lcd_excap_en" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>   
        <bits name="Mem_excap_en" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Mc_excap_en" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Spimem_excap_en" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vrf28_excap_en" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Sim0_excap_en" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Sim1_excap_en" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Sim2_excap_en" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Sim3_excap_en" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                                       
    </reg>
    <reg name="pmu_11H_LDO_POWER_ON_SETTING_5" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Hp_detect" pos="6" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Hp_in" pos="5" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Hp_out" pos="4" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Clear_hp_in" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Clear_hp_out" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Hp_in_mask" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>         
        <bits name="Hp_out_mask" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                       
    </reg> 
    <reg name="pmu_12H_charger_setting_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Chr_always_cc" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Chr_cv_lowgain" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Chr_auxadc_sel" pos="13:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Chr_bypass_chopper" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Chr_chopper_clk_sel" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Uv_sel" pos="9:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>         
        <bits name="Bg_disable_chopper" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>   
        <bits name="Chr_disable_osc" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Chr_term_ctrl" pos="5:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Chr_cc_ictrl_en_highac" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="1:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                                                            
    </reg>   
    <reg name="pmu_13H_charger_setting_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Chr_cc_i_bit_dr" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Chr_pre_i_bit_dr" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Chr_vfb_sel_dr" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Chr_cc_i_bit_reg" pos="9:7" access="rw" rst="0x6">
            <comment>
            </comment>
        </bits> 
        <bits name="Chr_pre_i_bit_reg" pos="4:6" access="rw" rst="0x7">
            <comment>
            </comment>
        </bits>         
        <bits name="Chr_vfb_sel_reg" pos="3:0" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>                                                                                                              
    </reg>  
    <reg name="pmu_14H_Charger_status" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Over_temp" pos="15" access="ro" rst="0x0">
            <comment>1: temperature is higher than expected(threshold); 0: temperature is ok.
            </comment>
        </bits> 
        <bits name="Bg_pmu_cal_out" pos="14" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="13" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="12" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Penirq_b" pos="11" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Penirq_key_b" pos="10" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="sar_out" pos="9" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Chr_ac_on" pos="8" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Chr_bat_on" pos="7" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Low_bat" pos="6" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Chr_creg" pos="5" access="ro" rst="0x0">
            <comment>1: voltage is higher than 3V. 0: voltage is lower.
            </comment>
        </bits> 
        <bits name="Chr_vreg" pos="4" access="ro" rst="0x0">
            <comment>1: voltage is higher than 4.1V; 0: voltage is lower.
            </comment>
        </bits> 
        <bits name="Chr_term" pos="3" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Chr_lowac_4p6" pos="2" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Chr_highac_6v" pos="1" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Chr_highac_9v" pos="0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                             
    </reg>  
    <reg name="pmu_15H_charger_control" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Chr_enable_dr" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Chr_enable_reg" pos="14" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Chr_cc_mode_dr" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Chr_cc_mode_reg" pos="12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:7" access="rw" rst="0xc">
            <comment>
            </comment>
        </bits>
        <bits name="Chr_en_freq" pos="6:5" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Chr_en_duty_cycle" pos="4:3" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Bat_monitor_enable" pos="2" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Bat_monitor_time_delay" pos="1:0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                           
    </reg> 
    <reg name="pmu_16H_CALIBRATION_SETTING_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pmu_bgap_cal_bypass" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Vbat_over_3p2_bypass" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pmu_bgap_cal_clock_inv" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pmu_bgap_cal_polarity" pos="12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Lp_mode_bg_dr" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Lp_mode_bg_reg" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pre_chr_check_bypass" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_bgap_cal_dr" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_bgap_cal_reg" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>     
        <bits name="Bgap_cal_bit_dr" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>   
        <bits name="Bgap_cal_bit_reg" pos="5:0" access="rw" rst="0x20">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                         
    </reg> 
    <reg name="pmu_17H_CALIBRATION_SETTING_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pu_ts_battery" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Ts_i_ctrl_battery" pos="14:11" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="10:1" access="rw" rst="0x188">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_charge_ldo" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                     
    </reg> 
    <reg name="pmu_18H_MISC_CONTROL" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="15:12" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits> 
        <bits name="Pu_clk_32k_dr" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_clk_32k_reg" pos="10" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_clk_4m_dr" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>      
        <bits name="Pu_clk_4m_reg" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_ldo_avdd3_dr" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_ldo_avdd3_reg" pos="6" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Clk2m_ftun_bit" pos="5:3" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Ldo_avdd3_bit" pos="2:0" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                                       
    </reg>   
    <reg name="pmu_19H_LED_SETTING_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pwm_rgb_freq" pos="15:12" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits> 
        <bits name="Reserved" pos="11:10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pwm_bl_enable" pos="9" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pwm_rgb_pmu_mode" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>      
        <bits name="Dim_led_r_dr" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dim_led_r_reg" pos="6" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Dim_led_g_dr" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dim_led_g_reg" pos="4" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Dim_led_b_dr" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Dim_led_b_reg" pos="2" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits> 
        <bits name="Dim_bl_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Dim_bl_reg" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                                                               
    </reg>  
    <reg name="pmu_1aH_LED_SETTING_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="I_bit_bl_act" pos="15:12" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits> 
        <bits name="I_bit_bl_lp" pos="11:8" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_bl_act" pos="7" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_bl_lp" pos="6" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>      
        <bits name="Ix2_bl" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Hv_mode_bl" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Neg_sel_bl" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Former_mode_bl" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Former_mode_rgb" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Reserved" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                                              
    </reg> 
    <reg name="pmu_1bH_LED_SETTING_3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Pwm_bl_duty_cycle" pos="14:10" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Pwm_bl_freq" pos="9:6" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
        <bits name="Pwm_bl_freq_sel" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>      
        <bits name="Reserved" pos="4:0" access="rw" rst="0x1c">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                            
    </reg>   
    <reg name="pmu_1cH_AUDIO_CONTROL" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Meas_wait_clr_penirq" pos="15" access="rw" rst="0x0">
            <comment>0: if touch screen is touched, pmu will measure x value and y value automatically; 1: if touch screen is touched, pmu will wait bb to clear penirq, and then measure x and y values.
            </comment>
        </bits> 
        <bits name="Bypass_bb_read" pos="14" access="rw" rst="0x0">
            <comment>1: if bb do not read touch screen data, and if time is long enough, touch screen will repeat measurement; 0: touch screen will wait for bb to read, and without Repeating measurement.
            </comment>
        </bits>
        <bits name="Delay_before_samp_tsc" pos="13:12" access="rw" rst="0x2">
            <comment>Delay between opening x/y switch and ADC sampling. 2'b00: 0us; 2'b01: 2us; 2'b10: 4us; 2'b11: 8us.            
            </comment>
        </bits>
        <bits name="Pwm_clk_div2_enable" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>      
        <bits name="Timer_penirq_stable" pos="10:8" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Timer_int_to_x_sel" pos="7:5" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Timer_x_to_y_sel" pos="4:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Time_samp_pos_tsc" pos="2" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Time_samp_neg_tsc" pos="1" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>     
        <bits name="Reserved" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                                                               
    </reg> 
    <reg name="pmu_1dH_TOUCH_SCREEN_CONTROL" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Tsc_pn_swap_y" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Tsc_pn_swap_x" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Tsc_clk_div_en" pos="13" access="rw" rst="0x2">
            <comment>            
            </comment>
        </bits>
        <bits name="Reserved" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>      
        <bits name="Tsc_sar_sel_r" pos="11:10" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="Sar_vref_bit" pos="9:8" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="Wait_bb_read_timsel" pos="7:6" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="Sar_out_polarity" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Sar_adc_mode" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>     
        <bits name="Samp_clk_inv" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Conv_clk_inv" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Reserved" pos="1:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                                                                                
    </reg>   
    <reg name="pmu_1eH_TOUCH_SCREEN_RESULTS_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Tsc_x_value_valid" pos="10" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Tsc_x_value_bit" pos="9:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                                                                 
    </reg>    
    <reg name="pmu_1fH_TOUCH_SCREEN_RESULTS_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Tsc_y_value_valid" pos="10" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Tsc_y_value_bit" pos="9:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                                                                 
    </reg> 
    <reg name="pmu_20H_TOUCH_SCREEN_RESULTS_3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Gpadc_value_valid" pos="10" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Gpadc_value_bit" pos="9:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                                                                 
    </reg> 
    <reg name="pmu_21H_EFUSE_and_OTP_SETTING_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Efuse_sel_word_auto" pos="15:12" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits> 
        <bits name="Psub_clk_sleep_prd" pos="11:9" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>           
        <bits name="Psub_clk_awake_prd" pos="8:6" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc1_clk_enable_reg" pos="5" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc2_clk_enable_reg" pos="4" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc3_clk_enable_reg" pos="3" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>    
        <bits name="Dcdc4_clk_enable_reg" pos="2" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc5_clk_enable_reg" pos="1" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc6_clk_enable_reg" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                                                                                                          
    </reg>  
    <reg name="pmu_22H_EFUSE_and_OTP_SETTING_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Sw_pmos_ctrl_cp" pos="15:14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Sw_nmos_ctrl_cp" pos="15:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>           
        <bits name="Cp_osc_freq_sel" pos="11:10" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="Psub_en_cp" pos="9" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Hp_en_cp" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Spk_led_en_cp" pos="7" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>    
        <bits name="Vmax5v5_en_cp" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="5:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Lp_mode_dr" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>     
        <bits name="Lp_mode_reg" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_otp_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                                                                                                                     
    </reg>    
    <reg name="pmu_23H_EFUSE_and_OTP_SETTING_3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                                                                                             
    </reg>
    <reg name="pmu_24H_EFUSE_and_OTP_SETTING_4" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Efuse_out_read" pos="15:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                                                                                             
    </reg>
    <reg name="pmu_25H_EFUSE_and_OTP_SETTING_5" protect="rw">                                                                                                                                                                                                                                                                                              
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
    </reg>
    <reg name="pmu_26H_CLK GATE" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Chr_out_time_sel" pos="15:13" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Chr_ac_on_time_sel" pos="12:10" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Time_clk_4m_stable" pos="9:8" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="7:4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Timer_bb_resetn_sel" pos="3:2" access="rw" rst="0x2">
            <comment>Time between power_on_reset and resetn_bb. 00: 10ms; 01: 40ms; 10: 60ms; 11: 100ms.
            </comment>
        </bits>
        <bits name="Bypass_clk_32k_gate" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bypass_clk_4m_gate" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                                                                                                                                             
    </reg>   
     <reg name="pmu_27H_SPK CONTROL 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Delay_bit_cp" pos="15:14" access="rw" rst="0x11">
            <comment>
            </comment>
        </bits>
        <bits name="Vcp_out_bit" pos="13:10" access="rw" rst="0x1000">
            <comment>
            </comment>
        </bits>
        <bits name="Clk_sel_cp" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clg_det_out_pol" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clg_det_out_time" pos="7:6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vbp_ctrl_cp" pos="5:4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_cp_dr" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>    
        <bits name="Pu_cp_reg" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>        
        <bits name="Bypass_cp_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>        
        <bits name="Bypass_cp_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                                                                                                                                                                                                                                                                                                                                                 
    </reg>     
    <reg name="pmu_28H_SIM INTERFACE ACT" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pu_vsim0_act" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vsim1_act" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vsim2_act" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vsim3_act" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim0_ibit_act" pos="11:9" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim1_ibit_act" pos="8:6" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim2_ibit_act" pos="5:3" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim3_ibit_act" pos="2:0" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>                   
        </reg>     
        <reg name="pmu_29H_SIM INTERFACE LP" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pu_vsim0_lp" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vsim1_lp" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vsim2_lp" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vsim3_lp" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim0_ibit_lp" pos="11:9" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim1_ibit_lp" pos="8:6" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim2_ibit_lp" pos="5:3" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim3_ibit_lp" pos="2:0" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>                   
        </reg>       
        <reg name="pmu_2aH_BUCK BIT 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Vbuck3_bit_act" pos="15:12" access="rw" rst="0x1010">
            <comment>
            </comment>
        </bits>
        <bits name="Vbuck3_bit_lp" pos="11:8" access="rw" rst="0x1010">
            <comment>
            </comment>
        </bits>
        <bits name="Vbuck4_bit_act" pos="7:4" access="rw" rst="0x0101">
            <comment>
            </comment>
        </bits>
        <bits name="Vbuck4_bit_lp" pos="3:0" access="rw" rst="0x0101">
            <comment>
            </comment>
        </bits> 
        </reg>   
         <reg name="pmu_2bH_SIM INTERFACE" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pu_vsim0" pos="15" access="rO" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vsim1" pos="14" access="rO" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vsim2" pos="13" access="rO" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vsim3" pos="12" access="rO" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim0_ibit" pos="11:9" access="rO" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim1_ibit" pos="8:6" access="rO" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim2_ibit" pos="5:3" access="rO" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim3_ibit" pos="2:0" access="rO" rst="0x0">
            <comment>
            </comment>
        </bits>                   
        </reg> 
        <reg name="pmu_2cH_BT FM POWER" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pa_on_bypass" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Transc_resetn_time_sel" pos="13:12" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Abb_resetn_time_sel" pos="11:10" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_transc_dr" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_transc_reg" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_abb_dr" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_abb_reg" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>    
        <bits name="Reserved" pos="5:4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
        <bits name="Pu_fm_dr" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
        <bits name="Pu_fm_reg" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
        <bits name="Pu_bt_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
        <bits name="Pu_bt_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>                
        </reg>
        <reg name="pmu_2dH_BUCK SETTING 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Vbuck1_ldo_bit" pos="15:13" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_mode_clk_prd_buck1" pos="12:11" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_clk_disable_buck1_dr" pos="10" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_clk_disable_buck1_reg" pos="9" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Counter_disable_buck1" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_buck1_threshold" pos="7:6" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Osc_freq_buck1" pos="5:4" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Low_sense_buck1" pos="3:2" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>    
        <bits name="Heavy_load_buck1" pos="1" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>  
        <bits name="antiring_disable_buck1" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>             
        </reg>
        <reg name="pmu_2eH_BUCK SETTING 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Vbuck2_ldo_bit" pos="15:13" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_mode_clk_prd_buck2" pos="12:11" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_clk_disable_buck2_dr" pos="10" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_clk_disable_buck2_reg" pos="9" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Counter_disable_buck2" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_buck2_threshold" pos="7:6" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Osc_freq_buck2" pos="5:4" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Low_sense_buck2" pos="3:2" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>    
        <bits name="Heavy_load_buck2" pos="1" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>  
        <bits name="antiring_disable_buck2" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>             
        </reg>
        <reg name="pmu_2fH_BUCK SETTING 3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Vbuck1_bit_act" pos="15:12" access="rw" rst="0x1010">
            <comment>
            </comment>
        </bits>
        <bits name="Vbuck1_bit_lp" pos="11:8" access="rw" rst="0x1010">
            <comment>
            </comment>
        </bits>
        <bits name="Vbuck2_bit_act" pos="7:4" access="rw" rst="0x0101">
            <comment>
            </comment>
        </bits>
        <bits name="Vbuck2_bit_lp" pos="3:0" access="rw" rst="0x0101">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_30H_BUCK SETTING 4" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Register_resetn" pos="15" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_buck3" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_mode_sel_buck3" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_buck3_ldo" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_buck4" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_mode_sel_buck4" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_buck4_ldo" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ref_ok_buck1" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>    
        <bits name="Ref_ok_buck2" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
            <bits name="Ref_ok_buck3" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
            <bits name="Ref_ok_buck4" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="4:1" access="rw" rst="0x0000">
            <comment>
            </comment>
        </bits>  
           <bits name="Soft_resetn" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>             
        </reg>
        <reg name="pmu_31H_POWER STATUS 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pu_buck" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_mode_sel_buck1" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_buck1_ldo" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vm" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vio" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_va" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vasw" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vcam" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>    
        <bits name="Pu_vlcd" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
            <bits name="Pu_vmc" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
            <bits name="Pu_vibr" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vusb" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
           <bits name="Pu_vmic" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_bl_led" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_spimem" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Lp_mode_b" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>             
        </reg>
        <reg name="pmu_32H_POWER STATUS 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Vrtc_vbit" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vio_vsel" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vasw_vsel" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vcam_vsel" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vlcd_vsel" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vmc_vsel" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vibr_vsel" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_vrf28" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>    
        <bits name="Pu_vboost" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
          <bits name="Pu_buck2" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
            <bits name="Pfm_mode_sel_buck2" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
            <bits name="Pu_buck2_ldo" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
           <bits name="pu_rgb_led" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>       
        </reg>
        <reg name="pmu_33H_RTC SETTING 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pu_bl" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vbackup_vbit" pos="14:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vspimem_ibit" pos="11:9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vm_ibit" pos="8:6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vio_ibit" pos="5:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vrtc_dcdc1_en" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vrtc_dcdc2_en" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>    
        </reg>
        <reg name="pmu_34H_CHARGER CLOCK" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Chopper_bg_4m_26m_sel" pos="15" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Chp_clk_bg_s4m_sel" pos="14:13" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Chp_clk_bg_s26m_sel" pos="12:11" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Chopper_chr_4m_26m_sel" pos="10" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Chp_clk_chr_s4m_sel" pos="9:8" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Chp_clk_chr_s26m_sel" pos="7:6" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="5:0" access="rw" rst="0x001110">
            <comment>
            </comment>
        </bits>   
        </reg>
        <reg name="pmu_35H_ POWER STATUS 3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="i_bit_bl" pos="15:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vusb_ibit" pos="11:9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_led_r" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_led_g" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_led_b" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="5:4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim0_vsel" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim1_vsel" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim2_vsel" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vsim3_vsel" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
        </reg>
        <reg name="pmu_36H_BUCK SETTING 5" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pu_bg_ts" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_thermo_protect" pos="14" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Thermo_sel" pos="13:12" access="rw" rst="0x11">
            <comment>
            </comment>
        </bits>
        <bits name="Calmode_en_bg_cal" pos="11" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Calmode_en_bg_noncal" pos="10" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Chr_calmode_en_bg_reg" pos="9" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Buck_heave_load" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vout_sel_buck1_lp" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vout_sel_buck2_lp" pos="6" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Vout_sel_buck3_lp" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Vout_sel_buck4_lp" pos="4" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Vout_sel_buck1_act" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
         <bits name="Vout_sel_buck2_act" pos="2" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
         <bits name="Vout_sel_buck3_act" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
         <bits name="Vout_sel_buck4_act" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_37H_BT FM SETTING 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Resetn_tsc_dr" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_tsc_reg" pos="14" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_bb_dr" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_bb_reg" pos="12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_bgap_dr" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_bgap_reg" pos="10" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Over_temp_bypass" pos="9" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bt_resetn_time_sel" pos="7:6" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_bt_dr" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_bt_reg" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Fm_resetn_time_sel" pos="3:2" access="rw" rst="0x101">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_fm_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
         <bits name="Resetn_fm_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_38H_LED SETTING 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pwm_r_duty_cycle" pos="15:11" access="rw" rst="0x10000">
            <comment>
            </comment>
        </bits>
        <bits name="Pwm_g_duty_cycle" pos="10:6" access="rw" rst="0x10000">
            <comment>
            </comment>
        </bits>
        <bits name="Pwm_b_duty_cycle" pos="5:1" access="rw" rst="0x10000">
            <comment>
            </comment>
        </bits>
        <bits name="Vclg_bit_dr" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        </reg>
         <reg name="pmu_39H_BUCK SETTING 6" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Discharge_enb_buck1" pos="15" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Discharge_enb_buck2" pos="14" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Discharge_enb_buck3" pos="13" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Discharge_enb_buck4" pos="12" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:8" access="rw" rst="0x0101">
            <comment>
            </comment>
        </bits>
        <bits name="Gpadc_chn_sel" pos="7:0" access="rw" rst="0x0000_0000">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_3aH_GPADC SETTING 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Gpadc_start_phase_sel" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Gpadc_eoc_phase_sel" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Samp_clk_inv_gpadc" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Conv_clk_inv_gpadc" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Sar_adc_mode_gpadc" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Sar_out_polarity_gpadc" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Delay_before_samp_gpadc" pos="9:8" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="7:6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Time_samp_pos_gpadc" pos="5" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Time_samp_neg_gpadc" pos="4" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Gpadc_start_dr" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Gpadc_start_reg" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_gpadc_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_gpadc_reg" pos="0" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>        
        </reg>
        <reg name="pmu_3bH_GPADC SETTING 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Gpadc_start_time_sel" pos="15:13" access="rw" rst="0x100">
            <comment>Period of gpadc sample 000: 125us 001: 1ms 010: 8ms 011: 128ms 100: 250ms 101: 500ms 110: 1s 111: 2s
            </comment>
        </bits>
        <bits name="Gpadc_clk_div_en" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Timer_sar_stable_sel " pos="11:9" access="rw" rst="0x010">
            <comment>
            </comment>
        </bits>
        <bits name="Gpadc_en _reg" pos="8:1" access="rw" rst="0x0000_0000">
            <comment>
            </comment>
        </bits>
        <bits name="Gpadc_en_dr" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_3cH_POWER TIMER 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Vcore_pon_time_sel" pos="15:14" access="rw" rst="0x00">
            <comment>
            </comment>
        </bits>
        <bits name="Vcore_poff_time_sel" pos="13:12" access="rw" rst="0x11">
            <comment>
            </comment>
        </bits>
        <bits name="Vio_pon_time_sel" pos="11:10" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Vio_poff_time_sel" pos="9:8" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Vmem_pon_time_sel" pos="7:6" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Vmem_poff_time_sel" pos="5:4" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Vother1_pon_time_sel" pos="3:2" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Vother1_poff_time_sel" pos="1:0" access="rw" rst="0x00">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_3dH_POWER TIMER 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Vother2_pon_time_sel" pos="15:14" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Vother2_poff_time_sel" pos="13:12" access="rw" rst="0x00">
            <comment>
            </comment>
        </bits>
        <bits name="Timer_thermo_check" pos="11:9" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="8:6" access="rw" rst="0x010">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_dvdd_transc" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_dvdd_abb" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_dvdd_fm" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_dvdd_bt" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Lv_detect_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Lv_detect_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_3eH_LED SETTING 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Gbit_abb_enable" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_led_r_act" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_led_g_act" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_led_b_act" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_led_r_lp" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_led_g_lp" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_led_b_lp" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="I_bit_r" pos="8:6" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="I_bit_g" pos="5:3" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="I_bit_b" pos="2:0" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_3fH_SPK SETTING 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Double_en_clg" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Interface_mode_en_clg" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved_analog" pos="13:0" access="rw" rst="0x11_0000_1111_0011">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_40H_SPK SETTING 3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="I_bit_clg" pos="15:14" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Gbit_l_clg_reg" pos="13:11" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="Gbit_r_clg_reg" pos="10:8" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="Vncn_bit" pos="7:6" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Vclg_bit_reg" pos="5:3" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="No_detect_en" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ncn_en_l" pos="1" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Ncn_en_r" pos="0" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_41H_SPK SETTING 4" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reset_clg_delay_pos" pos="15:14" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_clg_delay_neg" pos="13:12" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Other_delay_pos" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Other_delay_neg" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="L_enable_clg" pos="9" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="R_enable_clg" pos="8" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Test_p_cp" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Test_n_cp" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Mono_l_r_sel" pos="5" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Dmode_en_clg" pos="4:2" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="Setup_tmctrl_bit" pos="1:0" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_42H_SPK SETTING 5" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pu_clg_dr" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_clg_reg" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_l_clg_dr" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_l_clg_reg" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_o_l_clg_dr" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_o_l_clg_reg" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_r_clg_dr" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_r_clg_reg" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
       <bits name="Pu_o_r_clg_dr" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_o_r_clg_reg" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_clg_dr" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_clg_reg" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_l_clg_dr" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_l_clg_reg" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_r_clg_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_r_clg_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_43H_SPK SETTING 6" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Clg_l_det_out_h" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clg_r_det_out_h" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Iov_l_det_out" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Iov_r_det_out" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ncn_l_det_out" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ncn_r_det_out" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clg_l_det_out" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clg_r_det_out" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
         </reg>
        <hole size="2*32" />
         <reg name="pmu_46H_TSC KEY SETTING" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pu_tsc_int_dr" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_tsc_int_reg" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_tsc_x_dr" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_tsc_x_reg" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_tsc_y_dr" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_tsc_y_reg" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Key_int_en_dr" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Key_int_en_reg" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Key_en_dr" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Key_en_reg" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Tsc_enable_ana_dr" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Tsc_enable_ana_reg" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_sar_dr" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_sar_reg" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Sar_vref_ms_enable_tsc" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Sar_vref_ms_enable_gpadc" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        </reg>
        <hole size="3*32" />
         <reg name="pmu_4aH_BUCK SETTING 7" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Vbuck3_ldo_bit" pos="15:13" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_mode_clk_prd_buck3" pos="12:11" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_clk_disable_buck3_dr" pos="10" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_clk_disable_buck3_reg" pos="9" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Counter_disable_buck3" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_buck3_threshold" pos="7:6" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Osc_freq_buck3" pos="5:4" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Low_sense_buck3" pos="3:2" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Heavy_load_buck3" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Antiring_disable_buck3" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_4bH_BUCK SETTING 8" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Vbuck4_ldo_bit" pos="15:13" access="rw" rst="0x100">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_mode_clk_prd_buck4" pos="12:11" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_clk_disable_buck4_dr" pos="10" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_clk_disable_buck4_reg" pos="9" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Counter_disable_buck4" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pfm_buck4_threshold" pos="7:6" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Osc_freq_buck4" pos="5:4" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Low_sense_buck4" pos="3:2" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Heavy_load_buck4" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Antiring_disable_buck4" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_4cH_BUCK SETTING 9" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Low_vbat_buck1" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Low_vbat_buck2" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Low_vbat_buck3" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Low_vbat_buck4" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Cc_disable_buck1_ldo" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Nonov_delay_buck1" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_soft_start_buck1" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Cc_disable_buck2_ldo" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Nonov_delay_buck2" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_soft_start_buck2" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Cc_disable_buck3_ldo" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Nonov_delay_buck3" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_soft_start_buck3" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Cc_disable_buck4_ldo" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Nonov_delay_buck4" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_soft_start_buck4" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        </reg>
        <hole size="3*32" />
        <reg name="pmu_50H_EFUSE SETTING 4" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Efuse_sel" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_51H_EFUSE SETTING 5" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Efuse_ref_res_bit" pos="9:8" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Efuse_sense_en_dr" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Efuse_sense_en_reg" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Efuse_sense_dr" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Efuse_sense_reg" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Efuse_sel_word_reg" pos="3:0" access="rw" rst="0x0000">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="pmu_52H_EFUSE SETTING 6" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Efuse_out" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        </reg>
</module>
</archive>

<archive relative='abb.xml' >


<module name="abb_page0" category="added_func">
    <reg name="PLL_Settings_000" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="undefine" pos="15" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Page" pos="14:12" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="undefine" pos="11:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_Settings_001" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_clkout_en" pos="14:13" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpaux_bit" pos="12:10" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_filter_ibit" pos="9:7" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cp_bit" pos="6:4" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_vreg_bit" pos="3:0" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_Settings_002" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_reserved" pos="12:9" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_refmulti2_en" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_high_test" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_low_test" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_test_en" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_sdm_clk_test_en" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_sdm_clk_sel_rst" pos="3" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_sdm_clk_sel_nor" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_Settings_003" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Refbuf_vreg_bit" pos="15:0" access="rw" rst="0x72e3">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_Settings_004" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pu_pll" pos="15" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_lock" pos="14" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_sdm_resetn" pos="13" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_sdm_clk_sel" pos="12" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="undefine" pos="11:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_Settings_005" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_sdm_freq" pos="15:0" access="rw" rst="0x24ec">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_Settings_006" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_sdm_freq" pos="15:2" access="rw" rst="0x40">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="1:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_Settings_007" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved_sdm" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_dec_sel" pos="7:5" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits>
        <bits name="Dither_bypass" pos="4" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Ss_en" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ss_squre_tri_sel" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_sdm_resetn_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_sdm_resetn_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_Settings_008" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_ss_devi_ct" pos="15:8" access="rw" rst="0x00">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ss_peri_ct" pos="7:0" access="rw" rst="0x00">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_Settings_009" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:0" access="rw" rst="0x7100">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_Settings_00a" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Sdm_reset_time_sel" pos="15:14" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Sdmclk_sel_time_sel" pos="13:12" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:1" access="rw" rst="0x000">
            <comment>
            </comment>
        </bits>
        <bits name="Clk_gen_en_reg" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>
</module>


<module name="abb_page1" category="added_func">
    <reg name="CHIP ID_040" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="ChipID" pos="15:4" access="ro" rst="0xABB">
            <comment>ABB chip ID.
            </comment>
        </bits>
        <bits name="RevID" pos="3:0" access="ro" rst="0x0">
            <comment>Revision ID.
            </comment>
        </bits>
    </reg>
    <reg name=" SIMCARD_041" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Sim_select" pos="15:14" access="rw" rst="0x0">
            <comment>00: sim1 channel is selected; 01: sim2 channel is selected; 10: sim1 channel is selected; 11: sim2 channel is selected;
            </comment>
        </bits>
        <bits name="Reserved" pos="13:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pullup_enable_1" pos="11" access="rw" rst="0x0">
            <comment>1: sim1_io is LOW Voltage; 0: sim1_io is HIGH Voltage.
            </comment>
        </bits>
        <bits name="Unsel_clk_val_1" pos="10" access="rw" rst="0x0">
            <comment>0: sim1_clk is LOW Voltage; 1: sim1_clk is HIGH Voltage.
            </comment>
        </bits>
        <bits name="Unsel_rst_val_1" pos="9" access="rw" rst="0x0">
            <comment>0: sim1_rst is LOW Voltage; 1: sim1_rst is HIGH Voltage.
            </comment>
        </bits>
        <bits name="Pullup_enable_2" pos="8" access="rw" rst="0x0">
            <comment>1: sim2_io is LOW Voltage;0: sim2_io is HIGH Voltage.
            </comment>
        </bits>
        <bits name="Unsel_clk_val_2" pos="7" access="rw" rst="0x0">
            <comment>0: sim2_clk is LOW Voltage; 1: sim2_clk is HIGH Voltage.
            </comment>
        </bits>
        <bits name="Unsel_rst_val_2" pos="6" access="rw" rst="0x0">
            <comment>0: sim2_rst is LOW Voltage; 1: sim2_rst is HIGH Voltage.
            </comment>
        </bits>
        <bits name="Pullup_enable_3" pos="5" access="rw" rst="0x0">
            <comment>1: sim1_io is LOW Voltage; 0: sim1_io is HIGH Voltage.
            </comment>
        </bits>
        <bits name="Unsel_clk_val_3" pos="4" access="rw" rst="0x0">
            <comment>0: sim1_clk is LOW Voltage; 1: sim1_clk is HIGH Voltage.
            </comment>
        </bits>

        <bits name="Unsel_rst_val_3" pos="3" access="rw" rst="0x0">
            <comment>0: sim1_rst is LOW Voltage; 1: sim1_rst is HIGH Voltage.
            </comment>
        </bits>
        <bits name="Pullup_enable_4" pos="2" access="rw" rst="0x0">
            <comment>1: sim2_io is LOW Voltage; 0: sim2_io is HIGH Voltage.
            </comment>
        </bits>
        <bits name="Unsel_clk_val_4" pos="1" access="rw" rst="0x0">
            <comment>0: sim2_clk is LOW Voltage; 1: sim2_clk is HIGH Voltage.
            </comment>
        </bits>
        <bits name="Unsel_rst_val_4" pos="0" access="rw" rst="0x0">
            <comment>0: sim2_rst is LOW Voltage; 1: sim2_rst is HIGH Voltage.
            </comment>
        </bits>
    </reg>

    <reg name="CODEC_settings_1_042" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Codec_control_by_abb" pos="15" access="rw" rst="0x0">
            <comment>0: codec control from dbb pin; 1: codec control through SPI
            </comment>
        </bits>
        <bits name="Au_deep_pu_reg" pos="14" access="rw" rst="0x0">
            <comment>1: power up all codec analog module
            </comment>
        </bits>
        <bits name="Au_ref_pu_reg" pos="13" access="rw" rst="0x0">
            <comment>1: power up codec reference module for codec analog module;
            </comment>
        </bits>
        <bits name="Au_mic_pu_reg" pos="12" access="rw" rst="0x0">
            <comment>1: power up MIC
            </comment>
        </bits>
        <bits name="Au_ad_pu_reg" pos="11" access="rw" rst="0x0">
            <comment>1: power up ADC.
            </comment>
        </bits>
        <bits name="Au_dac_pu_reg" pos="10" access="rw" rst="0x0">
            <comment>1: power up DAC.
            </comment>
        </bits>
        <bits name="Au_auxmic_sel_reg" pos="9" access="rw" rst="0x0">
            <comment>1: select AUX MIC; 0: select MIC.
            </comment>
        </bits>
        <bits name="Au_auxmic_pu_reg" pos="8" access="rw" rst="0x0">
            <comment>1: power up AUX MIC.
            </comment>
        </bits>
        <bits name="Au_mic_gain_reg" pos="7:4" access="rw" rst="0x0">
            <comment>MIC gain control.
            </comment>
        </bits>
        <bits name="Au_mic_mute_n_reg" pos="3" access="rw" rst="0x0">
            <comment>0: mute MIC; 1: don't mute MIC.
            </comment>
        </bits>
        <bits name="Au_spk_sel_reg" pos="2" access="rw" rst="0x0">
            <comment>1: select speaker PA.
            </comment>
        </bits>
        <bits name="Au_rcv_sel_reg" pos="1" access="rw" rst="0x0">
            <comment>1: select Receiver PA.
            </comment>
        </bits>
        <bits name="Au_head_sel_reg" pos="0" access="rw" rst="0x0">
            <comment>1: select headphone PA.
            </comment>
        </bits>
    </reg>
    <reg name="CODEC_settings_2_043" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Au_fm_sel_reg" pos="15" access="rw" rst="0x0">
            <comment>1: select FM output,
            </comment>
        </bits>
        <bits name="Au_spk_mono_sel_reg" pos="14" access="rw" rst="0x0">
            <comment>1: SPK use mono mode.
            </comment>
        </bits>
        <bits name="Au_spk_mute_n_reg" pos="13" access="rw" rst="0x0">
            <comment>1: don't mute SPK; 0: mute SPK.
            </comment>
        </bits>
        <bits name="Au_dac_reset_n_reg" pos="12" access="rw" rst="0x0">
            <comment>1: don't reset DAC; 0: reset DAC.
            </comment>
        </bits>
        <bits name="Au_spk_gain_reg" pos="11:8" access="rw" rst="0x8">
            <comment>SPK gain control.
            </comment>
        </bits>
        <bits name="Au_rcv_gain_reg" pos="7:4" access="rw" rst="0x8">
            <comment>Receiver gain control.
            </comment>
        </bits>
        <bits name="Au_head_gain_reg" pos="3:0" access="rw" rst="0x8">
            <comment>Headphone gain control.
            </comment>
        </bits>
    </reg>
    <reg name="USB_control_044" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ssi_vrefn_rbit" pos="15:14" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="Ssi_vrefp_rbit" pos="13:12" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="padet_ibit" pos="11:9" access="rw" rst="0x4">
            <comment>1: don't mute SPK; 0: mute SPK.
            </comment>
        </bits>
        <bits name="padet_clk_sel" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="pu_lpo_codec" pos="7" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="6:5" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_refbuff" pos="4" access="rw" rst="0x1">
            <comment>Headphone gain control.
            </comment>
        </bits>
        <bits name="Pll_refbuff_vreg_bit" pos="3:0" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="MIC_045" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Mb_sel_bit_l" pos="15:14" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="Mic_chop_en_l" pos="13" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Mic_hpf_mode_en_l" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Miccapless_mode_enb_l" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Test_en_adc_l" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Mash_en_adc_l" pos="9" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Mic_com_mode_l" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="7:0" access="rw" rst="0x05">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="AUDIO ANA_1_046" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Boost_bp_mic_r_dr" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Boost_bp_mic_r_reg" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Mcpga_gain_bit_r_dr" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Mcpga_gain_bit_r_reg" pos="12:10" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="9:8" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_bg_dr" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_bg_reg" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_en_adc_l_dr" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_en_adc_l_reg" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_en_adc_r_dr" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_en_adc_r_reg" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Boost_bp_mic_l_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Boost_bp_mic_l_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="AUDIO ANA_2_047" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Mcpga_gain_bit_l_dr" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Mcpga_gain_bit_l_reg" pos="14:12" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Reci_gain_bit_dr" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reci_gain_bit_reg" pos="10:8" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Hp_gain_bit_dr" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Hp_gain_bit_reg" pos="6:4" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Spk_gain_bit_dr" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Spk_gain_bit_reg" pos="2:0" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="AUDIO ANA_3_048" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Hp_rcv_mute_enable" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="14:4" access="rw" rst="0x399">
            <comment>
            </comment>
        </bits>
        <bits name="Adc_pu_sel_adc" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Mic_to_pa_mode" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Linein_to_mic_mode" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Linein_to_pa_mode" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="AUDIO_ANA_4_049" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pu_all_dr" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_all_reg" pos="14" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_adc_l_dr" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_adc_l_reg" pos="12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_adc_r_dr" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_adc_r_reg" pos="10" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_dac_l_dr" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_dac_l_reg" pos="8" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_dac_r_dr" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_dac_r_reg" pos="6" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pa_en_reci_dr" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pa_en_reci_reg" pos="4" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pa_en_hp_dr" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pa_en_hp_reg" pos="2" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_mux_en_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_mux_en_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="AUDIO_ANA_5_04a" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Vcom_mode" pos="15:13" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="Vref_mode" pos="12:10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Isel_bit_b" pos="9:8" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="Sel_bg" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="6:4" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits>
        <bits name="Classg_enable_dr" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Classg_enable_reg" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_sip_mux_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_sip_mux_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="AUDIO_ANA_6_04b" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved_analog" pos="15:10" access="rw" rst="0x38">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="9:3" access="rw" rst="0x70">
            <comment>
            </comment>
        </bits>
        <bits name="Test_en_spk" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Double_mode_en" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Syn_en_dac" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="AUDIO_ANA_7_04c" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dac_l_enable" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dac_r_enable" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Micdac_mode_en" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dac_mode_l_en" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dac_mode_r_en" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Line_mode_en" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Wifi_mode_en" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reci_dac_en" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reci_linein_en" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Hp_vcom_sel" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="5:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name=" CODEC_CALIBRATION_setting_04d" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:9" access="rw" rst="0xf0">
            <comment>
            </comment>
        </bits>
        <bits name="Cal_bypass" pos="8" access="rw" rst="0x0">
            <comment>1: bypass codec reference calibration; 0: do codec reference calibration.
            </comment>
        </bits>
        <bits name="Resetn_cal_dr" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Resetn_cal_reg" pos="6" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Cal_out_polartiy" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Cal_clk_inv" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Cal_bit_dr" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Cal_bit_reg" pos="2:0" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="POWER_CONTROL_04e" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reset_mic_l_dr" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_mic_l_reg" pos="14" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_mic_r_dr" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_mic_r_reg" pos="12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_pa_reci_dr" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_pa_reci_reg" pos="10" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_pa_hp_dr" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_pa_hp_reg" pos="8" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_pa_spk_dr" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_pa_spk_reg" pos="6" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Rstn_codec_dr" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Rstn_codec_reg" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Adc_en_codec_dr" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Adc_en_codec_reg" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dac_en_codec_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dac_en_codec_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="CLKGEN_1_04f" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dssi_inv" pos="15" access="rw" rst="0x1">
            <comment>Reset register file; 0: reset;
            </comment>
        </bits>
        <bits name="Ph_sel_ct_clkgen1" pos="14:12" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="Ph_sel_ct_clkgen2" pos="11:9" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="Ph_sel_ct_clkgen3" pos="8:6" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="Ph_sel_ct_clkgen4" pos="5:3" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="Ph_sel_ct_clkgen5" pos="2:0" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="AUDIO_ANA_8_050" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Adc_l_enable" pos="15" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Adc_r_enable" pos="14" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Mic_std_en_l" pos="13" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Mic_aux_en_l" pos="12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Micin_ibpga_en_l" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Muxin_left_en_l" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Muxin_right_en_l" pos="9" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Mic_std_en_r" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Micin_ibpga_en_r" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="6:0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="AUDIO_ANA_9_051" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Mb_sel_bit_r" pos="15:14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Mic_chop_en_r" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Mic_hpf_mode_en_r" pos="12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Miccapless_mode_enb_r" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Test_en_adc_r" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Mash_en_adc_r" pos="9" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="8:0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="AUDIO_ANA_10_052" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pu_ssi" pos="15" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Dssi_ana_enable" pos="14" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Dssi_stable_time_sel" pos="13:12" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Dssi_lg_en_time_sel" pos="11:10" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Spk_gain_sel_inv" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Spk_lowgain_en_l_dr" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Spk_lowgain_en_l_reg" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Spk_lowgain_en_r_dr" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Spk_lowgain_en_r_reg" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Padet_en" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_padet_time_sel" pos="3:2" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_padet_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reset_padet_reg" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_AUX_1_053" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_clkout_en" pos="13:12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_cpaux_bit" pos="11:9" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_filter_ibit" pos="8:6" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_cp_bit" pos="5:3" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_int_mode" pos="2" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_sdm_clk_sel_rst" pos="1" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_sdm_clk_sel_nor" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_AUX_2_054" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_aux_sdm_clk_test_en" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_refmulti2_en" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_vco_high_test" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_vco_low_test" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_test_en" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_vreg_bit" pos="10:7" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_aux_dr" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_aux_reg" pos="5" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="4:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_pu" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="SDM_1_055" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm1_freq" pos="11:0" access="rw" rst="0x800">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="SDM_2_056" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Bbpll_sdm1_freq" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="SDM_3_057" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Bbpll_sdm1_int_dec_sel" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm1_dither_bypass" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm1_ss_en" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm1_ss_squre_tri_sel" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm1_reserved" pos="9:2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm1_resetn_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm1_resetn_reg" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="SDM_4_058" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Bbpll_sdm1_ss_devi_ct" pos="15:8" access="rw" rst="0x80">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm1_ss_peri_ct" pos="7:0" access="rw" rst="0x80">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_1_059" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_clkout_en" pos="13:12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpaux_bit" pos="11:9" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_filter_ibit" pos="8:6" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cp_bit" pos="5:3" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_int_mode" pos="2" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_sdm_clk_sel_rst" pos="1" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_sdm_clk_sel_nor" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_2_05a" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_sdm_clk_test_en" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_refmulti2" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_vco_high_test" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_vco_low_test" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_test_en" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_vreg_bit" pos="10:7" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_dr" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_reg" pos="5" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="4:0" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_3_05b" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:12" access="rw" rst="0x20">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm2_freq" pos="11:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_4_05c" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Bbpll_sdm2_freq" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_5_05d" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Bbpll_sdm2_int_dec_sel" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm2_dither_bypass" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm2_ss_en" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm2_ss_squre_tri_sel" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm2_reserved" pos="9:2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm2_resetn_dr" pos="1" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm2_resetn_reg" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_6_05e" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Bbpll_sdm2_ss_devi_ct" pos="15:8" access="rw" rst="0x80">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm2_ss_peri_ct" pos="7:0" access="rw" rst="0x80">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_7_05f" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Codec_en_codec" pos="15" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Isphone_codec" pos="14" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="13:7" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_lock" pos="6" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_aux" pos="5" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm1_resetn" pos="4" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="3" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_lock" pos="2" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll" pos="1" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Bbpll_sdm2_resetn" pos="0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="CLKGEN_2_060" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="dcdc_clkgen1_div_base" pos="15:4" access="rw" rst="0xdc">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen1_dither_ct" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen1_clk_sel" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="CLKGEN_3_061" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="dcdc_clkgen2_div_base" pos="15:4" access="rw" rst="0xdc">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen2_dither_ct" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen2_clk_sel" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="CLKGEN_4_062" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="dcdc_clkgen3_div_base" pos="15:4" access="rw" rst="0xdc">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen3_dither_ct" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen3_clk_sel" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="CLKGEN_5_063" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="dcdc_clkgen4_div_base" pos="15:4" access="rw" rst="0xdc">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen4_dither_ct" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen4_clk_sel" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="CLKGEN_6_064" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="dcdc_clkgen5_div_base" pos="15:4" access="rw" rst="0xdc">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen5_dither_ct" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen5_clk_sel" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="CLKGEN_7_065" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="ph_sel_ct_clkgen6" pos="14:12" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen1_time_sel" pos="11:10" access="rw" rst="0x2">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen2_time_sel" pos="9:8" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen3_time_sel" pos="7:6" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen4_time_sel" pos="5:4" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen5_time_sel" pos="3:2" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen6_time_sel" pos="1:0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="CLKGEN_8_066" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen1_resetn_dr" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen1_resetn_reg" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen2_resetn_dr" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen2_resetn_reg" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen3_resetn_dr" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen3_resetn_reg" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen4_resetn_dr" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen4_resetn_reg" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen5_resetn_dr" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen5_resetn_reg" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen6_resetn_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dcdc_clkgen6_resetn_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="CLKGEN_9_067" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:8" access="rw" rst="0x0f">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_sdm_resetn_time" pos="7:6" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_sdm_clksel_time" pos="5:4" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_sdm_resetn_time" pos="3:2" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_aux_sdm_clksel_time" pos="1:0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="CLKGEN_10_068" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen1_phase_sel" pos="13:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen1_clk_swch" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen2_phase_sel" pos="6:1" access="rw" rst="0x08">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen2_clk_swch" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="CLKGEN_11_069" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen3_phase_sel" pos="13:8" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen3_clk_swch" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen4_phase_sel" pos="6:1" access="rw" rst="0x18">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen4_clk_swch" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="CLKGEN_12_06a" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen5_phase_sel" pos="13:8" access="rw" rst="0x20">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen5_clk_swch" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen6_phase_sel" pos="6:1" access="rw" rst="0x28">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen6_clk_swch" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="CLKGEN_13_06b" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dcdc_clkgen6_div_base" pos="15:4" access="rw" rst="0x0dc">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen6_dither_ct" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen6_clk_sel" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="CLKGEN_14_06c" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:6" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen1_resetn" pos="5" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen2_resetn" pos="4" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen3_resetn" pos="3" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen4_resetn" pos="2" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen5_resetn" pos="1" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dcdc_clkgen6_resetn" pos="0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

</module>



<module name="abb_page2" category="added_func">
    <reg name="reg_120" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:0" access="rw" rst="0xf0f0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="reg_121" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:0" access="rw" rst="0xf0f0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="reg_122" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:0" access="rw" rst="0x0000">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="reg_123" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:0" access="rw" rst="0x0010">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="reg_124" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:0" access="rw" rst="0x5a80">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="reg_125" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:0" access="rw" rst="0x9454">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="reg_126" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:0" access="rw" rst="0x0528">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="reg_127" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="rampdn_step" pos="6:0" access="rw" rst="0x3">
            <comment>dac ramp down per step time, unit is 1ms.
            </comment>
        </bits>
        <bits name="rampup_step" pos="13:7" access="rw" rst="0xa">
            <comment>dac ramp up per step time, unit is 1ms.
            </comment>
        </bits>
        <bits name="ramp_bypass" pos="14" access="rw" rst="0x1">
            <comment>1: ramp bypass.
            </comment>
        </bits>
        <bits name="ramp_ind" pos="15" access="rw" rst="0x0">
            <comment>0->1: ramp up, 1->0: ramp down.
            </comment>
        </bits>
    </reg>
    <reg name="reg_128" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="fm_mode" pos="0" access="rw" rst="0x0">
            <comment>1: fm_mode, 0: codec.
            </comment>
        </bits>
        <bits name="reserved" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="sleep_mode" pos="2" access="rw" rst="0x0">
            <comment>1: sleep_mode.
            </comment>
        </bits>
        <bits name="reserved" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="s_adc_osr_sel" pos="5:4" access="rw" rst="0x0">
            <comment>01:2.048M, 00:1.024M
            </comment>
        </bits>
        <bits name="cnt_adc_clk_int" pos="12:6" access="rw" rst="0x18">
            <comment>divider number for CODEC clk div to ADC clk Integer part.
            </comment>
        </bits>
        <bits name="cnt_adc_clk_dec" pos="15:13" access="rw" rst="0x0">
            <comment>Decimal part.
            </comment>
        </bits>
    </reg>
    <reg name="reg_129" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="s_hpf_bypass" pos="1" access="rw" rst="0x0">
            <comment>1: bypass mic HPF.
            </comment>
        </bits>
        <bits name="s_codec_en" pos="2" access="rw" rst="0x0">
            <comment>1: enable codec dsp.
            </comment>
        </bits>
        <bits name="s_isphone" pos="3" access="rw" rst="0x0">
            <comment>1: phone in/out.
            </comment>
        </bits>
        <bits name="earphone_det_clk_inv" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="earphone_det_clk_div2_en" pos="5" access="rw" rst="0x0">
            <comment>1: div2.
            </comment>
        </bits>
        <bits name="adc_clk_invert" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dac_clk_invert" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="s_adc_in_inv" pos="8" access="rw" rst="0x0">
            <comment>1: swap adc_f/s
            </comment>
        </bits>
        <bits name="mash_en_adc" pos="9" access="rw" rst="0x1">
            <comment>1: mash enable
            </comment>
        </bits>
        <bits name="s_dither_bypass" pos="10" access="rw" rst="0x0">
            <comment>1: bypass
            </comment>
        </bits>
        <bits name="s_dwa_en" pos="11" access="rw" rst="0x1">
            <comment>1: enable
            </comment>
        </bits>
        <bits name="s_phone_sel" pos="12" access="rw" rst="0x0">
            <comment>1: select rin, 0: select lin
            </comment>
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="0x0">
            <comment>1: enable
            </comment>
        </bits>
    </reg>
    <reg name="reg_12a" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="s_mute_r" pos="0" access="rw" rst="0x0">
            <comment>1: mute Rdac out.
            </comment>
        </bits>
        <bits name="s_mute_l" pos="1" access="rw" rst="0x0">
            <comment>1: mute Ldac out.
            </comment>
        </bits>
        <bits name="s_dac_volume" pos="6:2" access="rw" rst="0x18">
            <comment>-25dB(00001)~5dB(11111), step is 1dB, 00000=mute.
            </comment>
        </bits>
        <bits name="s_dac_volume_mute" pos="7" access="rw" rst="0x0">
            <comment>1: mute both L/R dac out.
            </comment>
        </bits>
        <bits name="dither_gain" pos="9:8" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="sdm_gain" pos="11:10" access="rw" rst="0x2">
            <comment>11: 0dB, 10: -2.5dB, 01: -4dB, 00: -6dB.
            </comment>
        </bits>
        <bits name="s_adc_dvst_ctl" pos="15:12" access="rw" rst="0xf">
            <comment>side tone gain, 0dB(00000)~-60dB(11110), step is 2dB, 11111: disable.
            </comment>
        </bits>
    </reg>
    <reg name="reg_12b" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="s_adc_dvst_ctl" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="tports_sel" pos="5:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="tports_codec_test_en" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="s_loop" pos="7" access="rw" rst="0x0">
            <comment>1: loop test
            </comment>
        </bits>
        <bits name="s_dac1k" pos="8" access="rw" rst="0x0">
            <comment>1: sine 1khz test
            </comment>
        </bits>
        <bits name="s_adc_volume" pos="12:9" access="rw" rst="0x2">
            <comment>mic gain, -12dB(0001)~16dB(1111) 0000: mute.
            </comment>
        </bits>
        <bits name="dither_gain" pos="15:13" access="rw" rst="0xf">
            <comment>sdm dither gain.
            </comment>
        </bits>
    </reg>
    <reg name="reg_12c" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="2:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="4:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reset_reg" pos="6:5" access="rw" rst="0x0">
            <comment>_1: reset adc path, _0: reset dac path.
            </comment>
        </bits>
        <bits name="s_dac_osr_sel" pos="8:7" access="rw" rst="0x0">
            <comment>1x=512osr, 01=256osr, 00=128osr.
            </comment>
        </bits>
        <bits name="reserved" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="s_dac_gain" pos="11:10" access="rw" rst="0x0">
            <comment>dac gain, unit is 6dB.
            </comment>
        </bits>
        <bits name="s_cnt_constant" pos="15:12" access="rw" rst="0x0">
            <comment>sdm dither gain.
            </comment>
        </bits>
    </reg>

    <reg name="reg_12d" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="s_cnt_constant" pos="10:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="15:11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="reg_12e" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="tports" pos="15:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="reg_12f" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="func_id" pos="15:0" access="ro" rst="0xcdec">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="reg_130" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="deemph_b0" pos="12:0" access="rw" rst="0x0">
            <comment>de-emphasis filter coef b0
            </comment>
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="reg_131" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="deemph_b1" pos="12:0" access="rw" rst="0x0">
            <comment>de-emphasis filter coef b1
            </comment>
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="reg_132" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="deemph_a1" pos="12:0" access="rw" rst="0x0">
            <comment>de-emphasis filter coef a1
            </comment>
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="reg_133" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="clkgen_mode" pos="1:0" access="rw" rst="0x0">
            <comment>_1: adc path, locked with txstb. _0: dac path, locked with txstb.
            </comment>
        </bits>
        <bits name="earphone_det_flg_code" pos="9:2" access="rw" rst="0xea">
            <comment>Index={flag,power,code}
            </comment>
        </bits>
        <bits name="adc_lpf_bypass" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="record_32k" pos="11" access="rw" rst="0x0">
            <comment>1: rxstb=32khz
            </comment>
        </bits>
        <bits name="record_16k" pos="12" access="rw" rst="0x0">
            <comment>1: rxstb=16khz
            </comment>
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="reg_134" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="earphone_det_th_l" pos="8:0" access="rw" rst="0x11a">
            <comment>
            </comment>
        </bits>
        <bits name="earphone_det_cnt_th" pos="12:9" access="rw" rst="0x3">
            <comment>number of tone20hz
            </comment>
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="reg_135" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="earphone_det_th_h" pos="8:0" access="rw" rst="0x13e">
            <comment>earphone_det_clk/4096/tone20hz.
            </comment>
        </bits>
        <bits name="spk_gain_sel" pos="10:9" access="rw" rst="0x0">
            <comment>_1: L+R, or L/R _0: swap L/R.
            </comment>
        </bits>
        <bits name="reserved" pos="15:11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="reg_136" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="reg_137" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:0" access="rw" rst="0xcdec">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="reg_138" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="lpf20_cf_a2" pos="15:0" access="rw" rst="0x0">
            <comment>signed(2.14)
            </comment>
        </bits>
    </reg>
    <reg name="reg_139" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="lpf20_cf_a1" pos="15:0" access="rw" rst="0x0">
            <comment>signed (2.14)
            </comment>
        </bits>
    </reg>

    <reg name="reg_13a" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="lpf20_cf_b0b2" pos="5:0" access="rw" rst="0x5">
            <comment>unsigned)
            </comment>
        </bits>
        <bits name="earphone_det_gain" pos="7:6" access="rw" rst="0x0">
            <comment>Unit 6dB
            </comment>
        </bits>
        <bits name="earphone_det_hpf_ct_u" pos="9:8" access="rw" rst="0x2">
            <comment>00=bypass
            </comment>
        </bits>
        <bits name="earphone_det_lpf20_bypass" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="15:11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="reg_13b" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="reg_13c" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="earphone_det_coef_15_0" pos="15:0" access="rw" rst="0x0">
            <comment>CLK=24.576e6 %Fs base CLK_GEN20=24.576e6 %Fs T=0.20 %time(s) FREQ=20*CLK_GEN20/CLK %Freq Fs=CLK_GEN20/4096 N=round(T*CLK/4096) k=floor(0.5+N*FREQ/Fs) coef=round(2*cos(2*pi*k/N)*2^18) dec2hex(coef)
            </comment>
        </bits>
    </reg>
    <reg name="reg_13d" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="earphone_det_coef_19_16" pos="3:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="earphone_det_th" pos="10:4" access="rw" rst="0xa">
            <comment>
            </comment>
        </bits>
        <bits name="earphone_det_sel" pos="11" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="earphone_det_bypass" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="notch20_bypass" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dac_hpf_mode" pos="14" access="rw" rst="0x1">
            <comment>1=HPF; 0=NOTCH.
            </comment>
        </bits>
        <bits name="tone20_gen_enable" pos="15" access="rw" rst="0x1">
            <comment>1=generate, 0=no.
            </comment>
        </bits>
    </reg>

    <reg name="reg_13e" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="earphone_det_a1_15_0" pos="15:0" access="rw" rst="0x0">
            <comment>20Hz tone tx freq parameter = round(Freq20*2^30/Fs).
            </comment>
        </bits>
    </reg>
    <reg name="reg_13f" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="earphone_det_a1_23_16" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="earphone_det_b1_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>20Hz tone tx gain.
            </comment>
        </bits>
    </reg>
    <reg name="reg_140" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="earphone_det_b1_23_8" pos="15:0" access="rw" rst="0x0400">
            <comment>20Hz tone tx gain.
            </comment>
        </bits>
    </reg>

    <reg name="reg_141" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="earphone_det_time" pos="15:0" access="rw" rst="0x4b0">
            <comment>20Hz detect time.
            </comment>
        </bits>
    </reg>

    <reg name="reg_142" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="earphone_det_flag" pos="7" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="earphone_det_rssi" pos="6:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="reg_143" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="gain_ctrl_num_5_0" pos="5:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="gain_ctrl_th_6_0" pos="12:6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="reg_144" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="notch20_cf_b1a1_19_8" pos="11:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="notch20_cf_b0b2_3_0" pos="15:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="reg_145" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="notch20_cf_b0b2_19_4" pos="15:0" access="rw" rst="0x0">
            <comment>if dac_hpf_mode=0,H(z)=[b0b2b1a1*z^-1b0b2*z^-2] /[1b1a1*z^-1a2] else H(z)=[1-2*z^-11] /[1b1a1*z^-1a2]
            </comment>
        </bits>
    </reg>
    <reg name="reg_146" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="3:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="notch20_cf_a2_11_0" pos="15:4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="reg_147" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="notch20_cf_a2_19_12" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="notch20_cf_b1a1_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

</module>



<module name="ap_pll_page0" category="added_func">
    <reg name="PLL_CPU_Settings_000H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Page_2_0" pos="14:12" access="ro" rst="0x0">
            <comment>interrupt.
            </comment>
        </bits>
        <bits name="reserved" pos="11:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_CPU_Settings_001H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_clkout_en_1_0" pos="14:13" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_cpaux_bit_2_0" pos="12:10" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_filter_ibit_2_0" pos="9:7" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_cp_bit_2_0" pos="6:4" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_vreg_bit_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_CPU_Settings_002H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_reserved_3_0" pos="12:9" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_refmulti2_en" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_high_test" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_low_test" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_test_en" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_sdm_clk_test_en" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_sdm_clk_sel_rst" pos="3" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_sdm_clk_sel_nor" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_cpu_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_cpu_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_CPU_Settings_003H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:0" access="rw" rst="0x72e3">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_CPU_Settings_004H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pu_pll_cpu" pos="15" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_lock" pos="14" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_sdm_resetn" pos="13" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_sdm_clk_sel" pos="12" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="11:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_CPU_Settings_005H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_cpu_sdm_freq_29_14" pos="15:0" access="rw" rst="0x24ec">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_CPU_Settings_006H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_cpu_sdm_freq_13_0" pos="15:2" access="rw" rst="0x13b1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="1:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_CPU_Settings_007H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved_sdm_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_dec_sel_2_0" pos="7:5" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits>
        <bits name="Dither_bypass" pos="4" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Ss_en" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ss_squre_tri_sel" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_sdm_resetn_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_sdm_resetn_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_CPU_Settings_008H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_cpu_ss_devi_ct_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cpu_ss_peri_ct_7_0" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_CPU_Settings_009H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:0" access="rw" rst="0x7100">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_CPU_Settings_00aH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Sdm_reset_time_sel_1_0" pos="15:14" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Sdmclk_sel_time_sel_1_0" pos="13:12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clk_gen_en_reg" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>
</module>

<module name="ap_pll_page1" category="added_func">
    <reg name="PLL_BUS_Settings_020H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Page_2_0" pos="14:12" access="ro" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_BUS_Settings_021H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_clkout_en_1_0" pos="14:13" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_cpaux_bit_2_0" pos="12:10" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_filter_ibit_2_0" pos="9:7" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_cp_bit_2_0" pos="6:4" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_vreg_bit_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_BUS_Settings_022H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_reserved_3_0" pos="12:9" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_refmulti2_en" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_high_test" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_low_test" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_test_en" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_sdm_clk_test_en" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_sdm_clk_sel_rst" pos="3" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_sdm_clk_sel_nor" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_bus_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_bus_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_BUS_Settings_023H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:0" access="rw" rst="0x72e3">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_BUS_Settings_024H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pu_pll_bus" pos="15" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_lock" pos="14" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_sdm_resetn" pos="13" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_sdm_clk_sel" pos="12" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_BUS_Settings_025H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_bus_sdm_freq_29_14" pos="15:0" access="rw" rst="0x24ec">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_BUS_Settings_026H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_bus_sdm_freq_13_0" pos="15:2" access="rw" rst="0x4ec1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="1:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_BUS_Settings_027H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved_sdm_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_dec_sel_2_0" pos="7:5" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits>
        <bits name="Dither_bypass" pos="4" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Ss_en" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ss_squre_tri_sel" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_sdm_resetn_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_sdm_resetn_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_BUS_Settings_028H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_bus_ss_devi_ct_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_bus_ss_peri_ct_7_0" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_BUS_Settings_029H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:0" access="rw" rst="0x7100">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_BUS_Settings_02aH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Sdm_reset_time_sel_1_0" pos="15:14" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Sdmclk_sel_time_sel_1_0" pos="13:12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clk_gen_en_reg" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>
</module>

<module name="ap_pll_page2" category="added_func">
    <reg name="PLL_DDR_Settings_060H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Page_2_0" pos="14:12" access="ro" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_DDR_Settings_061H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_clkout_en_1_0" pos="14:13" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_cpaux_bit_2_0" pos="12:10" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_filter_ibit_2_0" pos="9:7" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_cp_bit_2_0" pos="6:4" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_vreg_bit_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_DDR_Settings_062H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_reserved_3_0" pos="12:9" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_refmulti2_en" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_high_test" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_low_test" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_test_en" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_sdm_clk_test_en" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_sdm_clk_sel_rst" pos="3" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_sdm_clk_sel_nor" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_ddr_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_ddr_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_DDR_Settings_063H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:0" access="rw" rst="0x72e3">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_DDR_Settings_064H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pu_pll_ddr" pos="15" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_lock" pos="14" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_sdm_resetn" pos="13" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_sdm_clk_sel" pos="12" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_DDR_Settings_065H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_ddr_sdm_freq_29_14" pos="15:0" access="rw" rst="0x24ec">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_DDR_Settings_066H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_ddr_sdm_freq_13_0" pos="15:2" access="rw" rst="0x13b1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="1:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_DDR_Settings_067H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved_sdm_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_dec_sel_2_0" pos="7:5" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits>
        <bits name="Dither_bypass" pos="4" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Ss_en" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ss_squre_tri_sel" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_sdm_resetn_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_sdm_resetn_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_DDR_Settings_068H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_ddr_ss_devi_ct_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_ddr_ss_peri_ct_7_0" pos="7:0" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_DDR_Settings_069H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:0" access="rw" rst="0x7100">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_DDR_Settings_06aH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Sdm_reset_time_sel_1_0" pos="15:14" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Sdmclk_sel_time_sel_1_0" pos="13:12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clk_gen_en_reg" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>
</module>

<module name="ap_pll_page3" category="added_func">
    <reg name="PLL_USB_Settings_080H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Page_2_0" pos="14:12" access="ro" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_USB_Settings_081H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_clkout_en_1_0" pos="14:13" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_cpaux_bit_2_0" pos="12:10" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_filter_ibit_2_0" pos="9:7" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_cp_bit_2_0" pos="6:4" access="rw" rst="0x4">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_vreg_bit_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_USB_Settings_082H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_reserved_3_0" pos="12:9" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_refmulti2_en" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_high_test" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_low_test" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_test_en" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
       <bits name="Pll_usb_sdm_clk_test_en" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_sdm_clk_sel_rst" pos="3" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_sdm_clk_sel_nor" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_usb_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pu_pll_usb_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_USB_Settings_083H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:0" access="rw" rst="0x72e3">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_USB_Settings_084H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pu_pll_usb" pos="15" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_lock" pos="14" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_sdm_resetn" pos="13" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_sdm_clk_sel" pos="12" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_USB_Settings_085H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_usb_sdm_freq_29_14" pos="15:0" access="rw" rst="0x24ec">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="PLL_USB_Settings_086H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_usb_sdm_freq_13_0" pos="15:2" access="rw" rst="0x13b1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="1:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_USB_Settings_087H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved_sdm_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_dec_sel_2_0" pos="7:5" access="rw" rst="0x3">
            <comment>
            </comment>
        </bits>
        <bits name="Dither_bypass" pos="4" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Ss_en" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ss_squre_tri_sel" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_sdm_resetn_dr" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_sdm_resetn_reg" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_USB_Settings_088H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_usb_ss_devi_ct_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_usb_ss_peri_ct_7_0" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_USB_Settings_089H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:0" access="rw" rst="0x7100">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="PLL_USB_Settings_08aH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Sdm_reset_time_sel_1_0" pos="15:14" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Sdmclk_sel_time_sel_1_0" pos="13:12" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clk_gen_en_reg" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>
</module>

<module name="ap_pll_page4" category="added_func">
    <reg name="DDR_Settings_100H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_101H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_prsel_offset_15_12" pos="15:12" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_2.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_11_8" pos="11:8" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_1.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_7_4" pos="7:4" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_0.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Read clock phase select for dm_0.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_102H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_prsel_offset_31_28" pos="15:12" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_6.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_27_24" pos="11:8" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_5.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_23_20" pos="7:4" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_4.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_19_16" pos="3:0" access="rw" rst="0x8">
            <comment>Read clock phase select for dm_3.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_103H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dqs_prsel_preset_3_0" pos="15:12" access="rw" rst="0x8">
            <comment>Read clock phase select for dqs_prsel_preset_3_0; Without CDR.
            </comment>
        </bits>
        <bits name="Dq_prsel_todig_3_0" pos="11:8" access="rw" rst="0x8">
            <comment>Read clock phase select for dq2dig.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_39_36" pos="7:4" access="rw" rst="0x8">
            <comment>Read clock phase select for dqs_phase_select, dqs_0.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_35_32" pos="3:0" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_7.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_104H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_pwsel_bit_15_12" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_2.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_11_8" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_1.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_7_4" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_0.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for dm_0.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_105H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_pwsel_bit_31_28" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_6.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_27_24" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_5.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_23_20" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_4.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_19_16" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_3.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_106H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserve" pos="15:12" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
        <bits name="Int_wsamp_preset_3_0" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for write sampling flip-flop; Without CDR for dig to analog phy.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_39_36" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dqs_0.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_35_32" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_7.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_107H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Odt_bit_7_4" pos="15:12" access="rw" rst="0x8">
            <comment>ODT resistor setting for dq_7_0.
            </comment>
        </bits>
        <bits name="Odt_bit_3_0" pos="11:8" access="rw" rst="0x8">
            <comment>ODT resistor setting for dqs._0.
            </comment>
        </bits>
        <bits name="Ron_bit_7_4" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_7_0.
            </comment>
        </bits>
        <bits name="Ron_bit_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Write driver strength for dqs.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_108H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dq_wsamp_mode_9" pos="9" access="rw" rst="0x0">
            <comment>Dqs_wsamp_mode. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Dq_wsamp_mode_8_1" pos="8:1" access="rw" rst="0x0">
            <comment>Write Sample Mode for Dq_7_0.
            </comment>
        </bits>
        <bits name="Dq_wsamp_mode_0" pos="0" access="rw" rst="0x0">
            <comment>Write Sample Mode for Dm_0.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_109H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clock_read_enable" pos="12" access="rw" rst="0x1">
            <comment>Read Clock Enable. 0: disenable; 1: enable.
            </comment>
        </bits>
        <bits name="Reserved" pos="11:9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clock_write_enable" pos="8" access="rw" rst="0x1">
            <comment>Read Clock Enable. 0: disenable; 1: enable.
            </comment>
        </bits>
        <bits name="Reserved" pos="7:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_cdr_enable" pos="4" access="rw" rst="0x0">
            <comment>CDR for clock between analog PHY and digital PHY. 0: CDR process is hold; 1: CDR begin when Int_cdr_select=0.
            </comment>
        </bits>
        <bits name="Reserved" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_cdr_select" pos="0" access="rw" rst="0x0">
            <comment>Select sampling clock for analog PHY. 0: select preset clock phase, no CDR used; 1: select clock recoveried from CDR process.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_10aH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dqs_cdr_mode" pos="8" access="rw" rst="0x1">
            <comment>CDR MODE for DQS. 0: slow; 1: fast.
            </comment>
        </bits>
        <bits name="Reserved" pos="7:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dqs_cdr_enable" pos="4" access="rw" rst="0x0">
            <comment>CDR for clock DQS. 0: CDR process is hold; 1: CDR begin when Dqs_cdr_select=0.
            </comment>
        </bits>
         <bits name="Reserved" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dqs_cdr_select" pos="0" access="rw" rst="0x0">
            <comment>Select dqs clock for analog PHY. 0: select preset clock phase, no CDR used; 1: select clock recoveried from CDR process.
            </comment>
        </bits>
    </reg>
</module>

<module name="ap_pll_page5" category="added_func">
    <reg name="DDR_Settings_120H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_121H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_prsel_offset_15_12" pos="15:12" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_10.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_11_8" pos="11:8" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_9.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_7_4" pos="7:4" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_8.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Read clock phase select for dm_1.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_122H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_prsel_offset_31_28" pos="15:12" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_14.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_27_24" pos="11:8" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_13.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_23_20" pos="7:4" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_12.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_19_16" pos="3:0" access="rw" rst="0x8">
            <comment>Read clock phase select for dm_11.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_123H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dqs_prsel_preset_3_0" pos="15:12" access="rw" rst="0x8">
            <comment>Read clock phase select for dqs_prsel_preset_3_0; Without CDR.
            </comment>
        </bits>
        <bits name="Dq_prsel_todig_3_0" pos="11:8" access="rw" rst="0x8">
            <comment>Read clock phase select for dq2dig.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_39_36" pos="7:4" access="rw" rst="0x8">
            <comment>Read clock phase select for dqs_1.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_35_32" pos="3:0" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_15.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_124H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_pwsel_bit_15_12" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_10.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_11_8" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_9.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_7_4" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_8.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for dm_1.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_125H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_pwsel_bit_31_28" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_14.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_27_24" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_13.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_23_20" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_12.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_19_16" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_11.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_126H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserve" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_14.
            </comment>
        </bits>
        <bits name="Int_wsamp_preset_3_0" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for write sampling flip-flop; Without CDR for dig to analog phy.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_39_36" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dqs_1.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_35_32" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_7.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_127H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Odt_bit_7_4" pos="15:12" access="rw" rst="0x8">
            <comment>ODT resistor setting for dq_15_8.
            </comment>
        </bits>
        <bits name="Odt_bit_3_0" pos="11:8" access="rw" rst="0x8">
            <comment>ODT resistor setting for dqs_1.
            </comment>
        </bits>
        <bits name="Ron_bit_7_4" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_15_8.
            </comment>
        </bits>
        <bits name="Ron_bit_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Write driver strength for dqs_1.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_128H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dq_wsamp_mode_9" pos="9" access="rw" rst="0x0">
            <comment>Dqs_wsamp_mode (dqs_1). 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Dq_wsamp_mode_8_1" pos="8:1" access="rw" rst="0x0">
            <comment>Write Sample Mode for Dq_15_8.
            </comment>
        </bits>
        <bits name="Dq_wsamp_mode_0" pos="0" access="rw" rst="0x0">
            <comment>Write Sample Mode for Dm_1.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_129H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clock_read_enable" pos="12" access="rw" rst="0x1">
            <comment>Read Clock Enable. 0: disenable; 1: enable.
            </comment>
        </bits>
        <bits name="Reserved" pos="11:9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clock_write_enable" pos="8" access="rw" rst="0x1">
            <comment>Read Clock Enable. 0: disenable; 1: enable.
            </comment>
        </bits>
        <bits name="Reserved" pos="7:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_cdr_enable" pos="4" access="rw" rst="0x0">
            <comment>CDR for clock between analog PHY and digital PHY. 0: CDR process is hold; 1: CDR begin when Int_cdr_select=0.
            </comment>
        </bits>
        <bits name="Reserved" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_cdr_select" pos="0" access="rw" rst="0x0">
            <comment>Select sampling clock for analog PHY. 0: select preset clock phase, no CDR used; 1: select clock recoveried from CDR process.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_12aH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dqs_cdr_mode" pos="8" access="rw" rst="0x1">
            <comment>CDR MODE for DQS. 0: slow; 1: fast.
            </comment>
        </bits>
        <bits name="Reserved" pos="7:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dqs_cdr_enable" pos="4" access="rw" rst="0x0">
            <comment>CDR for clock DQS. 0: CDR process is hold; 1: CDR begin when Dqs_cdr_select=0.
            </comment>
        </bits>
        <bits name="Reserved" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dqs_cdr_select" pos="0" access="rw" rst="0x0">
            <comment>Select dqs clock for analog PHY. 0: select preset clock phase, no CDR used; 1: select clock recoveried from CDR process.
            </comment>
        </bits>
    </reg>
</module>

<module name="ap_pll_page6" category="added_func">
    <reg name="DDR_Settings_140H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_141H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_prsel_offset_15_12" pos="15:12" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_18.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_11_8" pos="11:8" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_17.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_7_4" pos="7:4" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_16.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Read clock phase select for dm_2.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_142H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_prsel_offset_31_28" pos="15:12" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_22.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_27_24" pos="11:8" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_21.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_23_20" pos="7:4" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_20.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_19_16" pos="3:0" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_19.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_143H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dqs_prsel_preset_3_0" pos="15:12" access="rw" rst="0x8">
            <comment>Read clock phase select for dqs_prsel_preset_3_0;Without CDR.
            </comment>
        </bits>
        <bits name="Dq_prsel_todig_3_0" pos="11:8" access="rw" rst="0x8">
            <comment>Read clock phase select for dq2dig.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_39_36" pos="7:4" access="rw" rst="0x8">
            <comment>Read clock phase select for dqs_2.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_35_32" pos="3:0" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_23.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_144H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_pwsel_bit_15_12" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_18.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_11_8" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_17.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_7_4" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_16.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for dm_2.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_145H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_pwsel_bit_31_28" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_22.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_27_24" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_21.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_23_20" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_20.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_19_16" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_19.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_146H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserve" pos="15:12" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
        <bits name="Int_wsamp_preset_3_0" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for write sampling flip-flop; Without CDR for dig to analog phy.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_39_36" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dqs_2.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_35_32" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_23.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_147H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Odt_bit_7_4" pos="15:12" access="rw" rst="0x8">
            <comment>ODT resistor setting for dq_23_16 and dm_2.
            </comment>
        </bits>
        <bits name="Odt_bit_3_0" pos="11:8" access="rw" rst="0x8">
            <comment>ODT resistor setting for dqs_2.
            </comment>
        </bits>
        <bits name="Ron_bit_7_4" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_23_16 and dm_2.
            </comment>
        </bits>
        <bits name="Ron_bit_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Write driver strength for dqs_2.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_148H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dq_wsamp_mode_9" pos="9" access="rw" rst="0x0">
            <comment>Dqs_wsamp_mode. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Dq_wsamp_mode_8_1" pos="8:1" access="rw" rst="0x0">
            <comment>Write Sample Mode for Dq_7_0.
            </comment>
        </bits>
        <bits name="Dq_wsamp_mode_0" pos="0" access="rw" rst="0x0">
            <comment>Write Sample Mode for Dm_0.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_149H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clock_read_enable" pos="12" access="rw" rst="0x1">
            <comment>Read Clock Enable. 0: disenable; 1: enable.
            </comment>
        </bits>
        <bits name="Reserved" pos="11:9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clock_write_enable" pos="8" access="rw" rst="0x1">
            <comment>Read Clock Enable.
            </comment>
        </bits>
        <bits name="Reserved" pos="7:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_cdr_enable" pos="4" access="rw" rst="0x1">
            <comment>CDR for clock between analog PHY and digital PHY. 0: CDR process is hold; 1: CDR begin when Int_cdr_select=0.
            </comment>
        </bits>
        <bits name="Reserved" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_cdr_select" pos="0" access="rw" rst="0x0">
            <comment>Select sampling clock for analog PHY. 0: select preset clock phase, no CDR used; 1: select clock recoveried from CDR process.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_14aH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dqs_cdr_mode" pos="8" access="rw" rst="0x1">
            <comment>CDR MODE for DQS. 0: slow; 1: fast.
            </comment>
        </bits>
        <bits name="Reserved" pos="7:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dqs_cdr_enable" pos="4" access="rw" rst="0x0">
            <comment>CDR for clock DQS. 0: CDR process is hold; 1: CDR begin when Dqs_cdr_select=0.
            </comment>
        </bits>
        <bits name="Reserved" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dqs_cdr_select" pos="0" access="rw" rst="0x0">
            <comment>Select dqs clock for analog PHY. 0: select preset clock phase, no CDR used; 1: select clock recoveried from CDR process.
            </comment>
        </bits>
    </reg>
</module>

<module name="ap_pll_page7" category="added_func">
    <reg name="DDR_Settings_160H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Regbit_vtt[2:0]" pos="2:0" access="rw" rst="0x0">
            <comment>Output Voltage of Regulator for VTT.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_161H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_prsel_offset_15_12" pos="15:12" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_26.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_11_8" pos="11:8" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_25.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_7_4" pos="7:4" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_24.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Read clock phase select for dm_3.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_162H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_prsel_offset_31_28" pos="15:12" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_30.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_27_24" pos="11:8" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_29.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_23_20" pos="7:4" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_28.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_19_16" pos="3:0" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_27.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_163H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dqs_prsel_preset_3_0" pos="15:12" access="rw" rst="0x8">
            <comment>Read clock phase select for dqs_prsel_preset_3_0;Without CDR.
            </comment>
        </bits>
        <bits name="Dq_prsel_todig_3_0" pos="11:8" access="rw" rst="0x8">
            <comment>Read clock phase select for dq2dig.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_39_36" pos="7:4" access="rw" rst="0x8">
            <comment>Read clock phase select for dqs_3.
            </comment>
        </bits>
        <bits name="Dq_prsel_offset_35_32" pos="3:0" access="rw" rst="0x8">
            <comment>Read clock phase select for dq_31.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_164H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_pwsel_bit_15_12" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_26.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_11_8" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_25.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_7_4" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_24.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for dm_3.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_165H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Dq_pwsel_bit_31_28" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_30.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_27_24" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_29.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_23_20" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_28.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_19_16" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_27.
            </comment>
        </bits>
    </reg>


    <reg name="DDR_Settings_166H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserve" pos="15:12" access="rw" rst="0x8">
            <comment>
            </comment>
        </bits>
        <bits name="Int_wsamp_preset_3_0" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for write sampling flip-flop; Without CDR for dig to analog phy.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_39_36" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dqs_3.
            </comment>
        </bits>
        <bits name="Dq_pwsel_bit_35_32" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_31.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_167H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Odt_bit_7_4" pos="15:12" access="rw" rst="0x8">
            <comment>ODT resistor setting for dq_31_24.
            </comment>
        </bits>
        <bits name="Odt_bit_3_0" pos="11:8" access="rw" rst="0x8">
            <comment>ODT resistor setting for dqs.
            </comment>
        </bits>
        <bits name="Ron_bit_7_4" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for dq_31_24.
            </comment>
        </bits>
        <bits name="Ron_bit_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Write driver strength for dqs.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_168H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dq_wsamp_mode_9" pos="9" access="rw" rst="0x0">
            <comment>Dqs_wsamp_mode. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Dq_wsamp_mode_8_1" pos="8:1" access="rw" rst="0x0">
            <comment>Write Sample Mode for Dq_7_0.
            </comment>
        </bits>
        <bits name="Dq_wsamp_mode_0" pos="0" access="rw" rst="0x0">
            <comment>Write Sample Mode for Dm_0.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_169H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clock_read_enable" pos="12" access="rw" rst="0x1">
            <comment>Read Clock Enable. 0: disenable; 1: enable.
            </comment>
        </bits>
        <bits name="Reserved" pos="11:9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Clock_write_enable" pos="8" access="rw" rst="0x1">
            <comment>Read Clock Enable. 0: disenable; 1: enable.
            </comment>
        </bits>
        <bits name="Reserved" pos="7:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_cdr_enable" pos="4" access="rw" rst="0x0">
            <comment>CDR for clock between analog PHY and digital PHY. 0: CDR process is hold; 1: CDR begin when Int_cdr_select=0.
            </comment>
        </bits>
        <bits name="Reserved" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_cdr_select" pos="0" access="rw" rst="0x0">
            <comment>Select sampling clock for analog PHY. 0: select preset clock phase, no CDR used; 1: select clock recoveried from CDR process.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_16aH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dqs_cdr_mode" pos="8" access="rw" rst="0x1">
            <comment>CDR MODE for DQS. 0: slow; 1: fast.
            </comment>
        </bits>
        <bits name="Reserved" pos="7:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dqs_cdr_enable" pos="4" access="rw" rst="0x0">
            <comment>CDR for clock DQS. 0: CDR process is hold; 1: CDR begin when Dqs_cdr_select=0.
            </comment>
        </bits>
        <bits name="Reserved" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Dqs_cdr_select" pos="0" access="rw" rst="0x0">
            <comment>Select dqs clock for analog PHY. 0: select preset clock phase, no CDR used; 1: select clock recoveried from CDR process.
            </comment>
        </bits>
    </reg>
</module>

<module name="ap_pll_page8" category="added_func">
    <reg name="DDR_Settings_180H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ca_pwsel_bit_15_12" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for ras_n.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_11_8" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for cas_n.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_7_4" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for we_n.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for CK_t/CK_c.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_181H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ca_pwsel_bit_31_28" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_3.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_27_24" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_2.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_23_20" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_1.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_19_16" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_0.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_182H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ca_pwsel_bit_47_44" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_7.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_43_41" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_6.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_39_36" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_5.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_35_32" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_4.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_183H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ca_pwsel_bit_63_60" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_11.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_59_56" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_10.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_55_52" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_9.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_51_48" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_8.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_184H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ca_pwsel_bit_79_76" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_15.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_75_72" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_14.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_71_68" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_13.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_67_64" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for ca_12.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_185H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ca_pwsel_bit_95_92" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for odt_0.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_91_88" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for ba_2.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_87_84" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for ba_1.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_83_80" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for ba_0.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_186H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ca_pwsel_bit_111_108" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for reset_n.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_107_104" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for cke_1.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_103_100" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for cke_0.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_99_96" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for odt_1.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_187H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ca_pwsel_bit_127_124" pos="15:12" access="rw" rst="0x8">
            <comment>Write clock phase select for cs_n_3.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_123_120" pos="11:8" access="rw" rst="0x8">
            <comment>Write clock phase select for cs_n_2.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_119_116" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for cs_n_1.
            </comment>
        </bits>
        <bits name="Ca_pwsel_bit_115_112" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for cs_n_0.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_188H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ca_wsamp_mode_15_4" pos="15:4" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for ca_11_0. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Ca_wsamp_mode_3" pos="3" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for ras_n. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Ca_wsamp_mode_2" pos="2" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for cas_n. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Ca_wsamp_mode_1" pos="1" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for we_n. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Ca_wsamp_mode_0" pos="0" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for ck_t/ck_c. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_189H" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ca_wsamp_mode_31_28" pos="31:28" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for cs_n_3_0. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Ca_wsamp_mode_27" pos="27" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for reset_n. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Ca_wsamp_mode_26_25" pos="26:25" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for cke_1_0. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Ca_wsamp_mode_24_23" pos="24:23" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for odt_1_0. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Ca_wsamp_mode_22_20" pos="22:20" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for ba_15_0. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Ca_wsamp_mode_19_16" pos="19:16" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for ca_15_12. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Reserved" pos="15:4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ca_wsamp_mode_3" pos="3" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for ras_n. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Ca_wsamp_mode_2" pos="2" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for cas_n. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Ca_wsamp_mode_1" pos="1" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for we_n. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
        <bits name="Ca_wsamp_mode_0" pos="0" access="rw" rst="0x0">
            <comment>ca_wsamp_mode for ck_t/ck_c. 0: normal delay for write; 1: delay more one clock cycle.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_18aH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ck_clk_write_enalbe" pos="12" access="rw" rst="0x1">
            <comment>Write clock enable for CK.
            </comment>
        </bits>
        <bits name="Reserved" pos="11:9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ca_clk_write_enable" pos="8" access="rw" rst="0x1">
            <comment>Write clock enable for CA and other signals.
            </comment>
        </bits>
        <bits name="Ron_bit_7_4" pos="7:4" access="rw" rst="0x8">
            <comment>Write clock phase select for CA and other signals.
            </comment>
        </bits>
        <bits name="Ron_bit_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Write driver strength for CK.
            </comment>
        </bits>
    </reg>

    <reg name="DDR_Settings_18bH" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_cdr_enable" pos="8" access="rw" rst="0x0">
            <comment>CDR for clock between analog PHY and digital PHY. 0: CDR process is hold; 1: CDR begin when Int_cdr_select=0.
            </comment>
        </bits>
        <bits name="Reserved" pos="7:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Int_cdr_select" pos="4" access="rw" rst="0x0">
            <comment>Select sampling clock for analog PHY. 0: select preset clock phase, no CDR used; 1: select clock recoveried from CDR process.
            </comment>
        </bits>
        <bits name="Ca_clkwsamp_preset_3_0" pos="3:0" access="rw" rst="0x8">
            <comment>Write clock phase select for command group;Without CDR.
            </comment>
        </bits>
    </reg>


</module>
</archive>

<archive relative='tranceiver.xml' >


<module name="tranceiver" category="added_func">
    <reg name="xcv_00h_Revision_ID" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="ChipID" pos="15:14" access="rw" rst="0x0">
            <comment>6223 chip ID Read as 12'h623
            </comment>
        </bits>
        <bits name="RevID" pos="13:8" access="rw" rst="0x0">
            <comment>Revision ID Read as 6'h0
            </comment>
        </bits>
        <bits name="xcv_01h" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>    
    <reg name="xcv_02h_TX Gain settings" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    <reg name="xcv_04h_TX Gain setting for slot 0" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    <reg name="xcv_06h_RXPLL frequency setting" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    <reg name="xcv_08h_Frequency channel number" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    <reg name="xcv_0ah" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    <reg name="xcv_0ch_RXPLL VCO Calibration" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    <reg name="xcv_0eh_Rxpll settings" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    <reg name="xcv_10h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    	    <bits name="Reserved" pos="15:8" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="7:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="xcv_12h_POWER 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="pu_thrnt" pos="15" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pu_lna_grp" pos="14" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pu_mixer_grp" pos="13" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pu_pga" pos="12" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pu_filter" pos="11" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pu_rfvco" pos="10" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pu_rxpll_peri" pos="9" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pu_rxpll_presc" pos="8" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pu_adc" pos="7" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pu_dac" pos="6" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pu_tx_grp" pos="5" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pu_dac_ramp" pos="4" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pu_mdll" pos="3" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pu_bg" pos="2" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="1" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="0" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        </reg> 
     <reg name="xcv_14h_Analog Gain" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="lna_gain_bit" pos="15:14" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="lna_gain2_bit" pos="13:12" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="sel_lna_single_lband" pos="11" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="sel_lna_single_hband" pos="10" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="lna_notch_lband_en" pos="9" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="lna_notch_Hband_en" pos="8" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="lna_i_bit" pos="7:5" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="lna_cap_in" pos="4:3" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="lna_cap_out" pos="2:1" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="0" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        </reg>
         <reg name="xcv_16h_MIXER" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="mixer_power_psr_en" pos="15" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="mixer_power_ana_en" pos="14" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="sel_mixer_l" pos="13" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="sel_mixer_h" pos="12" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="tia_gain_bit" pos="11:10" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="9" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="8" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pga_op_ibit" pos="7" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pga_gain_bit" pos="6:5" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pga_bw_rbit" pos="4:3" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pga_bw_cbit" pos="2:1" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="0" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        </reg>
        <reg name="xcv_18h_PGA 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="pga_mode_gsm" pos="15" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pga_mode_td" pos="14" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="mixer_offser_range_bit" pos="13:12" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="11" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="10" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="9" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="8" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="pga_cal_mixer_i" pos="7:0" access="rw" rst="0x1111_1111">
            <comment>
            </comment>
        </bits>
        </reg>  
     <reg name="xcv_1ah_PGA 4" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
     	   <bits name="pga_cal_mixer_q" pos="15:8" access="rw" rst="0x1111_1111">
            <comment>
            </comment>
        </bits>
        <bits name="filter_gain_bit" pos="7:4" access="rw" rst="0x1111">
            <comment>
            </comment>
        </bits>
        <bits name="filter_tuning_bit" pos="3:0" access="rw" rst="0x1111">
            <comment>
            </comment>
        </bits>
        </reg>
     <reg name="xcv_1ch_FILTER 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="filter_mode_gsm" pos="15" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="filter_mode_td" pos="14" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="filter_cal_enable" pos="13" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="filter_rstn" pos="12" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="11" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="10" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="9" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="8" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rfvco_current" pos="7:4" access="rw" rst="0x1111">
            <comment>
            </comment>
        </bits>
        <bits name="rfvco_vcobuf_ibit" pos="3:0" access="rw" rst="0x1111">
            <comment>
            </comment>
        </bits>
    </reg>
    
    
    <reg name="xcv_1eh_RFVCO 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="14" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="13" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rfvco_varcom_vbit_2" pos="12:10" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="9" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="8" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rfvco_band_sel" pos="7" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rfvco_lo_en_rxh" pos="6" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rfvco_lo_en_rxl" pos="5" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rfvco_lo_en_txh" pos="4" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rfvco_lo_en_txl" pos="3" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_open_en" pos="2" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_sdn_clk_sel" pos="1" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_refmulti2_en" pos="0" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
     </reg>
     
     <reg name="xcv_20h_RXPLL 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="rxpll_reg_div2_bit" pos="15:12" access="rw" rst="0x1111">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_refg_presc_bit" pos="11:8" access="rw" rst="0x1111">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_fbc_sel" pos="7:5" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_phase_ctrl_dly" pos="4:3" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_sink_mode" pos="2:0" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
    </reg>
     <reg name="xcv_22h_RFPLL 3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="rxpll_cp_bit" pos="15:12" access="rw" rst="0x1111">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_vco_gain" pos="11:8" access="rw" rst="0x1111">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_r_bit" pos="7:6" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_lpf_gain" pos="5:2" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_bypass_notch" pos="1" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_xfer_aux_en" pos="0" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
    </reg>
    
     <reg name="xcv_24h_RFPLL 5" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="rxpll_pfd_res_bit" pos="15:10" access="rw" rst="0x111111">
            <comment>
            </comment>
        </bits>
        <bits name="sel_bg" pos="9" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_cal_clk_sel" pos="8" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_reg_digi_bit" pos="7:4" access="rw" rst="0x1111">
            <comment>
            </comment>
        </bits>
        <bits name="rxpll_reg_fit_bit" pos="3:0" access="rw" rst="0x1111">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="xcv_26h_THERM 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="thmt_vbe_bias" pos="15:8" access="rw" rst="0x11111111">
            <comment>
            </comment>
        </bits>
        <bits name="thmt_vbe_bias_sdm" pos="7" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="thmt_div_num" pos="6:3" access="rw" rst="0x1111">
            <comment>
            </comment>
        </bits>
        <bits name="thmt_chopper_en" pos="2" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="thmt_clk_reverse" pos="1" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="thmt_rstn" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
    </reg>  
    
    <reg name="xcv_28h_THERM 3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="thmt_ibit_adc" pos="15:12" access="rw" rst="0x111">
            <comment>
            </comment>
        </bits>
        <bits name="thmt_beta_indep_en" pos="11" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="10:8" access="rw" rst="0x1111">
            <comment>
            </comment>
        </bits>
        <bits name="Tx_lpf_bw_mode" pos="7:6" access="rw" rst="0x11">
            <comment>
            </comment>
        </bits>
        <bits name="Tx_lpf_bw_tuning" pos="5:4" access="rw" rst="0x11">
            <comment>
            </comment>
        </bits>
        <bits name="tx_lpf_therm_gain" pos="3:1" access="rw" rst="0x111">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="xcv_2ah_TXLPF 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="tx_lpf_if_vcom" pos="15:13" access="rw" rst="0x111">
            <comment>
            </comment>
        </bits>
        <bits name="tmx_gain" pos="12:10" access="rw" rst="0x111">
            <comment>
            </comment>
        </bits>
        <bits name="tmx_cal_en" pos="9" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="tmx_cal_en" pos="8" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="tmx_op_ibit" pos="7:6" access="rw" rst="0x11">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="5:0" access="rw" rst="0x11111">
            <comment>
            </comment>
        </bits>
     </reg>
      <reg name="xcv_2ch_TMX 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="tmx_op_rstn" pos="15" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="14" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="13" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="12" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="padrv_bias_ibit" pos="11:8" access="rw" rst="0x1111">
            <comment>
            </comment>
        </bits>
        <bits name="padrv_gain" pos="7:5" access="rw" rst="0x111">
            <comment>
            </comment>
        </bits>
        <bits name="tx_grp_vreg_ibit" pos="4:1" access="rw" rst="0x1111">
            <comment>
            </comment>
        </bits>
        <bits name="tx_grp_bandselect" pos="0" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
      </reg>  
      <reg name="xcv_2eh_PADRV 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="tx_grp_pll_test" pos="15" access="rw" rst="0x1">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="14:8" access="rw" rst="0x111111">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="7:0" access="rw" rst="0x11111111">
            <comment>
            </comment>
        </bits>
     </reg>  
     
    <reg name="xcv_30h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    <reg name="xcv_32h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    <reg name="xcv_34h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    <reg name="xcv_36h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    <reg name="xcv_38h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    <reg name="xcv_3ah" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    <reg name="xcv_3ch" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    <reg name="xcv_3eh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    </reg>
    
    
    <reg name="xcv_40h_FREQ 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="freq_dsp_31_16" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>

    </reg>
    <reg name="xcv_42h_FREQ 3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="freq_dsp_15_0" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="xcv_44h_SDM 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="resetn_sdm" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="former_bypass" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="tri_wave_bypass" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="int_dec_sel" pos="12:11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="shift_more" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="offset_enable" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="tx_rx" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="offset_value_23_16" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>       
    </reg>
    <reg name="xcv_46h_SDM 3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="offset_value_15_0" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="xcv_48h_SDM 5" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved_sdm_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="freq_tx_offset_17_10" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="xcv_4ah_FREQ_TX2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="freq_tx_offset_9_2" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="freq_tx_offset" pos="7:6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dither_bypass" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="former_clk_edge" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="nphase" pos="3:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="xcv_4ch_SDM 6" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        
        <bits name="dll_mode" pos="15:14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="offset_select_wave" pos="13:11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dec_numerator" pos="10:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="clk_former_edge_sdm" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="6:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
     <reg name="xcv_4eh_SDM 8" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>   
     
     <reg name="xcv_50h_DSP 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="ctrl_ext" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg> 
     <reg name="xcv_52h_DSP 3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="resetn_dsp" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="sample_mode" pos="14:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="pn9_en" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dac_fix_en" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="diag_dac_sine" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="adc_reset_mode" pos="9:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved_dsp_17_10" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="xcv_54h_DSP 5" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved_dsp_9_2" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved_dsp" pos="7:6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="if_mode" pos="5:4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dac_fix_11_8" pos="3:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="xcv_56h_DSP 7" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="dac_fix_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dc_ct1_10_3" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="xcv_58h_DSP 9" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="dc_ct1_2_0" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dccancel1_bypass" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dccancel2_bypass" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dc_ct2" pos="10:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="xcv_5ah_DSP 11" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="iq_swap" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="lpfil_bypass" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="compfil_mode" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="bw_sel" pos="12:10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="imgrej_dsp" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="gain2_delay_bypass" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="gain2_ct_7_0" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="xcv_5ch_DSP 13" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="gain1_ct" pos="15:14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="gain2_delay_ct" pos="13:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="ts_mode" pos="7:4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dc_tx_cal_en" pos="3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dc_rx_cal_en" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dc_out_en" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="tx_dac_cal_en" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="xcv_5eh_DSP 15" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="dc_in_i_rx" pos="15:6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dc_in_q_rx_9_4" pos="5:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="xcv_60h_DSP 17" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="dc_in_q_rx_3_0" pos="15:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dc_in_i_tx" pos="11:2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="dc_in_q_tx_9_8" pos="1:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
     </reg>
     <reg name="xcv_62h_DSP 19" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="dc_in_q_tx_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="tx_dac_bit_i_11_4" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="xcv_64h_DSP 21" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="tx_dac_bit_i_3_0" pos="15:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="tx_dac_bit_q" pos="11:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
     </reg>
     <reg name="xcv_66h_DSP 23" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="former_ctsample" pos="15:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="former_wt_ct" pos="11:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
         <bits name="digrf_en" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="former_dem_inv" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="former_start_th" pos="5:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
     </reg>
     <reg name="xcv_68h_DSP 25" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="former_fifo_en" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="equfil_tx_shift_ct_gsm" pos="14:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="r68_reserved" pos="11:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="equfil_tx_g_gsm_15_8" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="xcv_6ah_DSP 27" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="equfil_tx_g_gsm_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="equfil_tx_b1_11_4" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="xcv_6ch_DSP 29" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="equfil_tx_b1_3_0" pos="15:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="equfil_tx_b2" pos="11:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
       <reg name="xcv_6eh_DSP 31" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="equfil_tx_a1" pos="15:4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
        <bits name="equfil_tx_a2_11_8" pos="3:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg>
      <reg name="xcv_70h_DSP 33" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="equfil_tx_a2_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="equfil_tx_k_14_8" pos="6:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg>  
      <reg name="xcv_72h_DSP 35" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="equfil_tx_k_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved0_agc_lna_15_8" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg>
      <reg name="xcv_74h_DSP 37" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved0_agc_lna_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved1_agc_lna_15_8" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg>
      <reg name="xcv_76h_DSP 39" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved1_agc_lna_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved2_agc_lna_15_8" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg>
      <reg name="xcv_78h_DSP 41" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved2_agc_lna_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved3_agc_lna_15_8" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg>
      <reg name="xcv_7ah_DSP 43" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="reserved3_agc_lna_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="slot_length_base" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg>
      
      
    <reg name="xcv_7ch_DSP 45" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="edge_gsm" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="edge_acc_en" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="pa_ramp_bypass" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="solo_strobe_mode" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="edge_dly_sel_0" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserve" pos="10:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="edge_dly_sel_8_1" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>        
     </reg>
     <reg name="xcv_7eh_DSP 47" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="edge_gain_ct1" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="slot_length_delta" pos="12:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="edge_gain_ct2" pos="7:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg> 
      <reg name="xcv_80h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Chip_id_23_8" pos="15:0" access="rw" rst="0x0110_0010">
            <comment>
            </comment>
        </bits>
      </reg>
      <reg name="xcv_82h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Chip_id_7_0" pos="15:8" access="rw" rst="0x1110_0000">
            <comment>
            </comment>
        </bits>
        <bits name="Revision_id" pos="7:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg>

<hole size="2*32"/>

       <reg name="xcv_88h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="P2_in_0" pos="15:8" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="P2_in_1" pos="7:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg>
       <reg name="xcv_8ah" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="P2_in_2" pos="15:8" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="P2_in_3" pos="7:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg>      
      <reg name="xcv_8ch" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="P2_in_4" pos="15:8" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="P2_in_5" pos="7:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg>
      <reg name="xcv_8eh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="P2_in_6" pos="15:8" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="P2_in_7" pos="7:0" access="ro" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg>
      <reg name="xcv_90h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_cnt_target" pos="15:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg>
      <reg name="xcv_92h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_cal_resetn" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_int_delay" pos="14:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cnt_delay_sel" pos="11:10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cal_opt" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cal_hd" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cal_enable_reg" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_cnt_enable_reg" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pll_vco_bits_12_8" pos="4:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
      </reg>
    <reg name="xcv_94h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pll_vco_bits_7_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Reserved" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
    </reg>    
    <reg name="xcv_96h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Digrf_rx_resetn" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="enable_clk_digrf_rx" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="enable_clk_digrf_tx" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="rxclk_polarity" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
        <bits name="txclk_polarity" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Digrf_txon" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="digrf_enable" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="digrf_stream_mode_enable" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="rx_iq_order" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="sample_mode" pos="6:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="rx_en_delay_counter" pos="3:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
    </reg>
     <reg name="xcv_98h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="edge_mode" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="digrf_test_en" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="tx_block_flr" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="slot_number_dr" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
        <bits name="slot_number_reg" pos="11:10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="time_sel_after_rampd" pos="9:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="txdata_out_timer" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="xcv_9ah" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ema" pos="15:13" access="rw" rst="0x010">
            <comment>
            </comment>
        </bits>
        <bits name="Emaw" pos="12:11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="10:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="aux_buf_delay" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="gpio_auxclk_en_dr" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="gpio_auxclk_en_reg" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="4:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg> 
    <reg name="xcv_9ch" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="cnt_max_dccal_i" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="cnt_max_dccal_q" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg> 
    <reg name="xcv_9eh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="rx_tx" pos="10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dccal_q_enable" pos="9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dccal_i_enable" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="mem_phy_ctrl" pos="7:0" access="rw" rst="0x0100_0010">
            <comment>
            </comment>
        </bits>
    </reg> 
    <reg name="a0h_RTC setting" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="enable_clk_6p5m" pos="15" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="xen_bt_enablex" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="xen_bt_enable" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="12:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="a2h_RTC setting" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="a4h_RTC setting" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="a6h_RTC setting" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ibit_xosc_nor" pos="15:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Xosc_cdac_nor" pos="11:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Fix_ibit_xosc_nor" pos="4:0" access="rw" rst="0x01_0100">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="a8h_RTC setting" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ibit_xosc_lp" pos="15:12" access="rw" rst="0x1000">
            <comment>
            </comment>
        </bits>
        <bits name="Xosc_cdac_lp" pos="11:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Xosc_cdac_lp" pos="7:5" access="rw" rst="0x010">
            <comment>
            </comment>
        </bits>
        <bits name="Fix_ibit_xosc_lp" pos="4:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="aah_RTC setting" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="timer_pu_xtal" pos="15:14" access="rw" rst="0x10">
            <comment>
            </comment>
        </bits>
        <bits name="timer_lp_mode" pos="13:12" access="rw" rst="0x01">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:8" access="rw" rst="0x0001">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>

<hole size="1*32"/>

    <reg name="aeh" protect="rw"> 
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    	<bits name="Reserved" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Reserved" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>     
    </reg>
    <reg name="b0h" protect="rw"> 
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
    	<bits name="Reserved" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits> 
        <bits name="Reserved" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>     
    </reg>
    <reg name="b2h_RAMP" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="ramp_gain_bit" pos="13:9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="adc_clk_en" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="adc_iq_swap" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="adc_resetn" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="adc_isel" pos="4:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="adc_digi_pwr_bit" pos="2:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="b4h_ADC 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="adc_gain_bit" pos="15:14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="adc_cal_reg_en" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="reserved" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="adc_cal_refi_enable" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="adc_cal_refi_bit" pos="10:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="adc_nrz_mode" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="adc_lp_mode_en" pos="6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="adc_aux_filter_enable" pos="5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="4:3" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dac_rstn" pos="2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dac_iout_enable" pos="1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dac_vtr_sel" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
    <reg name="b6h_DAC 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="dac_cm_bit" pos="15:14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dac_range_bit" pos="13:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dac_auxout_enable" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dac_low_bit" pos="10:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dac_bias_sel" pos="7:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dac_core_bit" pos="4:2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="dac_mux_en" pos="1:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
     <reg name="b8h_CLK GATE" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="clk_pllcal_26m_enable" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="clk_dac_26m_enable" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="clk_interface_26m_enable" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="clk_8051_26m_en" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="clk_8051_156m_en" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="xtal_reg_bit" pos="10:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="digi_afc_bit" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="bah_AFC 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="digi_afc_bit" pos="15:10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="xtal_rfac_hlsel" pos="9:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="xdrv_aux_reg_bit" pos="7:5" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="xdrv_aux_step_en" pos="4:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="clk_plls_26m_enable" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="bch_MDLL 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="mdll_div_num" pos="15:12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="mdll_band_sel" pos="11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="mdll_band" pos="10:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="mdll_startup" pos="7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="mdll_cp_ibit" pos="6:4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="mdll_startip_v" pos="3:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="mdll_vctrl_test_en" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="beh_MDLL 3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="mdll_dither_en" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="mdll_dither_mode" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="mdll_dither_bit" pos="13:11" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="10:9" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="digrf_test_en" pos="8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="7:4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="gpio_slew_bit" pos="3:2" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="digrf_slew_bit_test" pos="1:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>

<hole size="8*32"/>

    <reg name="d0h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Reserved" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pa_ramp_p1" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
     <reg name="d2h_RAMP CURVE 2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pa_ramp_p2" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pa_ramp_p3" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg> 
     <reg name="d4h_RAMP CURVE 4" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pa_ramp_p4" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pa_ramp_p5" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="d6h_RAMP CURVE 6" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pa_ramp_p6" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pa_ramp_p7" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="d8h_RAMP CURVE 8" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pa_ramp_p8" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pa_ramp_p9" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="dah_RAMP CURVE 10" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pa_ramp_p10" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pa_ramp_p11" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
      <reg name="dch_RAMP CURVE 12" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pa_ramp_p12" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pa_ramp_p13" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="deh_RAMP CURVE 14" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Pa_ramp_p14" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Pa_ramp_p15" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     
     <reg name="e0h_RAMP FACTOR 1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ramp_mult_factor_0" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ramp_mult_factor_1" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="e2h_RAMP FACTOR 3" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ramp_mult_factor_2" pos="15:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ramp_mult_factor_3" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
    <reg name="e4h_RAMP FACTOR 5" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Ramp_curve_sel_0" pos="15:13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ramp_curve_sel_1" pos="12:10" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ramp_curve_sel_2" pos="9:7" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Ramp_curve_sel_3" pos="6:4" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="3:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
    </reg>
     <reg name="e6h_RAMP" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="ramp_dac_din_reg" pos="15:6" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="5:1" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="ramp_dac_din_dr" pos="0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>
     <reg name="e7h_RAMP" protect="rw">     
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
     </reg>
     <reg name="e8h_GPIO" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0" />
        <bits name="read_req" pos="30" access="rw" rst="0x0" />
        <bits name="Gpio_bs0_reg" pos="15" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Gpio_bs1_reg" pos="14" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Gpio_bs2_out" pos="13" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Gpio_paon_out" pos="12" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
        <bits name="Reserved" pos="11:8" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>  
        <bits name="Reserved" pos="7:0" access="rw" rst="0x0">
            <comment>
            </comment>
        </bits>
     </reg>   
</module>
</archive>

<archive relative='xcv_rda6220e.xml' >

<module name="xcv_rda6220e_page0" category="added_func">

    <reg name="Revision_ID_00h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="ChipID" pos="17:6" access="rw" rst="0x622">
        </bits>
        <bits name="RevID" pos="5:0" access="rw" rst="0x0">
        </bits>
    </reg>
    <reg name="rx_gain_01h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="gain_table_enable" pos="17" access="rw" rst="0x1">
        </bits>
        <bits name="gain_table_pointer" pos="16:14" access="rw" rst="0x0">
        </bits>
        <bits name="Lpf_rx_85k_enable" pos="13" access="rw" rst="0x0">
        </bits>
        <bits name="Bw_sel" pos="12:10" access="rw" rst="0x1">
        </bits>
        <bits name="gain1_ct" pos="9:8" access="rw" rst="0x0">
        </bits>
        <bits name="gain2_ct_reg" pos="7:0" access="rw" rst="0x46">
        </bits>
    </reg>
    <reg name="tx_gain_02h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>

        <bits name="Ramp_mult_factor_flag_0" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_mult_factor_flag_1" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_mult_factor_flag_2" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_mult_factor_flag_3" pos="14" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_mode_sel_gsm" pos="13" access="rw" rst="0x0">
        </bits>

        <bits name="edge_vga_bit_dr" pos="12" access="rw" rst="0x0">
        </bits>
        <bits name="strobe_timer_en" pos="11" access="rw" rst="0x0">
        </bits>
        <bits name="tx_block_bb_send_data_flag" pos="10" access="rw" rst="0x0">
        </bits>
        <bits name="digrf_stream_mode_enable" pos="9" access="rw" rst="0x0">
        </bits>
        <bits name="txlpf_gain_bit" pos="8:0" access="rw" rst="0x100">
        </bits>
    </reg>


    <reg name="Multi_slot_Mode_Select_03h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Multi_slot_sel" pos="16:15" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_curve_sel_0" pos="14:12" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_curve_sel_1" pos="11:9" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_curve_sel_2" pos="8:6" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_curve_sel_3" pos="5:3" access="rw" rst="0x3ff">
        </bits>
        <bits name="Gsm_mode_1" pos="2" access="rw" rst="0x1">
        </bits>
        <bits name="Gsm_mode_2" pos="1" access="rw" rst="0x1">
        </bits>
        <bits name="Gsm_mode_3" pos="0" access="rw" rst="0x1">
        </bits>
    </reg>



    <reg name="tx_gain1_slot0_04h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="Vga_gain_bit_0" pos="13:10" access="rw" rst="0x0">
        </bits>
        <bits name="tmx_gain_bit_0" pos="9:0" access="rw" rst="0x3f">
        </bits>
    </reg>




    <reg name="tx_gain2_slot0_05h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Gain3_ct_0" pos="17:12" access="rw" rst="0x20">
        </bits>
        <bits name="Vga_gain_bit_0" pos="11:4" access="rw" rst="0x0">
        </bits>
        <bits name="Tx_edge_gain_ct1" pos="3:1" access="rw" rst="0x3">
        </bits>
        <bits name="Tx_edge_gain_ct2" pos="0" access="rw" rst="0x1">
        </bits>
    </reg>




    <reg name="PDN_GSM_Register_Control_06h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pdn" pos="0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="GSM_Ramp_Analog_Control_07h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="ramp_gain_bit" pos="17:13" access="rw" rst="0x0">
        </bits>
        <bits name="pd_dac_ramp_dr" pos="12" access="rw" rst="0x0">
        </bits>
        <bits name="ramp_din_dr" pos="11" access="rw" rst="0x0">
        </bits>
        <bits name="pd_dac_ramp_reg" pos="10" access="rw" rst="0x0">
        </bits>
        <bits name="ramp_din_reg" pos="9:0" access="rw" rst="0x300">
        </bits>
    </reg>


    <reg name="Frequency_Channel_Control_08h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Gsm_mode_0" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="mdll_div_normal" pos="16" access="rw" rst="0x1">
        </bits>
        <bits name="mdll_div_reg" pos="15:14" access="rw" rst="0x2">
        </bits>
        <bits name="band_sel" pos="13:12" access="rw" rst="0x1">
        </bits>
        <bits name="rxon_arfcn" pos="11" access="rw" rst="0x1">
        </bits>
        <bits name="txon_arfcn" pos="10" access="rw" rst="0x0">
        </bits>
        <bits name="arfcn" pos="9:0" access="rw" rst="0x0">
        </bits>
    </reg>




    <reg name="calib_set_09h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="tx_dac_cal_bit_sel" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="offset_init_delay" pos="15:14" access="rw" rst="0x0">
        </bits>
        <bits name="dc_cal_mode" pos="13:12" access="rw" rst="0x2">
        </bits>
        <bits name="tx_dc_cal_en_gsm" pos="11" access="rw" rst="0x1">
        </bits>
        <bits name="rxpll_cal_mode" pos="10" access="rw" rst="0x0">
        </bits>
        <bits name="rxpll_init_delay" pos="9:7" access="rw" rst="0x1">
        </bits>
        <bits name="time_sel_after_rampd" pos="6:5" access="rw" rst="0x2">
        </bits>
        <bits name="reserved" pos="4:3" access="rw" rst="0x1">
        </bits>
        <bits name="rxpll_cal_opt" pos="2" access="rw" rst="0x1">
        </bits>
        <bits name="rxpll_cnt_delay_sel" pos="1:0" access="rw" rst="0x1">
        </bits>
    </reg>

    <reg name="calib_res_tun_filt_0ah" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="filter_dac1_bit_dr" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="filter_dac1_bit_i_reg" pos="15:8" access="rw" rst="0x80">
        </bits>
        <bits name="filter_dac1_bit_q_reg" pos="7:0" access="rw" rst="0x80">
        </bits>
    </reg>


    <reg name="calib_res_mix_filt_0bh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="filter_dac2_bit_dr" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="filter_dac2_bit_i_reg" pos="15:8" access="rw" rst="0x80">
        </bits>
        <bits name="filter_dac2_bit_q_reg" pos="7:0" access="rw" rst="0x80">
        </bits>
    </reg>
    <reg name="calib_res_rxpll_0ch" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Dcc_auto_mode" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Dcc_hold" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="Gain3_ct_0_rc" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="14" access="rw" rst="0x0">
        </bits>
        <bits name="Rfvco_bit_dr" pos="13" access="rw" rst="0x0">
        </bits>
        <bits name="rfvco_bit_reg" pos="12:0" access="rw" rst="0x200">
        </bits>
    </reg>
    <reg name="calib_bits_0dh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="time_sel_dsp_reset_ms" pos="17:16" access="rw" rst="0x2">
        </bits>
        <bits name="adc_digi_pwr_bit_dr" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="adc_cal_refi_bit_dr" pos="14" access="rw" rst="0x9">
        </bits>
        <bits name="atuning_bit_reg" pos="13:10" access="rw" rst="0x8">
        </bits>
        <bits name="ftuning_bit_reg" pos="9:6" access="rw" rst="0x8">
        </bits>
        <bits name="adc_digi_pwr_bit_reg" pos="5:3" access="rw" rst="0x4">
        </bits>
        <bits name="adc_cal_refi_bit_reg" pos="2:0" access="rw" rst="0x4">
        </bits>
    </reg>
    <reg name="rxpll_set_0eh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="rxpll_cap_bit_mdll" pos="16:13" access="rw" rst="0x8">
        </bits>
        <bits name="rfvco_cap_mode" pos="12:10" access="rw" rst="0x0">
        </bits>
        <bits name="rfvco_div_ibit_dr" pos="9" access="rw" rst="0x0">
        </bits>
        <bits name="div_grp_tx_ibit_dr" pos="8" access="rw" rst="0x0">
        </bits>
        <bits name="rfvco_div_ibit_reg" pos="7:4" access="rw" rst="0x8">
        </bits>
        <bits name="div_grp_tx_ibit_reg" pos="3:0" access="rw" rst="0x8">
        </bits>
    </reg>
    <reg name="rxpll_set_0fh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="time_sel_digrf_txen" pos="17:16" access="rw" rst="0x2">
        </bits>
        <bits name="rxpll_reg_gro_bit_reg" pos="15:12" access="rw" rst="0x8">
        </bits>
        <bits name="reserved" pos="11:0" access="rw" rst="0x88">
        </bits>
    </reg>



    <reg name=" GSM_Ramp_Control_1_10h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_mult_factor_0" pos="17:8" access="rw" rst="0x200">
        </bits>
        <bits name="Ramp_mult_factor_1" pos="7:0" access="rw" rst="0x80">
        </bits>
    </reg>

    <reg name="GSM_Ramp_Control_2_11h" protect="rw">

        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_mult_factor_1" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_mult_factor_2" pos="15:6" access="rw" rst="0x200">
        </bits>
        <bits name="Ramp_mult_factor_3" pos="5:0" access="rw" rst="0x20">
        </bits>
    </reg>



    <reg name="GSM_Ramp_Control_3_12h" protect="rw">

        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_mult_factor_3" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="13:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="rxpll_set_13h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="15" access="rw" rst="0x7241">
        </bits>
        <bits name="reserved" pos="14" access="rw" rst="0x0">
        </bits>
        <bits name="Ctrl_ect" pos="13:10" access="rw" rst="0x7241">
        </bits>
        <bits name="Digrf_rx_delay_en" pos="9" access="rw" rst="0x0">
        </bits>
        <bits name="Digrf_rx_delay_cnt" pos="8:1" access="rw" rst="0x7241">
        </bits>
        <bits name="Ctrl_ect" pos="0" access="rw" rst="0x0">
        </bits>
    </reg>




    <reg name="rxpll_set_14h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:15" access="rw" rst="0x0">
        </bits>
        <bits name="dac_low_bit" pos="14:12" access="rw" rst="0x8">
        </bits>
        <bits name="sdm_clk_sel_pll_cal_en" pos="11" access="rw" rst="0x1">
        </bits>
        <bits name="sdm_clk_sel_pll_cal_nen" pos="10" access="rw" rst="0x0">
        </bits>
        <bits name="rxpll_sink_mode" pos="9:7" access="rw" rst="0x1">
        </bits>
        <bits name="pll_register_pointer_dr" pos="6" access="rw" rst="0x0">
        </bits>
        <bits name="pll_register_pointer_reg" pos="5:4" access="rw" rst="0x1">
        </bits>
        <bits name="Former_ct_shift_gsm_dr" pos="3" access="rw" rst="0x0">
        </bits>
        <bits name="Former_ct_shift_gsm_reg" pos="2:0" access="rw" rst="0x1">
        </bits>
    </reg>




    <reg name="rxpll_set_15h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Rfpll_reg_sdm_bit" pos="15:12" access="rw" rst="0x0">
        </bits>
        <bits name="Digi_pwr_lp_enable" pos="11" access="rw" rst="0x0">
        </bits>
        <bits name="Digi_pwr_iref_bit" pos="10:8" access="rw" rst="0x0">
        </bits>
        <bits name="Digi_pwr_vref_bit" pos="7:5" access="rw" rst="0x0">
        </bits>
        <bits name="Intfac_reg_vctrl_bit" pos="4:3" access="rw" rst="0x0">
        </bits>
        <bits name="Digi_pwr_test_enable" pos="2" access="rw" rst="0x0">
        </bits>
        <bits name="Test_bit" pos="1:0" access="rw" rst="0x0">
        </bits>
    </reg>



    <reg name="analog_mode_set_16h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Xdrv_reg_ibit" pos="17:15" access="rw" rst="0x2">
        </bits>
        <bits name="reserved" pos="14" access="rw" rst="0x0">
        </bits>
        <bits name="Vga_thermo_bypass" pos="13" access="rw" rst="0x0">
        </bits>
        <bits name="R16_reserved" pos="12" access="rw" rst="0x0">
        </bits>
        <bits name="Rstn_dac_op_dr" pos="11" access="rw" rst="0x0">
        </bits>
        <bits name="Rstn_dac_op_reg" pos="10" access="rw" rst="0x1">
        </bits>
        <bits name="Div_grp_highband_dr" pos="9" access="rw" rst="0x0">
        </bits>
        <bits name="Imgrej_dsp_dr" pos="8" access="rw" rst="0x0">
        </bits>
        <bits name="Imgrej_dsp_dr" pos="7" access="rw" rst="0x0">
        </bits>
        <bits name="Div_grp_highband_reg" pos="6" access="rw" rst="0x0">
        </bits>
        <bits name="Imgrej_dsp_reg" pos="5" access="rw" rst="0x0">
        </bits>
        <bits name="Filter_lp_mode_reg" pos="4" access="rw" rst="0x0">
        </bits>
        <bits name="Filter_if200k_mode_reg" pos="3" access="rw" rst="0x0">
        </bits>
        <bits name="Adc_lp_enable_reg" pos="2" access="rw" rst="0x0">
        </bits>
        <bits name="Tx_adc_enable_reg" pos="1" access="rw" rst="0x0">
        </bits>
        <bits name="Adc_fo_100k_en_reg" pos="0" access="rw" rst="0x0">
        </bits>
    </reg>




    <reg name="rx_path_set_17h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="Gsm_mode_enable" pos="11" access="rw" rst="0x3">
        </bits>
        <bits name="Aux_filter_out_enable" pos="10" access="rw" rst="0x0">
        </bits>
        <bits name="Adc_aux_filter_enable" pos="9" access="rw" rst="0x0">
        </bits>
        <bits name="Adc_reset_mode" pos="8:7" access="rw" rst="0x0">
        </bits>
        <bits name="Rmx_lo_div_ibit_dr" pos="6" access="rw" rst="0x0">
        </bits>
        <bits name="Adc_reset_dr" pos="5" access="rw" rst="0x0">
        </bits>
        <bits name="Rmx_lo_div_ibit_reg" pos="4:1" access="rw" rst="0x0">
        </bits>
        <bits name="Adc_reset_reg" pos="0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="adc_set_18h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Rfpll_lock_detect" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="Adc_reset_dsp" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="adc_reset_counter" pos="14:9" access="rw" rst="0x1a">
        </bits>
        <bits name="reset_adc_delay" pos="8:0" access="rw" rst="0x4c">
        </bits>
    </reg>



    <reg name="dac_crystal_set_19h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0x2">
        </bits>
        <bits name="Ldo_200m_vbit" pos="16:14" access="rw" rst="0x2">
        </bits>
        <bits name="Ldo_200m_lp_mode_b" pos="13" access="rw" rst="0x0">
        </bits>
        <bits name="Ldo_digio_bit" pos="12:10" access="rw" rst="0x0">
        </bits>
        <bits name="Reg_avdd_vio_bit" pos="9:8" access="rw" rst="0x80">
        </bits>
        <bits name="cdac" pos="7:0" access="rw" rst="0x4">
        </bits>
    </reg>


    <reg name="crystal_set_1ah" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Sel_digio_vio_lv" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Sel_avdd_vio_lv" pos="16" access="rw" rst="0x2">
        </bits>
        <bits name="Xtal_cfix" pos="15" access="rw" rst="0x8">
        </bits>
        <bits name="Xtal_fix_ibit" pos="14:12" access="rw" rst="0x0">
        </bits>
        <bits name="Xtal_amp" pos="11:9" access="rw" rst="0x2">
        </bits>
        <bits name="Xtal_rdac_hlsel" pos="8:5" access="rw" rst="0x0">
        </bits>
        <bits name="Xtal_reg_bit" pos="4:2" access="rw" rst="0x8">
        </bits>
        <bits name="Xdrv2_vsin_amp_bit" pos="1:0" access="rw" rst="0x7">
        </bits>
    </reg>


    <reg name="crystal_xdrv_set_1bh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Xout1_enable" pos="17" access="rw" rst="0x2">
        </bits>
        <bits name="Xdrv1_sin_enb" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="Xdrv1_sw_bit" pos="15:14" access="rw" rst="0x6">
        </bits>
        <bits name="Xdrv1_sw_bypass" pos="13" access="rw" rst="0x0">
        </bits>
        <bits name="Xdrv1_vtp_ibit" pos="12:10" access="rw" rst="0x2">
        </bits>
        <bits name="Xdrv1_vsin_amp_bit" pos="9:8" access="rw" rst="0x0">
        </bits>
        <bits name="Xout2_enable" pos="7" access="rw" rst="0x6">
        </bits>
        <bits name="Xdrv2_sin_enb" pos="6" access="rw" rst="0x0">
        </bits>
        <bits name="Xdrv2_sw_bit" pos="5:4" access="rw" rst="0x0">
        </bits>
        <bits name="Xdrv2_sw_bypass" pos="3" access="rw" rst="0x1">
        </bits>
        <bits name="Xdrv2_vtp_ibit" pos="2:0" access="rw" rst="0x1">
        </bits>
    </reg>

    <reg name="therm_calib_res_1ch" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_highband_mode_dr" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_highband_mode_reg" pos="16" access="rw" rst="0x2">
        </bits>
        <bits name="Txlpf_cal_sys_enable_dr" pos="15" access="rw" rst="0x2">
        </bits>
        <bits name="Txlpf_cal_sys_enable_reg" pos="14" access="rw" rst="0x2">
        </bits>
        <bits name="reserved" pos="13" access="rw" rst="0x1">
        </bits>
        <bits name="Thermo_pulse_restrain_ct" pos="12:11" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_cal_cnt" pos="10:7" access="rw" rst="0x20">
        </bits>
        <bits name="Thermo_cal_bit_dr" pos="6" access="rw" rst="0x20">
        </bits>
        <bits name="Thermo_cal_bit_reg" pos="5:0" access="rw" rst="0x20">
        </bits>
    </reg>




    <reg name="vga_set_1dh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Dac_afc_din" pos="17:6" access="rw" rst="0x2">
        </bits>
        <bits name="Dac_afc_bit" pos="5:1" access="rw" rst="0xf">
        </bits>
        <bits name="Pd_dac_afc" pos="0" access="rw" rst="0x8">
        </bits>

    </reg>


    <reg name="tx_path_set_1eh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Clk_enable_dr" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Clk26m_adc_enable_reg" pos="16" access="rw" rst="0x3">
        </bits>
        <bits name="Clk26m_adcfilter_enable_reg" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="Interface_26m_enable_reg" pos="14" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="13" access="rw" rst="0x1">
        </bits>
        <bits name="Tx_dac_bit_dr" pos="12" access="rw" rst="0x1">
        </bits>
        <bits name="Tx_dac_bit_i_reg" pos="11:0" access="rw" rst="0x800">
        </bits>
    </reg>


    <reg name="bgap_afc_set_1fh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Bgap_test_en" pos="15" access="rw" rst="0x2">
        </bits>
        <bits name="digi_afc_enable" pos="14" access="rw" rst="0x1">
        </bits>
        <bits name="digi_afc_bit" pos="13:0" access="rw" rst="0x2000">
        </bits>
    </reg>



    <reg name="digital_power_20h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="reset_dsp_delay" pos="16:14" access="rw" rst="0x3">
        </bits>
        <bits name="digital_power_test_en" pos="13" access="rw" rst="0x0">
        </bits>
        <bits name="digital_power_iref_bit" pos="12:10" access="rw" rst="0x4">
        </bits>
        <bits name="dvdd_ref_dsp" pos="9:7" access="rw" rst="0x4">
        </bits>
        <bits name="pd_power_dr" pos="6" access="rw" rst="0x0">
        </bits>
        <bits name="pu_digital_power_dr" pos="5" access="rw" rst="0x0">
        </bits>
        <bits name="filter_pd_power_reg" pos="4" access="rw" rst="0x0">
        </bits>
        <bits name="txlpf_pd_power_reg" pos="3" access="rw" rst="0x0">
        </bits>
        <bits name="bgap_pd_power_reg" pos="2" access="rw" rst="0x0">
        </bits>
        <bits name="dac_pd_power_reg" pos="1" access="rw" rst="0x0">
        </bits>
        <bits name="pu_digital_power_reg" pos="0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="ldo_regs_21h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Mode_24_bit" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Pd_xdrv_reg" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="Sar_sel_r" pos="15:14" access="rw" rst="0x0">
        </bits>
        <bits name="Sar_cal_bit_dr" pos="13" access="rw" rst="0x0">
        </bits>
        <bits name="Sar_cal_polarity" pos="12" access="rw" rst="0x0">
        </bits>
        <bits name="Sar_cal_aver_en" pos="11" access="rw" rst="0x0">
        </bits>
        <bits name="Sar_en_reg" pos="10" access="rw" rst="0x0">
        </bits>
        <bits name="Sar_cal_bit_reg" pos="9:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="ldo_pd_set_22h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pd_padrv_dr" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Pd_padrv_reg" pos="16" access="rw" rst="0x1">
        </bits>
        <bits name="Pd_vco_div_dr" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="Pd_vco_div_reg" pos="14" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="13:7" access="rw" rst="0x0">
        </bits>
        <bits name="Pu_rxvco_txbuf" pos="6" access="rw" rst="0x0">
        </bits>
        <bits name="Pu_rxvco_rxbuf" pos="5" access="rw" rst="0x1">
        </bits>
        <bits name="Pd_rxvco" pos="4" access="rw" rst="0x1">
        </bits>
        <bits name="Pd_rxpll_presc" pos="3" access="rw" rst="0x1">
        </bits>
        <bits name="Pd_rxpll_peri" pos="2" access="rw" rst="0x1">
        </bits>
        <bits name="Pd_rxpll_adclk" pos="1" access="rw" rst="0x1">
        </bits>
        <bits name="Pd_rxpll_rdac" pos="0" access="rw" rst="0x1">
        </bits>
    </reg>



    <reg name="pd_set_23h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pd_xdrv" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Pd_mdll" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="Pd_allpass" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="pd_digio" pos="14" access="rw" rst="0x1">
        </bits>
        <bits name="pd_lna850" pos="13" access="rw" rst="0x1">
        </bits>
        <bits name="pd_lna900" pos="12" access="rw" rst="0x1">
        </bits>
        <bits name="pd_lna1800" pos="11" access="rw" rst="0x1">
        </bits>
        <bits name="pd_lan1900" pos="10" access="rw" rst="0x1">
        </bits>
        <bits name="pd_mixer900" pos="9" access="rw" rst="0x1">
        </bits>
        <bits name="pd_mixer1800" pos="8" access="rw" rst="0x1">
        </bits>
        <bits name="pd_filter" pos="7" access="rw" rst="0x1">
        </bits>
        <bits name="pd_adc" pos="6" access="rw" rst="0x1">
        </bits>
        <bits name="pd_dac" pos="5" access="rw" rst="0x1">
        </bits>
        <bits name="pd_txlpf" pos="4" access="rw" rst="0x1">
        </bits>
        <bits name="pd_tmx" pos="3" access="rw" rst="0x1">
        </bits>
        <bits name="pd_bgiverf" pos="2" access="rw" rst="0x0">
        </bits>
        <bits name="pd_thermo" pos="1" access="rw" rst="0x0">
        </bits>
        <bits name="pd_xtal" pos="0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="timer_gpio_set_24h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="r24_reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="timer_txpower_start_delay" pos="15:14" access="rw" rst="0x1">
        </bits>
        <bits name="rx_wait_pll_stable_timer_on" pos="13" access="rw" rst="0x1">
        </bits>
        <bits name="tx_wait_pll_stable_timer_on" pos="12" access="rw" rst="0x1">
        </bits>
        <bits name="rx_wait_pll_stable_timer_on" pos="11:10" access="rw" rst="0x1">
        </bits>
        <bits name="tx_wait_pll_stable_timer" pos="9:8" access="rw" rst="0x1">
        </bits>
        <bits name="reset_sdm_delay" pos="7:6" access="rw" rst="0x1">
        </bits>
        <bits name="rda_gpio_paon_dr" pos="5" access="rw" rst="0x0">
        </bits>
        <bits name="rda_gpio_switch_on_dr" pos="4" access="rw" rst="0x0">
        </bits>
        <bits name="timer_vga_on_over_dr" pos="3" access="rw" rst="0x0">
        </bits>
        <bits name="rda_gpio_paon_reg" pos="2" access="rw" rst="0x0">
        </bits>
        <bits name="rda_gpio_switchon_reg" pos="1" access="rw" rst="0x0">
        </bits>
        <bits name="timer_vga_on_ower_reg" pos="0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="sdm_set_25h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="sdm_mode_sel" pos="17" access="rw" rst="0x1">
        </bits>
        <bits name="Clk_former_edge_sdm" pos="16" access="rw" rst="0x1">
        </bits>
        <bits name="tri_wave_bypass" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="tri_wave_step" pos="14:13" access="rw" rst="0x2">
        </bits>
        <bits name="r25_reserved" pos="12" access="rw" rst="0x1">
        </bits>
        <bits name="int_dec_sel" pos="11:10" access="rw" rst="0x0">
        </bits>
        <bits name="offset_enable" pos="9" access="rw" rst="0x0">
        </bits>
        <bits name="square_wave_in" pos="8" access="rw" rst="0x0">
        </bits>
        <bits name="Nphase" pos="7:4" access="rw" rst="0xc">
        </bits>
        <bits name="offset_select_wave" pos="3:1" access="rw" rst="0x4">
        </bits>
        <bits name="shift_more" pos="0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="sdm_set_26h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Pd_ldo_dr" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Pd_ldo_reg" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="Pd_ldo_lv_reg" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="Pd_ldo_200m_reg" pos="14" access="rw" rst="0x0">
        </bits>
        <bits name="Pd_dac_dr" pos="13" access="rw" rst="0x0">
        </bits>
        <bits name="Pd_dac_reg" pos="12" access="rw" rst="0x0">
        </bits>
        <bits name="dither_bypass" pos="11" access="rw" rst="0x0">
        </bits>
        <bits name="former_bypass_dr" pos="10" access="rw" rst="0x0">
        </bits>
        <bits name="sdm_resetn_dr" pos="9" access="rw" rst="0x0">
        </bits>
        <bits name="resetn_dsp_dr" pos="8" access="rw" rst="0x0">
        </bits>
        <bits name="tx_rx_dr" pos="7" access="rw" rst="0x0">
        </bits>
        <bits name="if_mode_dr" pos="6" access="rw" rst="0x0">
        </bits>
        <bits name="former_bypass_reg" pos="5" access="rw" rst="0x0">
        </bits>
        <bits name="sdm_resetn_reg" pos="4" access="rw" rst="0x1">
        </bits>
        <bits name="resetn_dsp_reg" pos="3" access="rw" rst="0x1">
        </bits>
        <bits name="tx_rx_reg" pos="2" access="rw" rst="0x0">
        </bits>
        <bits name="if_mode_reg" pos="1:0" access="rw" rst="0x2">
        </bits>
    </reg>



    <reg name="sdm_set_27h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Tx_dac_cal_bit_sel" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_cal_bit_sel" pos="15:14" access="rw" rst="0x0">
        </bits>
        <bits name="Txlpf_cal_bit_sel" pos="13:12" access="rw" rst="0x0">
        </bits>
        <bits name="Tx_dac_bit_q_reg" pos="11:0" access="rw" rst="0x0">
        </bits>
    </reg>



    <reg name="sdm_set_28h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="dec_numerator" pos="17:15" access="rw" rst="0x4">
        </bits>
        <bits name="edge_polar_mode" pos="14" access="rw" rst="0x1">
        </bits>
        <bits name="pn9_en" pos="13" access="rw" rst="0x0">
        </bits>
        <bits name="dac_fix_en" pos="12" access="rw" rst="0x0">
        </bits>
        <bits name="dac_fix" pos="11:0" access="rw" rst="0x200">
        </bits>
    </reg>



    <reg name="dsp_set_29h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Lpfil_bypass" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="decancel1_bypass" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="decancel2_bypass" pos="15" access="rw" rst="0x1">
        </bits>
        <bits name="compfil_mode" pos="14" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="13:11" access="rw" rst="0x2">
        </bits>
        <bits name="gain2_delay_bypass" pos="10" access="rw" rst="0x1">
        </bits>
        <bits name="gain2_delay_ct" pos="9:4" access="rw" rst="0x0">
        </bits>
        <bits name="ts_mode" pos="3:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="ramp_set_slot1_2ah" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="Vga_gain_bit_1" pos="13:10" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_gain_bit" pos="9:0" access="rw" rst="0x3ff">
        </bits>
    </reg>

    <reg name="TX_gain_2_for_Slot1_2bh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Gain3_ct_1" pos="17:12" access="rw" rst="0x20">
        </bits>
        <bits name="Vga_gain_bit_1" pos="11:4" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="3:0" access="rw" rst="0x0">
        </bits>
    </reg>
    <reg name="TX_Gain_1_for_Slot_2_2ch" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="Vga_gain_bit_2" pos="13:10" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_gain_bit_2" pos="9:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="TX_Gain_2_for_Slot_2_2dh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Gain3_ct_2" pos="17:12" access="rw" rst="0x7">
        </bits>
        <bits name="Vga_gain_bit_2" pos="11:4" access="rw" rst="0x20">
        </bits>
        <bits name="reserved" pos="3:0" access="rw" rst="0x7">
        </bits>
    </reg>


    <reg name="dsp_set_2eh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Digrf_txen_fix_reg" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="equfil_cheby_bypass_dr" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="equfil_cheby_bypass_reg" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="pa_ramp_bypass" pos="14" access="rw" rst="0x0">
        </bits>
        <bits name="former_fifo_en" pos="13" access="rw" rst="0x1">
        </bits>
        <bits name="dll_mode_dr" pos="12" access="rw" rst="0x0">
        </bits>
        <bits name="dll_mode_reg" pos="11:10" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="9:8" access="rw" rst="0x0">
        </bits>
        <bits name="reserved_sdm" pos="7:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="MISC_2fh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Strobe_reg" pos="17" access="rw" rst="0x3">
        </bits>
        <bits name="reserved" pos="16" access="rw" rst="0x1">
        </bits>
        <bits name="Lna_gain_bit_reg" pos="15:10" access="rw" rst="0x7">
        </bits>
        <bits name="Rmx_gain_bit_reg" pos="9:7" access="rw" rst="0x10">
        </bits>
        <bits name="Filter_gain_bit_reg" pos="6:3" access="rw" rst="0x4">
        </bits>
        <bits name="Adc_gain_bit_reg" pos="2:0" access="rw" rst="0x3">
        </bits>
    </reg>


    <reg name="sys_ctrl_set_30h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="17:16" access="rw" rst="0x1">
        </bits>
        <bits name="Gsm_mode" pos="15" access="rw" rst="0x1">
        </bits>
        <bits name="Digrf_enable" pos="14" access="rw" rst="0x1">
        </bits>
        <bits name="Zf_mode" pos="13" access="rw" rst="0x0">
        </bits>
        <bits name="If_200k_mode" pos="12" access="rw" rst="0x0">
        </bits>
        <bits name="Freq_mode" pos="11" access="rw" rst="0x0">
        </bits>
        <bits name="Direct_reg" pos="10" access="rw" rst="0x0">
        </bits>
        <bits name="Pd_all_b" pos="9" access="rw" rst="0x1">
        </bits>
        <bits name="Imgrej" pos="8" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="7:6" access="rw" rst="0x0">
        </bits>
        <bits name="Strobe_reg_enable" pos="5" access="rw" rst="0x0">
        </bits>
        <bits name="Strobe_gpio_enable" pos="4" access="rw" rst="0x0">
        </bits>
        <bits name="Strobe_gpio_level_mode" pos="3" access="rw" rst="0x0">
        </bits>
        <bits name="Mdll_div_dr" pos="2" access="rw" rst="0x0">
        </bits>
        <bits name="Chip_self_cal_enable" pos="1" access="rw" rst="0x0">
        </bits>
        <bits name="Soft_resetn" pos="0" access="rw" rst="0x1">
        </bits>
    </reg>


    <reg name="equfil_set_31h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_tx_g_gsm_d8" pos="15:0" access="rw" rst="0x2aac">
        </bits>
    </reg>

    <reg name="equfil_set_32h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_tx_g_edge_d8" pos="15:0" access="rw" rst="0x2875">
        </bits>
    </reg>


    <reg name="equfil_set_33h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="r33_reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="freq_comp" pos="15:4" access="rw" rst="0x0">
        </bits>
        <bits name="former_ct_shift_edge_dr" pos="3" access="rw" rst="0x0">
        </bits>
        <bits name="former_ct_shift_edge" pos="2:0" access="rw" rst="0x3">
        </bits>
    </reg>


    <reg name="TX_Gain_1_for_Slot_3_34h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="r34_reserved" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="Vga_gain_bit_3" pos="13:10" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_gain_bit_3" pos="9:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="TX_Gain_2_for_Slot_3_35h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Gain3_ct_3" pos="17:12" access="rw" rst="0x3">
        </bits>
        <bits name="Vga_gain_bit_3" pos="11:4" access="rw" rst="0x20">
        </bits>
        <bits name="reserve" pos="3:0" access="rw" rst="0x3">
        </bits>
    </reg>



    <reg name="ramp_set_gsm_special_36h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Gpio_bs3" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Gpio_swen_dr" pos="16" access="rw" rst="0x4">
        </bits>
        <bits name="Gpio_swen_reg" pos="15" access="rw" rst="0x4">
        </bits>
        <bits name="Reserved" pos="14:11" access="rw" rst="0x4">
        </bits>
        <bits name="ramp_mult_factor_flag_4" pos="10" access="rw" rst="0x0">
        </bits>
        <bits name="ramp_mult_factor_4" pos="9:0" access="rw" rst="0x0">
        </bits>
    </reg>



    <reg name="tx_block_set_37h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="slot_number_dr" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="slot_number" pos="16:15" access="rw" rst="0x0">
        </bits>
        <bits name="txclk_polarity" pos="14" access="rw" rst="0x0">
        </bits>
        <bits name="tx_block_flr" pos="13" access="rw" rst="0x0">
        </bits>
        <bits name="txdata_out_timer" pos="12:5" access="rw" rst="0x80">
        </bits>
        <bits name="slot_length_data" pos="4:0" access="rw" rst="0x0">
        </bits>
    </reg>



    <reg name="rx_block_set_38h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="rxclk_polarity" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="rx_delay_counter" pos="16:13" access="rw" rst="0x8">
        </bits>
        <bits name="rx_iq_order" pos="12" access="rw" rst="0x0">
        </bits>
        <bits name="sample_mode" pos="11:10" access="rw" rst="0x2">
        </bits>
        <bits name="r38_reserved" pos="9:7" access="rw" rst="0x80">
        </bits>
        <bits name="solo_strobe_mode" pos="6" access="rw" rst="0x0">
        </bits>
        <bits name="slot_mode" pos="5:3" access="rw" rst="0x0">
        </bits>
        <bits name="resetn_rx_data_mode" pos="2:1" access="rw" rst="0x1">
        </bits>
        <bits name="resetn_rx_data_reg" pos="0" access="rw" rst="0x1">
        </bits>
    </reg>


    <reg name="equfil_param_39h" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0x4">
        </bits>
        <bits name="Tmx_cal_bit_dr" pos="16" access="rw" rst="0x4">
        </bits>
        <bits name="Tmx_cal_bit_i_reg" pos="15:8" access="rw" rst="0x4">
        </bits>
        <bits name="Tmx_cal_bit_q_reg" pos="7:0" access="rw" rst="0x91a">
        </bits>
    </reg>


    <reg name="tx_block_set_3ah" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Txlpf_cal_bit_dr" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="Txlpf_cal_bit_i_reg" pos="15:8" access="rw" rst="0x2">
        </bits>
        <bits name="Txlpf_cal_bit_q_reg" pos="7:0" access="rw" rst="0x1">
        </bits>
    </reg>


    <reg name="equfil_param2_3bh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Dc_cal_one_time" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="Dc_table_full_mode" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="Dc_table_pointer_dr" pos="14" access="rw" rst="0x0">
        </bits>
        <bits name="Dc_table_pointer_reg" pos="13:11" access="rw" rst="0x0c">
        </bits>
        <bits name="Dc_ct1" pos="10:0" access="rw" rst="0x2d8">
        </bits>
    </reg>



    <reg name="dc_cancel_3ch" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:11" access="rw" rst="0x0">
        </bits>
        <bits name="dc_ct2" pos="10:0" access="rw" rst="0x3db">
        </bits>
    </reg>

    <reg name="pa_ramp_prog_reg_3dh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="array_data" pos="17:8" access="rw" rst="0x0">
        </bits>
        <bits name="array_addr" pos="7:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="tx_timer_ctrl_3eh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="switch_on_delay" pos="17:12" access="rw" rst="0x28">
        </bits>
        <bits name="pa_on_delay" pos="11:6" access="rw" rst="0x2c">
        </bits>
        <bits name="vga_on_delay" pos="5:0" access="rw" rst="0x28">
        </bits>
    </reg>

    <reg name="page_set_3fh" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:3" access="rw" rst="0x0">
        </bits>
        <bits name="page" pos="2:0" access="rw" rst="0x0">
        </bits>
    </reg>

</module>


<module name="xcv_rda6220e_page1" category="added_func">

    <reg name="reserved_00h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0x0">
        </bits>	
    </reg>

    <reg name="rxpll_set_01h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="rfvco_current_dr" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="rfvco_current_850" pos="15:12" access="rw" rst="0x8">
        </bits>
        <bits name="rfvco_current_900" pos="11:8" access="rw" rst="0x8">
        </bits>
        <bits name="rfvco_current_1800" pos="7:4" access="rw" rst="0x8">
        </bits>
        <bits name="rfvco_current_1900" pos="3:0" access="rw" rst="0x8">
        </bits>
    </reg>

    <reg name="rxpll_set_02h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="rxpll_r_bit_1900" pos="15:14" access="rw" rst="0x3">
        </bits>
        <bits name="rxpll_cp_bit_1900" pos="13:11" access="rw" rst="0x4">
        </bits>
        <bits name="rxpll_fts_cap_bit_850" pos="10:9" access="rw" rst="0x2">
        </bits>
        <bits name="rxpll_r_bit_850" pos="8:7" access="rw" rst="0x3">
        </bits>
        <bits name="rxpll_cp_bit_850" pos="6:4" access="rw" rst="0x4">
        </bits>
        <bits name="rxpll_vcogain_850" pos="3:0" access="rw" rst="0x8">
        </bits>
    </reg>

    <reg name="rxpll_set_03h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="rxpll_fts_cap_bit_1900" pos="16:15" access="rw" rst="0x2">
        </bits>
        <bits name="rxpll_vcogain_1900" pos="14:11" access="rw" rst="0x8">
        </bits>
        <bits name="rxpll_fts_cap_bit_900" pos="10:9" access="rw" rst="0x2">
        </bits>
        <bits name="rxpll_r_bit_900" pos="8:7" access="rw" rst="0x3">
        </bits>
        <bits name="rxpll_cp_bit_900" pos="6:4" access="rw" rst="0x4">
        </bits>
        <bits name="rxpll_vcogain_900" pos="3:0" access="rw" rst="0x8">
        </bits>
    </reg>


    <reg name="rxpll_set_04h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:11" access="rw" rst="0x0">
        </bits>
        <bits name="rxpll_fts_cap_bit_1800" pos="10:9" access="rw" rst="0x2">
        </bits>
        <bits name="rxpll_r_bit_1800" pos="8:7" access="rw" rst="0x3">
        </bits>
        <bits name="rxpll_cp_bit_1800" pos="6:4" access="rw" rst="0x4">
        </bits>
        <bits name="rxpll_vcogain_1800" pos="3:0" access="rw" rst="0x8">
        </bits>
    </reg>

    <reg name="rxgain_set_05h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Lna_gain_bit_0" pos="15:10" access="rw" rst="0x0">
        </bits>
        <bits name="Rmx_gain_bit_0" pos="9:7" access="rw" rst="0x7">
        </bits>
        <bits name="Filter_gain_bit_0" pos="6:3" access="rw" rst="0x10">
        </bits>
        <bits name="Adc_gain_bit_0" pos="2:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="rxgain_set_06h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Lna_gain_bit_1" pos="15:10" access="rw" rst="0x0">
        </bits>
        <bits name="Rmx_gain_bit_1" pos="9:7" access="rw" rst="0x7">
        </bits>
        <bits name="Filter_gain_bit_1" pos="6:3" access="rw" rst="0x10">
        </bits>
        <bits name="Adc_gain_bit_1" pos="2:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="rxgain_set_07h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Lna_gain_bit_2" pos="15:10" access="rw" rst="0x0">
        </bits>
        <bits name="Rmx_gain_bit_2" pos="9:7" access="rw" rst="0x7">
        </bits>
        <bits name="Filter_gain_bit_2" pos="6:3" access="rw" rst="0x10">
        </bits>
        <bits name="Adc_gain_bit_2" pos="2:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="rxgain_set_08h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Lna_gain_bit_3" pos="15:10" access="rw" rst="0x0">
        </bits>
        <bits name="Rmx_gain_bit_3" pos="9:7" access="rw" rst="0x7">
        </bits>
        <bits name="Filter_gain_bit_3" pos="6:3" access="rw" rst="0x10">
        </bits>
        <bits name="Adc_gain_bit_3" pos="2:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="rxgain_set_09h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Lna_gain_bit_4" pos="15:10" access="rw" rst="0x0">
        </bits>
        <bits name="Rmx_gain_bit_4" pos="9:7" access="rw" rst="0x7">
        </bits>
        <bits name="Filter_gain_bit_4" pos="6:3" access="rw" rst="0x10">
        </bits>
        <bits name="Adc_gain_bit_4" pos="2:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="rxgain_set_0ah_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Lna_gain_bit_5" pos="15:10" access="rw" rst="0x0">
        </bits>
        <bits name="Rmx_gain_bit_5" pos="9:7" access="rw" rst="0x7">
        </bits>
        <bits name="Filter_gain_bit_5" pos="6:3" access="rw" rst="0x10">
        </bits>
        <bits name="Adc_gain_bit_5" pos="2:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="therm_map_rfvco_current_0bh_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Lna_gain_bit_6" pos="15:10" access="rw" rst="0x0">
        </bits>
        <bits name="Rmx_gain_bit_6" pos="9:7" access="rw" rst="0x7">
        </bits>
        <bits name="Filter_gain_bit_6" pos="6:3" access="rw" rst="0x10">
        </bits>
        <bits name="Adc_gain_bit_6" pos="2:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="therm_map_rfvco_current_0ch_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Lna_gain_bit_7" pos="15:10" access="rw" rst="0x0">
        </bits>
        <bits name="Rmx_gain_bit_7" pos="9:7" access="rw" rst="0x7">
        </bits>
        <bits name="Filter_gain_bit_7" pos="6:3" access="rw" rst="0x10">
        </bits>
        <bits name="Adc_gain_bit_7" pos="2:0" access="rw" rst="0x0">
        </bits>
    </reg>



    <reg name="thermo_rfvco_div_ibit_0dh_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="thermo_rfvco_div_ibit_8" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="thermo_rfvco_div_ibit_7" pos="13:10" access="rw" rst="0x8">
        </bits>
        <bits name="thermo_rfvco_div_ibit_6" pos="9:6" access="rw" rst="0x8">
        </bits>
        <bits name="thermo_rfvco_div_ibit_5" pos="5:2" access="rw" rst="0x8">
        </bits>
        <bits name="thermo_rfvco_div_ibit_4" pos="1:0" access="rw" rst="0x2">
        </bits>
    </reg>


    <reg name="thermo_rfvco_div_ibit_0eh_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="thermo_rfvco_div_ibit_4" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="thermo_rfvco_div_ibit_3" pos="15:12" access="rw" rst="0x8">
        </bits>
        <bits name="thermo_rfvco_div_ibit_2" pos="11:8" access="rw" rst="0x8">
        </bits>
        <bits name="thermo_rfvco_div_ibit_1" pos="7:4" access="rw" rst="0x8">
        </bits>
        <bits name="thermo_rfvco_div_ibit_0" pos="3:0" access="rw" rst="0x8">
        </bits>
    </reg>


    <reg name="thermo_map_div_grp_tx_ibit_0fh_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="div_grp_tx_ibit_8" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="div_grp_tx_ibit_7" pos="13:10" access="rw" rst="0x8">
        </bits>
        <bits name="div_grp_tx_ibit_6" pos="9:6" access="rw" rst="0x8">
        </bits>
        <bits name="div_grp_tx_ibit_5" pos="5:2" access="rw" rst="0x8">
        </bits>
        <bits name="div_grp_tx_ibit_4" pos="1:0" access="rw" rst="0x2">
        </bits>
    </reg>


    <reg name="thermo_map_div_grp_tx_ibit_10h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="div_grp_tx_ibit_4" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="div_grp_tx_ibit_3" pos="15:12" access="rw" rst="0x8">
        </bits>
        <bits name="div_grp_tx_ibit_2" pos="11:8" access="rw" rst="0x8">
        </bits>
        <bits name="div_grp_tx_ibit_1" pos="7:4" access="rw" rst="0x8">
        </bits>
        <bits name="div_grp_tx_ibit_0" pos="3:0" access="rw" rst="0x8">
        </bits>
    </reg>


    <reg name="thermo_map_rxpll_reg_gro_bit_11h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="freq_comp_highband" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="freq_comp_lowband" pos="11:10" access="rw" rst="0x1a">
        </bits>
    </reg>


    <reg name="thermo_map_rxpll_reg_gro_bit_12h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Freq_comp_edge_tx_enable" pos="17" access="rw" rst="0x1">
        </bits>
        <bits name="Freq_comp_highband" pos="16:11" access="rw" rst="0xd">
        </bits>
        <bits name="Rxpll_fts_cap_bit_d9_edge_tx_dcs" pos="10:9" access="rw" rst="0x2">
        </bits>
        <bits name="Rxpll_r_bit_d9_edge_tx_dcs" pos="8:7" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_cp_bit_d9_edge_tx_dcs" pos="6:4" access="rw" rst="0x4">
        </bits>
        <bits name="Rxpll_vcogain_d9_edge_tx_dcs" pos="3:0" access="rw" rst="0xa">
        </bits>
     </reg>


    <reg name="thermo_map_rxpll_reg_pres_bit_13h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Gpio_bs_gsm850_rx" pos="17:15" access="rw" rst="0x88">
        </bits>
        <bits name="Gpio_bs_gsm900_rx" pos="14:12" access="rw" rst="0x88">
        </bits>
        <bits name="Gpio_bs_dcs1800_rx" pos="11:9" access="rw" rst="0x2">
        </bits>
        <bits name="Gpio_bs_pcs1900_rx" pos="8:6" access="rw" rst="0x88">
        </bits>
        <bits name="Gpio_bs_gsm850_tx" pos="5:3" access="rw" rst="0x88">
        </bits>
        <bits name="Gpio_bs_gsm900_tx" pos="2:0" access="rw" rst="0x2">
        </bits>
    </reg>


    <reg name="thermo_map_rxpll_reg_pres_bit_14h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_fts_cap_bit_d9n_edge_tx_dcs" pos="17:16" access="rw" rst="0x8">
        </bits>
        <bits name="Rxpll_r_bit_d9n_edge_tx_dcs" pos="15:14" access="rw" rst="0x88">
        </bits>
        <bits name="Rxpll_cp_bit_d9n_edge_tx_dcs" pos="13:11" access="rw" rst="0x8">
        </bits>
        <bits name="Rxpll_vcogain_d9n_edge_tx_dcs" pos="10:7" access="rw" rst="0x8">
        </bits>
        <bits name="reserved" pos="6" access="rw" rst="0x88">
        </bits>
        <bits name="Gpio_bs_dcs1800_tx" pos="5:3" access="rw" rst="0x8">
        </bits>
        <bits name="Gpio_bs_pcs1900_tx" pos="2:0" access="rw" rst="0x8">
        </bits>
    </reg>


    <reg name="thermo_map_rxpll_reg_pres_bit_15h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:11" access="rw" rst="0x8">
        </bits>
        <bits name="Txlpf_current_bit" pos="10:9" access="rw" rst="0x88">
        </bits>
        <bits name="Pd_txlpf_gain_ctrl" pos="8" access="rw" rst="0x22">
        </bits>
        <bits name="Txlpf_swing_cal" pos="7:6" access="rw" rst="0x88">
        </bits>
        <bits name="Txlpf_cal_enable_offset" pos="5" access="rw" rst="0x22">
        </bits>
        <bits name="Txlpf_cal_gain_bit" pos="4:1" access="rw" rst="0x88">
        </bits>
        <bits name="Txlpf_mode_edge" pos="0" access="rw" rst="0x22">
        </bits>
    </reg>


    <reg name="thermo_map_rxpll_reg_pres_bit_16h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Mdll_startup_dr" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Mdll_startup_reg" pos="16" access="rw" rst="0x88">
        </bits>
        <bits name="Mdll_startup_delay" pos="15:14" access="rw" rst="0x0">
        </bits>
        <bits name="Mdll_cap_bitb" pos="13:10" access="rw" rst="0x88">
        </bits>
        <bits name="Mdll_cp_ibit" pos="9:7" access="rw" rst="0x88">
        </bits>
        <bits name="Mdll_xtal_13meg_enable" pos="6" access="rw" rst="0x0">
        </bits>
        <bits name="Mdll_bp_sf_cp" pos="5" access="rw" rst="0x0">
        </bits>
        <bits name="Mdll_starup_v" pos="4:2" access="rw" rst="0x88">
        </bits>
        <bits name="Mdll_avdd_ctrl_test_enable" pos="1" access="rw" rst="0x88">
        </bits>
        <bits name="Mdll_test_enable" pos="0" access="rw" rst="0x88">
        </bits>
    </reg>


    <reg name="thermo_map_rxpll_reg_rdac_bit_17h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_rfvco_current_8" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_rfvco_current_7" pos="13:10" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_rfvco_current_6" pos="9:6" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_rfvco_current_5" pos="5:2" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_rfvco_current_4" pos="1:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="thermo_map_rxpll_reg_rdac_bit__18h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_rfvco_current_7" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_rfvco_current_3" pos="15:12" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_rfvco_current_2" pos="11:8" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_rfvco_current_1" pos="7:4" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_rfvco_current_0" pos="3:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="vco_cp_bit_compensation1_19h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="vco_cp_bit_factor_gsm850" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="vco_cp_bit_factor_gsm900" pos="11:6" access="rw" rst="0x0">
        </bits>
        <bits name="vco_cp_bit_factor_dcs1800" pos="5:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="vco_cp_bit_compensation2_1ah_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="r5a_reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="cpbit_lpfgain_sel" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="cpbit_lpfgain_unuse" pos="15:11" access="rw" rst="0x10">
        </bits>
        <bits name="vco_cp_bit_factor_pcs1900" pos="10:5" access="rw" rst="0x0">
        </bits>
        <bits name="vco_cp_bit_fine_pcs1900_tx" pos="4:0" access="rw" rst="0x10">
        </bits>
    </reg>


    <reg name="vco_cp_bit_compensation3_1bh_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="r5b_reserved" pos="17:15" access="rw" rst="0x0">
        </bits>
        <bits name="vco_cp_bit_fine_gsm850_tx" pos="14:10" access="rw" rst="0x0">
        </bits>
        <bits name="vco_cp_bit_fine_gsm900_tx" pos="9:5" access="rw" rst="0x10">
        </bits>
 	<bits name="vco_cp_bit_fine_dcs1800_tx" pos="4:0" access="rw" rst="0x10">
        </bits>
    </reg>


    <reg name="therm_map_rmx_lo_div_ibit_1ch_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="rmx_lo_div_ibit_8" pos="17:14" access="rw" rst="0x8">
        </bits>
        <bits name="rmx_lo_div_ibit_7" pos="13:10" access="rw" rst="0x8">
        </bits>
        <bits name="rmx_lo_div_ibit_6" pos="9:6" access="rw" rst="0x8">
        </bits>
        <bits name="rmx_lo_div_ibit_5" pos="5:2" access="rw" rst="0x8">
        </bits>
 	<bits name="rmx_lo_div_ibit_4" pos="1:0" access="rw" rst="0x2">
        </bits>
    </reg>

    <reg name="therm_map_rmx_lo_div_ibit_1dh_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="rmx_lo_div_ibit_4" pos="17:16" access="rw" rst="0x2">
        </bits>
        <bits name="rmx_lo_div_ibit_3" pos="15:12" access="rw" rst="0x8">
        </bits>
        <bits name="rmx_lo_div_ibit_2" pos="11:8" access="rw" rst="0x8">
        </bits>
        <bits name="rmx_lo_div_ibit_1" pos="7:4" access="rw" rst="0x8">
        </bits>
 	<bits name="rmx_lo_div_ibit_0" pos="3:0" access="rw" rst="0x8">
        </bits>
    </reg>



    <reg name="sub_module_control_1eh_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:10" access="rw" rst="0x2">
        </bits>
        <bits name="self_cal_ready_dr" pos="9" access="rw" rst="0x0">
        </bits>
        <bits name="adc_cal_reg_resetn_dr" pos="8" access="rw" rst="0x0">
        </bits>
        <bits name="rxpll_cal_resetn_dr" pos="7" access="rw" rst="0x0">
        </bits>
 	<bits name="thermo_cal_resetn_dr" pos="6" access="rw" rst="0x0">
        </bits>
 	<bits name="dc_offset_cal_fsm_resetn_dr" pos="5" access="rw" rst="0x0">
        </bits>
 	<bits name="self_cal_ready_reg" pos="4" access="rw" rst="0x1">
        </bits>
 	<bits name="adc_cal_reg_resetn_reg" pos="3" access="rw" rst="0x1">
        </bits>
 	<bits name="rxpll_cal_resetn_reg" pos="2" access="rw" rst="0x1">
        </bits>
 	<bits name="thermo_cal_resetn_reg" pos="1" access="rw" rst="0x1">
        </bits>
 	<bits name="dc_offset_cal_fsm_resetn" pos="0" access="rw" rst="0x1">
        </bits>
    </reg>

    <reg name="dsp_signal_1fh_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Edge_gain_am" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Pm_shift" pos="15:13" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="12:11" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_fts_cap_bit_d9_edge_tx_pcs" pos="10:9" access="rw" rst="0x1">
        </bits>
        <bits name="Rxpll_r_bit_d9_edge_tx_pcs" pos="8:7" access="rw" rst="0x2">
        </bits>
        <bits name="Rxpll_cp_bit_d9_edge_tx_pcs" pos="6:4" access="rw" rst="0x53">
        </bits>
        <bits name="Rxpll_vcogain_d9_edge_tx_pcs" pos="3:0" access="rw" rst="0x53">
        </bits>
    </reg>



    <reg name="dsp_signal_20h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="17" access="rw" rst="0x10">
        </bits>
        <bits name="Lna_lb_ibit" pos="16:14" access="rw" rst="0x4">
        </bits>
        <bits name="Lna_hb_ibit" pos="13:11" access="rw" rst="0x38">
        </bits>
        <bits name="Rmx_lo_vcom_sel" pos="10" access="rw" rst="0x10">
        </bits>
        <bits name="Rmx_ifvom_enable" pos="9" access="rw" rst="0x4">
        </bits>
        <bits name="Rmx_vcom_ctrl" pos="8:7" access="rw" rst="0x38">
        </bits>
        <bits name="Filter_cap_tuning" pos="6:3" access="rw" rst="0x10">
        </bits>
        <bits name="Filter_cal_mode_bandpass" pos="2" access="rw" rst="0x4">
        </bits>
        <bits name="Rmx_cal_resolv" pos="1:0" access="rw" rst="0x38">
        </bits>
    </reg>

    <reg name="dsp_signal_21h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Sdio_slew_bit" pos="17:16" access="rw" rst="0x2">
        </bits>
        <bits name="Gpio_slew_bit" pos="15:14" access="rw" rst="0x200">
        </bits>
        <bits name="Digio_i_bit" pos="13:11" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="10:8" access="rw" rst="0x1">
        </bits>
         <bits name="Allpass_cap_bit" pos="7:4" access="rw" rst="0x2">
        </bits>
        <bits name="Allpass_bypass_b" pos="3" access="rw" rst="0x200">
        </bits>
        <bits name="Adc_nrz_mode_enable" pos="2" access="rw" rst="0x0">
        </bits>
        <bits name="Adc_iq_swap" pos="1" access="rw" rst="0x1">
        </bits>
        <bits name="Adc_clk_mode" pos="0" access="rw" rst="0x1">
        </bits>
    </reg>


    <reg name="dsp_signal_readonly_22h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="Dac_cm_bit" pos="13:12" access="rw" rst="0x0">
        </bits>
        <bits name="Dac_range_bit" pos="11:10" access="rw" rst="0x0">
        </bits>
        <bits name="Dac_i_sel" pos="9:7" access="rw" rst="0x0">
        </bits>
        <bits name="Dac_core_bit" pos="6:4" access="rw" rst="0x0">
        </bits>
        <bits name="Dac_vlow_ctrl" pos="3:1" access="rw" rst="0x0">
        </bits>
        <bits name="Dac_iout_enable" pos="0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="dsp_signal_23h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_fts_cap_bit_d9n_edge_tx_pcs" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_r_bit_d9n_edge_tx_pcs" pos="15:14" access="rw" rst="0x1">
        </bits>
        <bits name="Rxpll_cp_bit_d9n_edge_tx_pcs" pos="13:11" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_vcogain_d9n_edge_tx_pcs" pos="10:7" access="rw" rst="0x0">
        </bits>
        <bits name="R63_reserved" pos="6" access="rw" rst="0x10">
        </bits>
        <bits name="Edge_acc_en" pos="5" access="rw" rst="0x0">
        </bits>
        <bits name="Edge_ct_shift" pos="4:2" access="rw" rst="0x0">
        </bits>
        <bits name="Dly_ph_sel" pos="1:0" access="rw" rst="0x10">
        </bits>
    </reg>


    <reg name="dsp_signal_24h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="r63_reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_tx_g_edge_d7" pos="15:0" access="rw" rst="0x1">
        </bits>
    </reg>



    <reg name="dsp_signal_25h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_tx_g_edge_d9" pos="15:0" access="rw" rst="0x4ea1">
        </bits>
    </reg>
    <reg name="dsp_signal_26h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="equfil_tx_g_edge_d10" pos="15:0" access="rw" rst="0x3333">
        </bits>
    </reg>


    <reg name="dsp_signal_27h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_tx_g_gsm_d7" pos="15:0" access="rw" rst="0x30c5">
        </bits>
    </reg>
    <reg name="dsp_signal_28h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_tx_g_gsm_d9" pos="15:0" access="rw" rst="0x25ee">
        </bits>
    </reg>
    <reg name="dsp_signal_29h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_tx_g_gsm_d10" pos="15:0" access="rw" rst="0x2223">
        </bits>
    </reg>



    <reg name="polarity_set_2ah_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Vco_cp_bit_fine_pcs1900_rx" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Filter_dac1_cal_iq_swap" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="Filter_dac2_cal_iq_swap" pos="14" access="rw" rst="0x0">
        </bits>
        <bits name="rxpll_cal_clk_inv" pos="13" access="rw" rst="0x0">
        </bits>
        <bits name="Tx_dac_cal_clk_inv" pos="12" access="rw" rst="0x0">
        </bits>
        <bits name="r6a_reserved" pos="11:10" access="rw" rst="0x0">
        </bits>
        <bits name="Clk_dsp_invert_reg" pos="9" access="rw" rst="0x0">
        </bits>
        <bits name="Clk_gating_always_on" pos="8" access="rw" rst="0x0">
        </bits>
        <bits name="Tx_path_dc_cal_polarity" pos="7" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_cal_polarity" pos="6" access="rw" rst="0x1">
        </bits>
        <bits name="Adc_cal_refi_polarity" pos="5" access="rw" rst="0x1">
        </bits>
        <bits name="Adc_cal_reg_polarity" pos="4" access="rw" rst="0x1">
        </bits>
        <bits name="tmx_cal_polarity" pos="3" access="rw" rst="0x0">
        </bits>
        <bits name="txlpf_cal_polarity" pos="2" access="rw" rst="0x0">
        </bits>
        <bits name="Filter_dac1_cal_polarity" pos="1" access="rw" rst="0x1">
        </bits>
        <bits name="Filter_dac2_cal_polarity" pos="0" access="rw" rst="0x1">
        </bits>
    </reg>





    <reg name="dsp_signal_2bh_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="vco_cp_bit_fine_gsm850_rx" pos="17:13" access="rw" rst="0x10">
        </bits>
        <bits name="vco_cp_bit_fine_gsm900_rx" pos="12:8" access="rw" rst="0x10">
        </bits>
        <bits name="vco_cp_bit_fine_dcs1800_rx" pos="7:3" access="rw" rst="0x10">
        </bits>
        <bits name="vco_cp_bit_fine_pcs1900_rx" pos="2:0" access="rw" rst="0x4">
        </bits>
    </reg>


    <reg name="compensation_set_2ch_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="freq_mismatch_900_5" pos="17:14" access="rw" rst="0x8">
        </bits>
        <bits name="freq_mismatch_900_4" pos="13:10" access="rw" rst="0x8">
        </bits>
        <bits name="freq_mismatch_900_3" pos="9:6" access="rw" rst="0x8">
        </bits>
        <bits name="freq_mismatch_900_2" pos="5:2" access="rw" rst="0x8">
        </bits>
        <bits name="freq_mismatch_900_1" pos="1:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="compensation_set_2dh_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="freq_mismatch_900_1" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="freq_mismatch_900_0" pos="15:12" access="rw" rst="0x8">
        </bits>
        <bits name="freq_mismatch_1800_10" pos="11:8" access="rw" rst="0x8">
        </bits>
        <bits name="freq_mismatch_1800_9" pos="7:4" access="rw" rst="0x8">
        </bits>
        <bits name="freq_mismatch_1800_8" pos="3:0" access="rw" rst="0x8">
        </bits>
    </reg>


    <reg name="compensation_set_2eh_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="freq_mismatch_1800_7" pos="17:14" access="rw" rst="0x8">
        </bits>
        <bits name="freq_mismatch_1800_6" pos="13:10" access="rw" rst="0x8">
        </bits>
        <bits name="freq_mismatch_1800_5" pos="9:6" access="rw" rst="0x8">
        </bits>
        <bits name="freq_mismatch_1800_4" pos="5:2" access="rw" rst="0x8">
        </bits>
        <bits name="freq_mismatch_1800_3" pos="1:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="compensation_set_2fh_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="freq_mismatch_1800_3" pos="13:12" access="rw" rst="0x0">
        </bits>
        <bits name="freq_mismatch_1800_2" pos="11:8" access="rw" rst="0x8">
        </bits>
        <bits name="freq_mismatch_1800_1" pos="7:4" access="rw" rst="0x8">
        </bits>
        <bits name="freq_mismatch_1800_0" pos="3:0" access="rw" rst="0x8">
        </bits>
    </reg>

    <reg name="compensation_set_30h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="thermo_diff_8" pos="17:14" access="rw" rst="0x8">
        </bits>
        <bits name="thermo_diff_7" pos="13:10" access="rw" rst="0x8">
        </bits>
        <bits name="thermo_diff_6" pos="9:6" access="rw" rst="0x8">
        </bits>
        <bits name="thermo_diff_5" pos="5:2" access="rw" rst="0x8">
        </bits>
        <bits name="thermo_diff_4" pos="1:0" access="rw" rst="0x2">
        </bits>
    </reg>


    <reg name="compensation_set_31h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="thermo_diff_4" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="thermo_diff_3" pos="15:12" access="rw" rst="0x8">
        </bits>
        <bits name="thermo_diff_2" pos="11:8" access="rw" rst="0x8">
        </bits>
        <bits name="thermo_diff_1" pos="7:4" access="rw" rst="0x8">
        </bits>
        <bits name="thermo_diff_0" pos="3:0" access="rw" rst="0x8">
        </bits>
    </reg>


    <reg name="strobe_timer_32h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_0" pos="17:12" access="rw" rst="0x200">
        </bits>
        <bits name="Ramp_bit_1" pos="11:6" access="rw" rst="0x200">
        </bits>
        <bits name="Ramp_bit_2" pos="5:0" access="rw" rst="0x100">
        </bits>
    </reg>



    <reg name="strobe_timer_33h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_3" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_4" pos="11:6" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_5" pos="5:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="strobe_timer_34h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_6" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_7" pos="11:6" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_8" pos="5:0" access="rw" rst="0x0">
        </bits>
    </reg>



    <reg name="digital_interface_set_35h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_9" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_a" pos="11:6" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_b" pos="5:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="reserved_reg_36h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_c" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_d" pos="11:6" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_e" pos="5:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="digital_interface_set_37h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="missmatch_diff_enable" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_diff_enable" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="Process_diff_dr" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_diff_dr" pos="14" access="rw" rst="0x0">
        </bits>
        <bits name="Mismatch_diff_dr" pos="13" access="rw" rst="0x0">
        </bits>
        <bits name="Process_diff_reg" pos="12:8" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_diff_reg" pos="7:4" access="rw" rst="0x0">
        </bits>
        <bits name="Mismatch_diff_reg" pos="3:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="compensate_set_38h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_cheby_k2" pos="11:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="compensate_set_39h_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Txlpf_ramp_bypass_dr" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Txlpf_ramp_bypass_reg" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="15:7" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_dr" pos="6" access="rw" rst="0x0">
        </bits>
        <bits name="Ramp_bit_f" pos="5:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="dc_cancel1_3ah_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Former_wt_ct" pos="17:14" access="rw" rst="0xc">
        </bits>
        <bits name="Slot_length_base" pos="13:6" access="rw" rst="0x124">
        </bits>
        <bits name="Reserved" pos="5" access="rw" rst="0x0">
        </bits>
        <bits name="Diag_dac_sine" pos="4" access="rw" rst="0x0">
        </bits>
        <bits name="Iq_swap" pos="3" access="rw" rst="0x0">
        </bits>
        <bits name="Dc_in_i_rx" pos="2:0" access="rw" rst="0x4">
        </bits>
    </reg>

    <reg name="dc_cancel2_3bh_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="dc_in_rx_dr" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="dc_in_i_rx_reg" pos="16:10" access="rw" rst="0x0">
        </bits>
        <bits name="dc_in_q_rx_reg" pos="9:0" access="rw" rst="0x200">
        </bits>
    </reg>


    <reg name="dc_cancel3_3ch_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="dc_in_tx_dr" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="dc_in_i_tx_reg" pos="16:10" access="rw" rst="0x0">
        </bits>
        <bits name="dc_in_q_tx_reg" pos="9:0" access="rw" rst="0x200">
        </bits>
    </reg>


    <reg name="former_set_3dh_1" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="dc-out_en" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="digrf_sign" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="fomer_dem_inv" pos="14" access="rw" rst="0x1">
        </bits>
        <bits name="fomer_ctsample" pos="13:10" access="rw" rst="0x0">
        </bits>
        <bits name="fomer_start_th" pos="9:4" access="rw" rst="0x4">
        </bits>
        <bits name="former_clk_edge" pos="3" access="rw" rst="0x0">
        </bits>
        <bits name="dc_in_i_tx" pos="2:0" access="rw" rst="0x4">
        </bits>
    </reg>

</module>




<module name="xcv_rda6220e_page2" category="added_func">

    <reg name="reserved_reg_00h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="edge_dsp_set_01h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="am_p0" pos="17:8" access="rw" rst="0x0">
        </bits>
        <bits name="am_p1" pos="7:0" access="rw" rst="0x7">
        </bits>
    </reg>

    <reg name="edge_dsp_set_02h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Am_p1" pos="17:16" access="rw" rst="0x3">
        </bits>
        <bits name="Reserved" pos="15:11" access="rw" rst="0x3f">
        </bits>
        <bits name="Gain3_ct" pos="10:6" access="rw" rst="0x3f">
        </bits>
        <bits name="Am_p3" pos="5:0" access="rw" rst="0x5">
        </bits>
    </reg>


    <reg name="edge_dsp_set_03h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Am_p3" pos="17:14" access="rw" rst="0xf">
        </bits>
        <bits name="Am_p4" pos="13:4" access="rw" rst="0x3f">
        </bits>
        <bits name="Am_p5" pos="3:0" access="rw" rst="0x2">
        </bits>
    </reg>


    <reg name="edge_dsp_set_04h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="am_p5" pos="17:12" access="rw" rst="0x1f">
        </bits>
        <bits name="am_p6" pos="11:2" access="rw" rst="0xbf">
        </bits>
        <bits name="am_p7" pos="1:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="edge_dsp_set_05h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Am_p7" pos="17:16" access="rw" rst="0xdf">
        </bits>
        <bits name="Timer_ctrl_single_slot" pos="15:10" access="rw" rst="0xff">
        </bits>
        <bits name="Fast_bw_mulit_slot" pos="9:7" access="rw" rst="0xff">
        </bits>
        <bits name="Timer_ctrl_multi_slot" pos="6:1" access="rw" rst="0xff">
        </bits>
        <bits name="Agc_index_update_rst_en" pos="0" access="rw" rst="0xff">
        </bits>
    </reg>


    <reg name="edge_dsp_set_06h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="am_p9" pos="17:8" access="rw" rst="0x11f">
        </bits>
        <bits name="am_p10" pos="7:0" access="rw" rst="0x4f">
        </bits>
    </reg>


    <reg name="edge_dsp_set_07h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="am_p10" pos="17:16" access="rw" rst="0x3">
        </bits>
        <bits name="am_p11" pos="15:6" access="rw" rst="0xaf">
        </bits>
        <bits name="am_p12" pos="5:0" access="rw" rst="0x17">
        </bits>
    </reg>


    <reg name="edge_dsp_set_08h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="am_p12" pos="17:14" access="rw" rst="0xf">
        </bits>
        <bits name="am_p13" pos="13:4" access="rw" rst="0x19f">
        </bits>
        <bits name="am_p14" pos="3:0" access="rw" rst="0x6">
        </bits>
    </reg>


    <reg name="edge_dsp_set_09h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="am_p14" pos="17:12" access="rw" rst="0x3f">
        </bits>
        <bits name="am_p15" pos="11:2" access="rw" rst="0x1df">
        </bits>
        <bits name="am_p16" pos="1:0" access="rw" rst="0x1">
        </bits>
    </reg>


    <reg name="edge_dsp_set_0ah_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="am_p16" pos="17:10" access="rw" rst="0xff">
        </bits>
        <bits name="pm_p0" pos="9:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="edge_dsp_set_0bh_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p1" pos="17:8" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p2" pos="7:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="edge_dsp_set_0ch_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p2" pos="17:6" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p3" pos="15:6" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p4" pos="5:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="edge_dsp_set_0dh_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p4" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p5" pos="13:4" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p6" pos="3:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="edge_dsp_set_0eh_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p6" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p7" pos="11:2" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p8" pos="1:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="edge_dsp_set_0fh_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p8" pos="17:10" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p9" pos="9:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="edge_dsp_set_10h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p10" pos="17:8" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p11" pos="7:0" access="rw" rst="0x0">
        </bits>
    </reg>
    <reg name="edge_dsp_set_11h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p11" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p12" pos="15:6" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p13" pos="5:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="edge_dsp_set_12h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p13" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p14" pos="13:4" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p15" pos="3:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="edge_dsp_set_13h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p15" pos="13:10" access="rw" rst="0x0">
        </bits>
        <bits name="pm_p16" pos="9:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="edge_dsp_set_14h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="freq_low_gsm850" pos="13:7" access="rw" rst="0x17">
        </bits>
        <bits name="freq_high_gsm850" pos="6:0" access="rw" rst="0x19">
        </bits>
    </reg>

    <reg name="edge_dsp_set_15h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="freq_low_gsm900" pos="13:7" access="rw" rst="0x19">
        </bits>
        <bits name="freq_high_gsm900" pos="6:0" access="rw" rst="0x1b">
        </bits>
    </reg>

    <reg name="edge_dsp_set_16h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="freq_low_dcs1800" pos="13:7" access="rw" rst="0x2b">
        </bits>
        <bits name="freq_high_dcs1800" pos="6:0" access="rw" rst="0x2e">
        </bits>
    </reg>

    <reg name="edge_dsp_set_17h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="freq_low_pcs1900" pos="13:7" access="rw" rst="0x14">
        </bits>
        <bits name="freq_high_pcs1900" pos="6:0" access="rw" rst="0x17">
        </bits>
    </reg>

    <reg name="edge_dsp_set_18h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="pa_ramp_p1" pos="15:8" access="rw" rst="0x0">
        </bits>
        <bits name="pa_ramp_p2" pos="7:0" access="rw" rst="0x1a">
        </bits>
    </reg>

    <reg name="edge_dsp_set_19h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="pa_ramp_p3" pos="15:8" access="rw" rst="0x35">
        </bits>
        <bits name="pa_ramp_p4" pos="7:0" access="rw" rst="0x4f">
        </bits>
    </reg>

    <reg name="edge_dsp_set_1ah_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="pa_ramp_p5" pos="15:8" access="rw" rst="0x68">
        </bits>
        <bits name="pa_ramp_p6" pos="7:0" access="rw" rst="0x7f">
        </bits>
    </reg>

    <reg name="edge_dsp_set_1bh_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="pa_ramp_p7" pos="15:8" access="rw" rst="0x96">
        </bits>
        <bits name="pa_ramp_p8" pos="7:0" access="rw" rst="0xab">
        </bits>
    </reg>

    <reg name="edge_dsp_set_1ch_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="pa_ramp_p9" pos="15:8" access="rw" rst="0xbe">
        </bits>
        <bits name="pa_ramp_p10" pos="7:0" access="rw" rst="0xce">
        </bits>
    </reg>

    <reg name="edge_dsp_set_1dh_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="pa_ramp_p11" pos="15:8" access="rw" rst="0xdd">
        </bits>
        <bits name="pa_ramp_p12" pos="7:0" access="rw" rst="0xe9">
        </bits>
    </reg>

    <reg name="edge_dsp_set_1eh_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="pa_ramp_p13" pos="15:8" access="rw" rst="0xf3">
        </bits>
        <bits name="pa_ramp_p14" pos="7:0" access="rw" rst="0xfa">
        </bits>
    </reg>

    <reg name="edge_dsp_set_1fh_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:8" access="rw" rst="0x0">
        </bits>
        <bits name="pa_ramp_p15" pos="7:0" access="rw" rst="0xfe">
        </bits>
    </reg>

    <reg name="digital_pll_set_20h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="freq_tx_offset" pos="17:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="digital_pll_set_21h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Lpfil1_tx_a2" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="11" access="rw" rst="0x0">
        </bits>
        <bits name="lpfill_tx_g" pos="10:0" access="rw" rst="0x4c">
        </bits>
    </reg>

    <reg name="digital_pll_set_22h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Lpfil1_tx_a2" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="lpfill_tx_a1" pos="11:0" access="rw" rst="0xb67">
        </bits>
    </reg>

    <reg name="digital_pll_set_23h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Dly_am_sel_d9n" pos="17:11" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_fts_cap_bit_d9n_edge_tx_lo" pos="10:9" access="rw" rst="0x1d3">
        </bits>
        <bits name="Rxpll_r_bit_d9n_edge_tx_lo" pos="8:7" access="rw" rst="0x1d3">
        </bits>
        <bits name="Rxpll_cp_bit_d9n_edge_tx_lo" pos="6:4" access="rw" rst="0x1d3">
        </bits>
        <bits name="Rxpll_vcogain_d9n_edge_tx_lo" pos="3:0" access="rw" rst="0x1d3">
        </bits>
    </reg>

    <reg name="digital_pll_set_24h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Dly_am_sel_d9n" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_tx_k_d9n" pos="14:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="digital_pll_set_25h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Lpfil2_tx_g" pos="17:13" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="12" access="rw" rst="0x0">
        </bits>
        <bits name="Lpfil2_tx_a1" pos="11:0" access="rw" rst="0xb67">
        </bits>
    </reg>


    <reg name="digital_pll_set_26h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Lpfil2_tx_g" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="Lpfil2_tx_a2" pos="11:0" access="rw" rst="0x1d3">
        </bits>
    </reg>


    <reg name="digital_pll_set_27h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_tx_a2" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_tx_b1" pos="11:0" access="rw" rst="0xd60">
        </bits>
    </reg>


    <reg name="digital_pll_set_28h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_tx_a2" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_tx_b2" pos="11:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="digital_pll_set_29h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_tx_a1" pos="11:0" access="rw" rst="0xfcd">
        </bits>
    </reg>


    <reg name="digital_pll_set_2ah_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Dly_am_sel_d9" pos="17:11" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_fts_cap_bit_d9_edge_tx_lo" pos="10:9" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_r_bit_d9_edge_tx_lo" pos="8:7" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_cp_bit_d9_edge_tx_lo" pos="6:4" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_vcogain_d9_edge_tx_lo" pos="3:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="digital_pll_set_2bh_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Dly_am_sel_d9n" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="Equfil_tx_k_d9" pos="14:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="digital_pll_set_2ch_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved_dsp" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Rx_gain_table_enable" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved_dsp" pos="15:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="digital_pll_set_2dh_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Offset_value" pos="17:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="digital_pll_set_2eh_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Offset_value" pos="17:12" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="11:10" access="rw" rst="0x0">
        </bits>
        <bits name="Freq_synthesize" pos="9:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="digital_pll_set_2fh_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Freq_synthesize" pos="17:0" access="rw" rst="0x0">
        </bits>
    </reg>

    <reg name="digital_pll_set_30h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Rfpll_vco_ibit" pos="16:10" access="rw" rst="0x0">
        </bits>
        <bits name="Rfpll_vcobuf_ibit" pos="9:3" access="rw" rst="0x0">
        </bits>
        <bits name="Vco_vcom_var_bit" pos="2:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="digital_pll_set_31h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="reserved" pos="17:11" access="rw" rst="0x0">
        </bits>
        <bits name="Rfpll_lo_rx_enable_td" pos="10" access="rw" rst="0x0">
        </bits>
        <bits name="Vco_varcom_bit" pos="9:8" access="rw" rst="0x0">
        </bits>
        <bits name="Vco_div_reg_bit" pos="7:1" access="rw" rst="0x0">
        </bits>
        <bits name="Vco_div_sel" pos="0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="digital_pll_set_32h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_band_cap" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_band_res" pos="15:13" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_op_ibit" pos="12:11" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_thermo_gain" pos="10:7" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_input_swing" pos="6:4" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_iq_swap" pos="3" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_lo_reg" pos="2:0" access="rw" rst="0x0">
        </bits>
    </reg>
    <reg name="digital_pll_set_33h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="17:8" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_pll_test_gsm" pos="7" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_pll_test_edge" pos="6" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_swbias_bit" pos="5:2" access="rw" rst="0x0">
        </bits>
        <bits name="Tmx_gaindac_ref" pos="1:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="digital_pll_set_34h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_reg_div2" pos="17:14" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_reg_digi_bit" pos="13:10" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_reg_flt_bit" pos="9:7" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_reg_fltcal_bit" pos="6:4" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_reg_pres_bit" pos="3:0" access="rw" rst="0x0">
        </bits>
    </reg>



    <reg name="digital_pll_set_35h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_reg_div_adc" pos="16:13" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_phase_ctrl_dly" pos="12:9" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_div_adclk" pos="8:1" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_xfer_aux_en" pos="0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="digital_pll_set_36h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Reserved" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_vco900_enable" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_sink_mode" pos="15:13" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_cal_clk_sel" pos="12" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_fbc_sel" pos="11:9" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_open_en" pos="8" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_cal_bit" pos="7:6" access="rw" rst="0x0">
        </bits>
        <bits name="Rxpll_pfd_res_bit" pos="5:0" access="rw" rst="0x0">
        </bits>
    </reg>



    <reg name="digital_pll_set_37h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Vga_reg_ibit" pos="17:16" access="rw" rst="0x0">
        </bits>
        <bits name="Vga_thermo_gain" pos="15:14" access="rw" rst="0x0">
        </bits>
        <bits name="Vga_balun_capbank_bi" pos="13:11" access="rw" rst="0x0">
        </bits>
        <bits name="Vga_r_bit0" pos="10:9" access="rw" rst="0x0">
        </bits>
        <bits name="Vga_r_bit1" pos="8:6" access="rw" rst="0x0">
        </bits>
        <bits name="Vga_r_bit2" pos="5:3" access="rw" rst="0x0">
        </bits>
        <bits name="Vga_r_bit3" pos="2:0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="digital_pll_set_38h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Vga_r_bit4" pos="17:15" access="rw" rst="0x0">
        </bits>
        <bits name="Vga_r_bit5" pos="14:12" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_pkdtc_enable" pos="11" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_pkdtc_in" pos="10" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_curr_sw" pos="9" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_ptat_var" pos="8:5" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_dac_ref_bit" pos="4:3" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_gain_bit" pos="2:1" access="rw" rst="0x0">
        </bits>
        <bits name="Thermo_test_en" pos="0" access="rw" rst="0x0">
        </bits>
    </reg>


    <reg name="digital_pll_set_39h_2" protect="rw">
        <bits name="write_req" pos="31" access="rw" rst="0x0">
        </bits>
        <bits name="read_req" pos="30" access="rw" rst="0x0">
        </bits>
        <bits name="Sel_bg" pos="17" access="rw" rst="0x0">
        </bits>
        <bits name="Ldo_bypass" pos="16" access="rw" rst="0x0">
        </bits>
        <bits name="Ldo_pd_mode" pos="15" access="rw" rst="0x0">
        </bits>
        <bits name="Ldo_vbit_lv" pos="14:12" access="rw" rst="0x0">
        </bits>
        <bits name="Ldo_vbit" pos="11:9" access="rw" rst="0x0">
        </bits>
        <bits name="Ldo_cur_lmt" pos="8:1" access="rw" rst="0x0">
        </bits>
        <bits name="Ldo_bypass_lv" pos="0" access="rw" rst="0x0">
        </bits>
    </reg>
</module>

</archive>

<archive relative='bb2g.xml' >


  <include file="globals.xml"/>
  <include file="global_macros.xml"/>
  <include file="bb2g_generic_config.xml"/>

  

  <include file="aif.xml" />
  <include file="voc_ram.xml" />
  <include file="voc_ahb.xml" />
  <include file="voc_cfg.xml" />
  <include file="bb_ahb_monitor.xml" />
  <include file="bb_cp2.xml" />
  <include file="bb_ifc.xml" />
  <include file="bb_irq.xml" />
  <include file="bb_sram.xml" />
  <include file="comregs.xml" />
  <include file="bcpu_cache.xml" />
  <include file="bcpu_tag.xml" />
  <include file="cipher.xml" />
  <include file="excor.xml" />
  <include file="evitac.xml" />
  <include file="cordic.xml" />
  <include file="debug_host.xml" />
  <include file="debug_host_internals.xml" />
  <include file="debug_uart.xml" />
  <include file="dma.xml" />
  <include file="mem_bridge.xml" />
  <include file="gpio.xml" />
  <include file="itlv.xml" />
  <include file="page_spy.xml" />
  <include file="rf_if.xml" />
  <include file="rf_spi.xml" />
  <include file="sci.xml" />
  <include file="spi.xml" />
  <include file="sys_ahb_monitor.xml" />
  <include file="sys_ctrl.xml" />
  <include file="sys_ifc.xml" />
  <include file="sys_irq.xml" />
  <include file="tcu.xml" />
  <include file="timer.xml" />
  <include file="vitac.xml" />
  <include file="xcor.xml" />
  <include file="cp0.xml" />
  <include file="regdef.xml" />
  <include file="xcpu_cache.xml" />
  <include file="xcpu_tag.xml" />
  <include file="xcpu.xml" />
  <include file="calendar.xml" />
  <include file='cfg_regs.xml' />
  <include file="sys_ctrl_ap.xml" />
  <include file="uart.xml" />
  <include file="sdmmc.xml" />
  <include file="keypad.xml" />
  <include file="pwm.xml" />
  <include file="i2c_master.xml" />
  <include file="timer_ap.xml" />
  <include file="apb1_ifc.xml" />
  <include file="apb2_ifc.xml" />
  <include file="ap_irq.xml" />
  <include file="gouda.xml" />
  <include file="camera.xml" />
  <include file="dma_ap.xml" />
  <include file="nand_ctrl.xml" />
  
  <include file="memory_burst_adapter.xml" />

  <include file="pmu.xml" />
  <include file="abb.xml" />
  <include file="tranceiver.xml" />


  
  <include file="xcv_rda6220e.xml" />

  
  <instance address="0x00000000" type="debug_host_internal_registers" name="INT_REG_DBG_HOST" />

  
  <instance address="0x02000000" type="ebc_cs0" name="CS0" />
  <instance address="0x018c0000" type="mem_FIFO" name="MEM_FIFO" />

  <instance address="0x01c00000" type="int_sram" name="INT_SRAM" />
  <instance address="0x01e00000" type="int_rom" name="INT_ROM" />

  <var name="DPSRAM_BASE" value="0x018a0000"><comment>DPSRAM base</comment></var>
  <var name="REG_AP_APB0_BASE" value="0x00800000"><comment>AP APB0 base</comment></var>
  <var name="REG_AP_APB1_BASE" value="0x00900000"><comment>AP APB1 base</comment></var>
  <var name="REG_AP_APB2_BASE" value="0x00a00000"><comment>AP APB2 base</comment></var>
  <var name="DDR_BASE" value="0x02800000"><comment>DDR base</comment></var>

  <instance address="REG_AP_APB0_BASE + AP_APB0_STEP * AP_APB0_ID_IRQ" type="ap_irq" name="AP_IRQ" />
  <instance address="REG_AP_APB0_BASE + AP_APB0_STEP * AP_APB0_ID_GOUDA" type="gouda" name="AP_GOUDA" />
  <instance address="REG_AP_APB0_BASE + AP_APB0_STEP * AP_APB0_ID_CAMERA" type="camera" name="AP_CAMERA" />
  <instance address="REG_AP_APB0_BASE + AP_APB0_STEP * AP_APB0_ID_DMA" type="dma_ap" name="AP_DMA" />

  <instance address="REG_AP_APB1_BASE + AP_APB1_STEP * AP_APB1_ID_SYSCTRL" type="sys_ctrl_ap" name="AP_SYS_CTRL" />
  <instance address="REG_AP_APB1_BASE + AP_APB1_STEP * AP_APB1_ID_TIMER" type="timer_ap" name="AP_TIMER" />
  <instance address="REG_AP_APB1_BASE + AP_APB1_STEP * AP_APB1_ID_KEYPAD" type="keypad" name="AP_KEYPAD" />
  <instance address="REG_AP_APB1_BASE + AP_APB1_STEP * AP_APB1_ID_GPIO" type="gpio" name="AP_GPIO_A" />
  <instance address="REG_AP_APB1_BASE + AP_APB1_STEP * AP_APB1_ID_GPIO + 0x00001000" type="gpio" name="AP_GPIO_B" />
  <instance address="REG_AP_APB1_BASE + AP_APB1_STEP * AP_APB1_ID_GPIO + 0x00002000" type="gpio" name="AP_GPIO_D" />
  <instance address="REG_AP_APB1_BASE + AP_APB1_STEP * AP_APB1_ID_PWM" type="pwm" name="AP_PWM" />
  <instance address="REG_AP_APB1_BASE + AP_APB1_STEP * AP_APB1_ID_I2C1" type="i2c_master" name="AP_I2C1" />
  <instance address="REG_AP_APB1_BASE + AP_APB1_STEP * AP_APB1_ID_I2C2" type="i2c_master" name="AP_I2C2" />
  <instance address="REG_AP_APB1_BASE + AP_APB1_STEP * AP_APB1_ID_I2C3" type="i2c_master" name="AP_I2C3" />
  <instance address="REG_AP_APB1_BASE + AP_APB1_STEP * AP_APB1_ID_COMREGS" type="comregs" name="AP_COMREGS" />
  <instance address="REG_AP_APB1_BASE + AP_APB1_STEP * AP_APB1_ID_AIF" type="aif" name="AP_AIF" />
  <instance address="REG_AP_APB1_BASE + AP_APB1_STEP * AP_APB1_ID_IFC" type="apb1_ifc" name="AU_IFC" />

  <instance address="REG_AP_APB2_BASE + AP_APB2_STEP * AP_APB2_ID_UART1" type="uart" name="AP_UART1" />
  <instance address="REG_AP_APB2_BASE + AP_APB2_STEP * AP_APB2_ID_UART2" type="uart" name="AP_UART2" />
  <instance address="REG_AP_APB2_BASE + AP_APB2_STEP * AP_APB2_ID_UART3" type="uart" name="AP_UART3" />
  <instance address="REG_AP_APB2_BASE + AP_APB2_STEP * AP_APB2_ID_SPI1" type="spi" name="AP_SPI1" />
  <instance address="REG_AP_APB2_BASE + AP_APB2_STEP * AP_APB2_ID_SPI2" type="spi" name="AP_SPI2" />
  <instance address="REG_AP_APB2_BASE + AP_APB2_STEP * AP_APB2_ID_SPI3" type="spi" name="AP_SPI3" />
  <instance address="REG_AP_APB2_BASE + AP_APB2_STEP * AP_APB2_ID_SDMMC1" type="sdmmc" name="AP_SDMMC1" />
  <instance address="REG_AP_APB2_BASE + AP_APB2_STEP * AP_APB2_ID_SDMMC2" type="sdmmc" name="AP_SDMMC2" />
  <instance address="REG_AP_APB2_BASE + AP_APB2_STEP * AP_APB2_ID_SDMMC3" type="sdmmc" name="AP_SDMMC3" />
  <instance address="REG_AP_APB2_BASE + AP_APB2_STEP * AP_APB2_ID_IFC" type="apb2_ifc" name="AP_APB2_IFC" />
  <instance address="REG_AP_APB2_BASE + AP_APB2_STEP * AP_APB2_ID_NFSC" type="nand_ctrl" name="AP_NFSC" />

  
  <var name="AP_VOC_BASE" value="0x000c0000"><comment>AP VOC base</comment></var>
  <instance address="AP_VOC_BASE+0x00000000" type="voc_ram" name="VOC_RAM" />
  <instance address="AP_VOC_BASE+0x0001ff80" type="voc_cfg" name="VOC_CFG" />
  <instance address="AP_VOC_BASE+0x00030000" type="voc_ahb" name="VOC_AHB" />

  

  <var name="REG_SYS_APB_BASE" value="0x01a00000"><comment>System APB base</comment></var>

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SYS_CTRL" type="sys_ctrl" name="SYS_CTRL" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_IRQ" type="sys_irq" name="SYS_IRQ" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_TIMER" type="timer" name="TIMER" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_EBC" type="mem_bridge" name="MEM_BRIDGE" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_DMA" type="dma" name="DMA" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_IFC" type="sys_ifc" name="SYS_IFC" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_CALENDAR" type="calendar" name="CALENDAR" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_COMREGS" type="comregs" name="SYS_COMREGS" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_GPIO" type="gpio" name="GPIO" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_CFG" type="cfg_regs" name="CONFIG_REGS" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_COMREGS_AP" type="comregs" name="SYS_COMREGS_AP" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_PAGE_SPY" type="page_spy" name="PAGE_SPY" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_RF_SPI" type="rf_spi" name="RF_SPI" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_TCU" type="tcu" name="TCU" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SYS_AHBC_MON" type="sys_ahb_monitor" name="SYS_AHB_MONITOR" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_BB_AHBC_MON" type="bb_ahb_monitor" name="BB_AHB_MONITOR" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SCI1" type="sci" name="SCI1" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SCI2" type="sci" name="SCI2" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SCI3" type="sci" name="SCI3" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SPI1" type="spi" name="SPI1" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SPI2" type="spi" name="SPI2" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_DEBUG_UART" type="debug_uart" name="DEBUG_UART" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_XCPU_REG" type="xcpu" name="XCPU" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_XCPU_TAG" type="xcpu_tag" name="XCPU_TAG" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_XCPU_IDATA" type="xcpu_cache" name="XCPU_IDATA" />

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_XCPU_DDATA" type="xcpu_cache" name="XCPU_DDATA" />

  
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_DEBUG_HOST" type="debug_host" name="DEBUG_HOST" />

  

  <instance address="0x01980000" type="bb_sram" name="BB_SRAM" />

  <var name="REG_BB_APB_BASE" value="0x01900000"><comment>Baseband APB base</comment></var>

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_XCOR" type="xcor" name="XCOR" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_IFC" type="bb_ifc" name="BB_IFC" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_IRQ" type="bb_irq" name="BB_IRQ" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_ITLV" type="itlv" name="ITLV" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_VITERBI" type="vitac" name="VITAC" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_A5" type="cipher" name="CIPHER" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_RF" type="rf_if" name="RF_IF" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_CP2" type="bb_cp2" name="BB_CP2" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BCPU_REG" type="xcpu" name="BCPU" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BCPU_TAG" type="bcpu_tag" name="BCPU_TAG" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BCPU_IDATA" type="bcpu_cache" name="BCPU_IDATA" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BCPU_DDATA" type="bcpu_cache" name="BCPU_DDATA" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_COMREGS" type="comregs" name="BB_COMREGS" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_EXCOR" type="excor" name="EXCOR" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_EVITAC" type="evitac" name="EVITAC" />

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_CORDIC" type="cordic" name="CORDIC" />


  <instance address="0x02000000" type="memory_burst_adapter" name="CS0_conf" />





  <instance address="0xa2000000" type="tranceiver" name="XCV" />

  
  <instance address="0xa2000200" type="abb_page0" name="ABB_000_00A" />
  <instance address="0xa2000240" type="abb_page1" name="ABB_040_06C" />
  <instance address="0xa2000300" type="abb_page2" name="ABB_120_147" />
  
  <instance address="0xa2000400" type="pmu" name="PMU" />
  
  <instance address="0xa2000580" type="ap_pll_page0" name="AP_PLL_000_00A" />
  <instance address="0xa20005c0" type="ap_pll_page1" name="AP_PLL_020_02A" />
  <instance address="0xa2000600" type="ap_pll_page2" name="AP_PLL_060_06A" />
  <instance address="0xa2000640" type="ap_pll_page3" name="AP_PLL_080_08A" />
  <instance address="0xa2000680" type="ap_pll_page4" name="AP_PLL_100_10A" />
  <instance address="0xa20006c0" type="ap_pll_page5" name="AP_PLL_120_12A" />
  <instance address="0xa2000700" type="ap_pll_page6" name="AP_PLL_140_14A" />
  <instance address="0xa2000740" type="ap_pll_page7" name="AP_PLL_160_16A" />
  <instance address="0xa2000780" type="ap_pll_page8" name="AP_PLL_180_18B" />

</archive>


</bigarchive>
